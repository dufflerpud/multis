;	@HDR@	$Id$
;	@HDR@		Copyright 1979-2024 by
;	@HDR@		Christopher Caldwell/Brightsands
;	@HDR@		P.O. Box 401, Bailey Island, ME 04003
;	@HDR@		All Rights Reserved
;	@HDR@
;	@HDR@	This software comprises unpublished confidential information
;	@HDR@	of Brightsands and may not be used, copied or made available
;	@HDR@	to anyone, except in accordance with the license under which
;	@HDR@	it is furnished.
	UNIVERSAL PACK				;PAGE 1

;	PACK.MAC
;	CREATED BY CHRISTOPHER M. CALDWELL
;	AT THE UNIVERSITY OF NEW HAMPSHIRE
;	COPYWRITE:  JULY 12, 1979
;	LAST REVISED:  MARCH 14, 1982

;	THIS MACRO-10 SUBROUTINE PACKAGE CONTAINS I/O DRIVERS,
;	TERMINAL AND PLOTTING OUTPUT FACILITIES, STRING PARSING
;	AND CONVERSION ROUTINES AND OTHER SYSTEM UTILITY
;	INTERFACES (GETTABS, MONITOR CALLS, CONTROL-C STUFF ETC).
;	IF %HISEG = 0, IT ALSO DEFINES A SET OF HISEGMENT ARRAY
;	MANIPULATION ROUTINES FOR MULTI-USER PROGRAMMING.

	SALL

	%HISEG==0	;0 MEANS HIPAK, ELSE USRPAK
			;IF HIPAK, HISEGMENT ROUTINES ARE INCLUDED
			;AND AS MUCH CODE AS POSSIBLE IS PUT IN HISEG.

COMMENT/

WHO						PAGE  2
DATIME						PAGE  3
OUTDAT						PAGE  4
INDAT						PAGE  5
USRSET						PAGE  6
FILES						PAGE  7
OUTPUT						PAGE  8
INPUT						PAGE  9
STROPR						PAGE 10
CONVRT						PAGE 11
JOBCON						PAGE 12
IPCF						PAGE 13
TEMP						PAGE 14
MATH						PAGE 15
CNTRLC						PAGE 16
EXADEP						PAGE 17
USRDDT						PAGE 18
RANDOM						PAGE 19
UPP						PAGE 20
UPP SYMBOL TABLES				PAGE 21
I.O.						PAGE 22
ALLOC						PAGE 23
ERROR						PAGE 24
-------------------------------------------------------
HISEG						PAGE 25
MAIN						PAGE 26

/

	%HIDBG==0	;0 MEANS NO HISEGMENT DEBUGGING, ELSE DEBUG
	%HAVEPLOT==0	;0 MEANS WE HAVE NO PLOTTER PACAKGE
	.JBINT==134	;DEFINE INTERUPT VECTOR
	.JBCST==136	;DEFINE CUSTOMER LOCATION IN JOBDAT
	.JBREL==44	;DEFINE LOCATION CONTAINING SIZE OF LOW CORE
	%MXCHN==20		;MAX NUMBER OF CHANNELS ALLOWABLE.
	.BFPOS==3		;OFFSET OF BUFFER POSITION WORD.
	%BFSIZ==200		;DEFAULT BUF SIZE
	%BFNUM==2		;DEFAULT NUMBER OF BUFFERS.

;	DEFINE REGISTERS

	TEMP==0
	T1==1
	T2==2
	T3==3
	T4==4
	T5==5
	T6==6
	T7==7
	T10==10
	T11==11
	CHAR==11	;REGISTER PASSED AROUND IN OUTPUT FOR FILE IO
	T12==12
	T13==13
	T14==14
	T15==15
	ARG==16
	STACK==17

	%SCRWID==^D80
	%SCRLEN==^D24
	%BITSPW==^D18			; 22
	%WSIZE==^D36			; 44
	%CRSPWD==%WSIZE/%BITSPW		; 2
	%SCRSIZ==%SCRWID*%SCRLEN	; ^D1920
	%SCRWDS==%SCRSIZ/%CRSPWD	; ^D960
	%WPSIZE==%WSIZE*10000		; 440000
	%BPSIZE==%BITSPW*100		; 002200
	%SCRBP==%WPSIZE+%BPSIZE		; 442200

;	SOME PSEUDO-INSTRUCTIONS

	OPDEF	GOTO	[JRST	0,]
	OPDEF	SAVE	[PUSH	STACK,]
	OPDEF	RESTORE	[POP	STACK,]
	OPDEF	CALL	[PUSHJ	STACK,]
	OPDEF	RETURN	[POPJ	STACK,]

	DEFINE	COMPOSE( FG, BG, CHAR ) < FG*^D256*^D8 + BG*^D256 + CHAR >
	DEFINE	FATAL( MESSAG )	;FATAL ERROR MACRO
<	GOTO	[
	OUTSTR	[ASCIZ/
?hipak 'MESSAGE
/]
	EXIT				] >

	PRGEND
	TITLE	WHO				;PAGE 2
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

;	IFLAG = LOGDIN( IJOB )	DETERMINE IF JOB IS LOGGED IN

	ENTRY	LOGDIN
LOGDIN:	MOVEI	TEMP,.GTPPN	;IF PPN IS 0,0, NOT LOGGED IN
	HRL	TEMP,@0(ARG)
	GETTAB	TEMP,		;GET PPN FROM GETTAB TABLES
	SETZ	TEMP,		;IF ERROR, DEFINATELY NOT JOB
	SKIPE	TEMP
	SETO	TEMP,		;RETURN -1(TRUE) IF NOT ZERO
	RETURN

;	I = JOB(0)		RETURNS USER'S JOB NUMBER.

	ENTRY	JOB
JOB:	PJOB	TEMP,
	RETURN

;	I = ITTY( IJOB )	RETURNS TTY IJOB IS CONNECTED TO.
;				-1 MEANS JOB IS DETACHED.

	ENTRY	ITTY
ITTY:	MOVE	TEMP,@0(ARG)	;GET JOB NUMBER TO FIND UDX
	TRMNO.	TEMP,		;GET UDX CODE
	MOVEI	TEMP,.UXTRM-1	;ERROR, SET SO SUB = -1
	SUBI	TEMP,.UXTRM	;MAKE TTYNUM, DETACH = -1
	RETURN

;	I = NODE( NODNUM )	RETURNS SIXBIT NODE NAME FROM NODNUM
;		OR
;	I = NODE( NODNAM )	RETURNS NODE NUMBER FOR SIXBIT NODNAM

	ENTRY	NODE
NODE:	SETZM	ERRFLG		;NO ERRORS YET
	MOVE	TEMP,@0(ARG)	;GET NODE NAME OR NUMBER
	SKIPE	TEMP		;IS THIS THE SPECIAL CASE?
	GOTO	RELNOD		;NOPE, GO DO THE CALL
	MOVE	TEMP,[SIXBIT/CENTRA/]	;YUP, PUT IN MAGIC VALUE
	RETURN

RELNOD:	MOVEM	TEMP,NODADR+1	;AND STUFF IN NODE BLOCK
	MOVE	TEMP,[XWD 2,NODADR]	;SET UP FOR NODE.
	NODE.	TEMP,		;ASK MONITOR FOR NODE
	SETOM	ERRFLG		;GOT AN ERROR, FLAG IT
	RETURN

IFE %HISEG,	<RELOC>		;LOW
NODADR:	.NDRNN			;RETURN NODE NAME OR NUMBER
	0			;WHERE TO PUT IT
IFE %HISEG,	<RELOC>		;HIGH

;	CALL NODLIN( ITTY, NODNUM, ITTYLN )	RETURNS NODE AND
;						LINE FROM ITTY

	ENTRY	NODLIN
NODLIN:	MOVE	TEMP,@0(ARG)	;GET TERMINAL NUMBER
	ADDI	TEMP,.UXTRM	;MAKE IT UDX CODE FOR MONITOR
	GTNTN.	TEMP,		;ASK MONITOR FOR IT
	SETZ	TEMP,		;MUST BE DETACHED
	HLRZM	TEMP,@1(ARG)	;PUT NODE IN SECOND ARG
	HRRZM	TEMP,@2(ARG)	;AND LINE IN THIRD ARG
	RETURN

;	CALL PPN( IP, IPN )	RETURNS JOB'S PPN

	ENTRY	PPN
PPN:	GETPPN	TEMP,		;ASK MONITOR FOR MY PPN
	JFCL			;FUNNY RETURN IF PRIVD (!)
	HLRZM	TEMP,@0(ARG)	;PUT PROJECT IN SECOND ARG
	HRRZM	TEMP,@1(ARG)	;AND PROGRAMMER IN THIRD ARG
	RETURN

;	I = ICJOB( IJOB )	RETURN'S JOB'S CONTROLLING JOB
;				OR -1 IF IT IS NOT A PTY

	ENTRY	ICJOB
ICJOB:	MOVE	TEMP,@0(ARG)	;GET JOB NUMBER
	CTLJOB	TEMP,		;GET ITS CONTROLLER FROM MON
	SETO	TEMP,		;RETURN AN ERROR CODE OF SORTS
	RETURN


;	I = JSTAT( IJOB )	RETURNS JOB'S SIXBIT JOB QUEUE
;				NAMES IN THE FIRST TWO BYTES

;THE BIT MANIPULATION IN THIS ROUTINE IS BORROWED FROM THE SYSTEM'S
;PROGRAM GOD.  THE BITS ARE NOT DOCUMENTED (ACCORDING TO THE 603
;MONITOR CALLS MANUAL, THEY ARE EXPLICITLY NOT DOCUMENTED!) SO THE
;CODING MAY BE PECULIAR.

	ENTRY	JSTAT
JSTAT:	SAVE	T2		;SINCE ITS A FUNCTION, CAN'T MESS IT UP
	HRL	T2,@0(ARG)	;GET INDEX (JOB) FOR GETTAB
	HRRI	T2,.GTSTS	;TO FIND JOB STATUS
	GETTAB	T2,		;ASK MONITOR
	SETZ	T2,		;ERROR RETURN
	LDB	TEMP,[POINT 5,2,14]	;TO GET FROM .GTWSN Q NAMES
	IDIVI	TEMP,3		;GET Q INDEX
	HRL	TEMP,TEMP	;GOING TO USE THAT AS INDEX TO 
	HRRI	TEMP,.GTWSN	;GET SIXBIT Q NAMES
	GETTAB	TEMP,		;ASK MONITOR
	SETZ	TEMP,		;ERROR RETURN
	LDB	T1,TBL(TEMP+1)	;GET THE TWO LETTERS FROM THE SIX
	CAIE	T1,'TI'		;IF ITS NOT TI
	GOTO	NOTTI		;SKIP THIS
	MOVN	T1,@0(ARG)	;SETUP FOR JOBSTS
	JOBSTS	T1,		;REQUEST JOB STATUS BITS
	JFCL			;ERROR RETURN
	TLNN	T1,JB.UTO/1000000	;IF OUTPUT IS AVAILABLE
	GOTO	ISNTO		;THIS REALLY IS INPUT WAIT
	MOVEI	T1,'TO'		;THIS IS TO WAIT
	GOTO	NOTTI
ISNTO:	MOVEI	T1,'TI'		;THIS IS REALLY INPUT WAIT
NOTTI:	TLNN	T2,400000	;UNDOCUMENTED BITS.  GOT ME!?
	MOVEI	T1,'^C'		;IN MONITOR STATE
	TLNE	T2,200000
	MOVEI	T1,'^W'		;IN COMMAND WAIT
	TRNE	T2,20000
	MOVEI	T1,'OW'		;MISCELANIOUS DEVICE WAIT
	CAIE	T1,'SL'		;IF IT THOUGHT IT WAS SLEEPING
	GOTO	NOTSL
	TRNN	T2,400000	;IT MAY BE IN A SUBCLASS OF SLEEP
	MOVEI	T1,'HB'		;LIKE HB
NOTSL:	MOVE	TEMP,T1		;GET SIXBIT WORD
	LSH	TEMP,%SCRLEN	;AND MAKE IT FIRST 12 BITS
	RESTORE	T2		;VALUE OF FUNCTION RETURNED IN AC 0
	RETURN

TBL:	POINT	12,0,11		;INDICES INTO JOB Q TABLE
	POINT	12,0,23
	POINT	12,0,35


;	I = IDIAL( TTY )	RETURNS TRUE IF TTY IS DIALUP

	ENTRY	IDIAL
IDIAL:	MOVE	T1,@0(ARG)	;GET TERMINAL NUMBER
	ADDI	T1,.UXTRM	;MAKE IT UDX FOR MONITOR
	GETLCH	T1		;GET ITS LINE CHARACTERSTICS
	SETZ	TEMP,		;BY DEFAULT IT IS NOT DIALUP
	TLNE	T1,GL.DSL/1000000	;UNLESS DATASET BIT IS SET
	SETO	TEMP,		;IN WHICH CASE IT IS
	RETURN			;VALUE OF FUNCTION RETURNED IN AC 0

;	I = IDLINE( SIXNAM )	RETURNS TTY NUMBER OF SIXBIT DEVICE

	ENTRY	IDLINE
IDLINE:	MOVE	TEMP,@0(ARG)	;GET SIXBIT ID TO FIND LINE NUMBER
	IONDX.	TEMP,		;GET LINE NUMBER IN UDX CODE
	SETZ	TEMP,		;ERROR RETURN
	SUBI	TEMP,.UXTRM	;MAKE IT A TERMINAL NUMBER
	RETURN			;AND RETURN VALUE IN AC 0


;	CALL CORSIZ( IJOB, ILOW, IHIGH, SWAP )	;RETURN PAGES IN
;				LOWSEG, HISEG AND IF SWAPPED

	ENTRY	CORSIZ
CORSIZ:	SETZM	@1(ARG)		;ZERO OUT ARGUMENTS TO START
	SETZM	@2(ARG)
	SETZM	@3(ARG)
	HRL	TEMP,@0(ARG)	;GET JOB NUMBER FOR GETTAB
	HRRI	TEMP,.GTSTS	;GET JOB STATUS BITS
	GETTAB	TEMP,		;FROM MONITOR
	RETURN			;DIE GRACEFULLY ON ERROR
	TLNN	TEMP,2000
	SETOM	@3(ARG)		;HE'S SWAPPED
	HRL	TEMP,@0(ARG)	;PREPARE TO
	HRRI	TEMP,.GTSWP	;GET SWAPPING TABLE
	GETTAB	TEMP,		;FROM MONITOR
	RETURN
	ANDI	TEMP,777	;ONLY USE THE LAST 9 BITS
	MOVEM	TEMP,@1(ARG)	;AND THAT IS THE LOWSEGMENT

	HRL	T2,@0(ARG)	;PREPARE TO
	HRRI	T2,.GTSGN	;GET HISEGMENT TABLE
	GETTAB	T2,		;FROM MONITOR
	RETURN
	JUMPL	T2,JSPY		;IF FIRST BIT SET, HE'S SPYING

	HRL	TEMP,T2		;OTHERWISE, USE THAT AS INDEX
	HRRI	TEMP,.GTADR	;TO GET JOB RELOCATION
	GETTAB	TEMP,		;FROM THE MONITOR
	RETURN
	HLRZ	TEMP,TEMP	;MAKE IT AN INDEX
	JUMPE	TEMP,SWAPPD	;ZERO MEANS WE DON'T KNOW SO SWAPPED
	ADDI	TEMP,777	;ELSE MAKE SURE ITS ONLY LAST 9 BITS
	IDIVI	TEMP,1000	;NOW GET SECOND 9 BITS
	ANDI	TEMP,777	;AND MAKE SURE THAT'S ONLY 9 BITS
	GOTO	EXCR

SWAPPD:	HRL	TEMP,@0(ARG)	;HE'S SWAPPED, CHECK
	HRRI	TEMP,.GTSGN	;HISEGMENT TABLE
	GETTAB	TEMP,		;FROM MONITOR
	RETURN
	HRL	TEMP,TEMP	;USE HISEG INDEX
	HRRI	TEMP,.GTSWP	;TO CHECK IF IT IS SWAPPED
	GETTAB	TEMP,		;ASK MONITOR
	RETURN
	ANDI	TEMP,777	;USE ONLY ITS LAST 9 BITS

EXCR:	MOVEM	TEMP,@2(ARG)	;AND RETURN THAT AS PAGES IN LOSEG
	TLNE	T2,200000	;IF NON SHAREABLE
	RETURN
	EXCH	TEMP,@1(ARG)	;LOW SEG IS TOTAL - HISEG
	SUBM	TEMP,@1(ARG)
	RETURN

JSPY:	HRRZ	TEMP,T2		;IF JOB WAS SPYING
	IDIVI	TEMP,1000	;RETURN NUMBER OF PAGES
	MOVNM	TEMP,@2(ARG)	;HE'S LOOKING AT (ONLY NEGATIVE)
	RETURN
	PRGEND
	TITLE	DATIME				;PAGE 3
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>

;	CALL DATIME( IDAY, MONTH, IYEAR, IHOUR, MINUTE, ISEC, MILSEC )
;				GET DATE AND TIME

	ENTRY	DATIME
DATIME:	DATE	TEMP,		;GET DATE (STANDARD FORMAT)
	IDIVI	TEMP,^D31	;DIVIDE OUT DAYS
	ADDI	TEMP+1,1	;ADD 1 (DAY 0 DOES NOT MAKE SENSE)
	MOVEM	TEMP+1,@0(ARG)	;AND RETURN IT
	IDIVI	TEMP,^D12	;DIVIDE OUT MONTHS
	ADDI	TEMP+1,1	;MONTH 0 DOESN'T MAKE SENSE EITHER
	MOVEM	TEMP+1,@1(ARG)	;AND RETURN IT
	ADDI	TEMP,^D1964	;ADD THE BEGINNING OF THE WORLD TO
	MOVEM	TEMP,@2(ARG)	;RESULT AND RETURN IT

	MSTIME	TEMP,		;NOW GET THE CURRENT TIME
	IDIVI	TEMP,^D1000	;GET MILLI-SECONDS
	MOVEM	TEMP+1,@6(ARG)	;AND RETURN THEM
	IDIVI	TEMP,^D60	;NOW SECONDS
	MOVEM	TEMP+1,@5(ARG)	;RETURN THEM
	IDIVI	TEMP,^D60	;MINUTES
	MOVEM	TEMP+1,@4(ARG)	;RETURN THEM
	MOVEM	TEMP,@3(ARG)	;RETURN REST AS HOUR

	RETURN

	PRGEND
	TITLE	OUTDAT				;PAGE 4
	SEARCH	PACK,UUOSYM

IFE %HISEG,	<TWOSEG	400000>



;	THIS SUBROUTINE DOES NOT OUTPUT THE DATE IN AND OF ITSELF,
;	BUT MERELY PLACES A STRING IN ISTRNG, THUS LEAVING IT UP TO
;	THE USER TO FIND A WAY OF OUTPUTTING THE STRING
;
;	CALL OUTDAT(IDATE,ISTRNG,ILENG,MAXLEN,TYPE[,SEPCHR])
;	WHERE:	IDATE	IS THE DATE IN TYPE FORMAT
;		ISTRNG	IS THE A1 FORMATTED STRING PASSED BACK BY OUTDAT.
;		ILENG	IS THE LENGTH OF THE STRING RETURNED IN ISTRNG.
;		MAXLEN	IS THE MAXIMUM DEFINED LENGTH OF ISTRNG
;		TYPE	IS TYPE OF DATE-TIME.  IF NEGATIVE, OUTPUT TIME AS
;			INTEGER RATHER THAN 0:0:0 FORMAT.
;			TYP IS:
;				0	FANCY UNIVERSAL FORMAT
;					DATE,,TIME
;				1-3	SYSTEM FORMAT
;					1	DATE,,TIME
;					2	DATE
;					3	TIME
;				4-6	UNIVERSAL FORMAT
;					4	DATE,,TIME
;					5	DATE
;					6	TIME
;				7	TIME IN JIFFIES TO SECONDS
;				8	TIME IN TICKS TO SECONDS
;				9	TIME IN MILLISECONDS TO SECONDS
;				10	TIME IN MILLISECONDS
;				11	TIME IN MINUTES TO SECONDS
;		SEPCHR	IS THE OPTIONAL CHAR SEPARATING THE DATE FROM TIME.
;			THIS CHARACTER DEFAULTS TO ":"
;
;
;
;


	CENTUR=^D19		;THE FIRST TWO DIGITS OF THIS CENTURY




	ENTRY	OUTDAT

OUTDAT:	SETZM	@2(ARG)		;ZERO COUNT OF CHARS
	MOVE	T1,@3(ARG)	;GET MAX LENGTH OF STRING
	ADDI	T1,@1(ARG)	;ADD LOC OF HEAD OF STRNG
	SOS	T1		;MINUS ONE TO GET OFFSET
	MOVEM	T1,MXLEN	;SAVE, SO WE CAN USE TO TEST EOL
	MOVEI	TEMP,@1(ARG)	;GET LOC OF STRING
	HRLS	TEMP
	AOS	TEMP
	SETZM	@1(ARG)		;ZERO FIRST WORD OF STRING
	BLT	TEMP,(T1)	;ZERO OUT STRING

	SETZM	INTIM		;INIT TO 0:0:0
	MOVE	T1,@4(ARG)	;GET TYPE OF DATE/TIME
	SKIPL	T1		;IF NEGATIVE, OUTPUT TIME AS INT.
	GOTO	ITIM
	SETOM	INTIM		;AND SET FLAG ACCORDINGLY, ALSO
	MOVNS	T1		;MAKE FLAG + SO WE CAN TEST IT.
ITIM:	SETO	TEMP,
	CAILE	T1,^D11		;MAXTYPE
	RETURN			;ELSE RETURN WITH ERROR IN F(AC0)
	MOVEM	T1,TYPFL	;SAVE IT..(DATYP)

	HLRO	TEMP,-1(ARG)	;GET LENGTH OF ARG BLOCK
	MOVNS	TEMP		;ARG IS -#,,0
	MOVE	T2,[ASCII/     /]	;DEFAULT SEPARATING CHAR
	CAILE	TEMP,5		;IF EXTRA OPTIONAL ARG
	MOVE	T2,@5(ARG)	;GET SPECIFIED SEP CHAR ,REPLACE DEFAULT
	MOVEM	T2,SEPCHR	;SAVE SEPARATING CHAR

	SAVE	[-1]		;SAVE ON STACK SO WE KNOW WHEN WE ARE AT END.
	HRRZ	T3,1(ARG)	;GET STRING LOC FOR OUTPUT PURPOSES
	SETZ	T5,
	MOVEI	T6,"0"		;SET NUMFMT TO 0(NO PADDING),PAD CHR "0"

	MOVE	TEMP,@0(ARG)	;GET DATE,,TIME
	CAIE	T1,2		;DATE IN RIGHT HALF
	CAIN	T1,5		;UNIVERSAL DATE IN RIGHT HALF
	HRLZ	TEMP,@0(ARG)	;TRANSFER..DATE GIVEN IN RH, FIX IT
	MOVEM	TEMP,WRKDAT	;SAVE IT

	JUMPE	T1,ISUNV	;IF 0,SPECIAL UNIVERSAL FORMAT
	CAIL	T1,4		;IF UNIVERSAL FORMAT...CONVERT
	CAIL	T1,7
	GOTO	NOTUN		;ELSE DON'T
	SUBI	T1,3		;ONCE CONVERTED, CAN TREAT AS SYS FMT
	MOVEM	T1,TYPFL	;RESET TYPFLAG
ISUNV:	SAVE	ARG		;SAVE ARG
	MOVEI	ARG,[WRKDAT]	;GET ARG POINTER.
	CALL	UNVSYS##	;CONVERT TO SYS FMT FROM UNIVERSAL FMT
	RESTORE	ARG		;RESTORE ORIGINAL ARG PTR
	MOVEM	TEMP,WRKDAT	;RESET STORAGE WORD.


NOTUN:	MOVE	TEMP,TYPFL	;GET TYPE, DESTROYED BY UNVSYS##
	CAIE	TEMP,3		;IF JUST TIME, DONT OUTPUT DATE
	CAIL	TEMP,7		;IF NOT SPECIAL FORMAT
	GOTO	NODAT
	HLRZ	TEMP,WRKDAT	;GET DATE
	CALL	ODAT		;DUMP IT

	MOVE	TEMP,TYPFL	;RE-GET TYPFLAG
	CAIN	TEMP,2		;IF NO TIME TO BE DUMPED, SKIP THIS PART
	GOTO	NOTIM
	MOVE	T1,SEPCHR	;GET SEPARATING CHARACTER
	CALL	PBYT+1		;DUMP IT, USING PBYT

NODAT:	MOVE	T1,WRKDAT	;GET DATE/TIME
	SKIPE	TEMP		;IF 0 OR
	CAIGE	TEMP,3		;IF DATE THERE TOO, ERASE IT
	HRRZS	T1

	CAIN	TEMP,7		;TIME IN JIFFIES??
	IDIVI	T1,^D60		;60 HZ IN THIS COUNTRY.

	CAIE	TEMP,^D8	;IF IN TICKS
	GOTO	NOTTCK
	MOVE	T2,[XWD 44,.GTCNF] ;TICKS PER SECOND
	GETTAB	T2,
	SETZ	T2,
	IDIV	T1,T2		;DIVIDE BY TICKS/SEC WANT IN SECONDS
NOTTCK:

	CAIE	TEMP,^D9	;IF IN MILLS.  DIVIDE BY 1000
	CAIN	TEMP,^D10
	IDIVI	T1,^D1000
	SAVE	T2		;SAVE MILLS IN CASE OF FUNCTION 9.


	CAIN	TEMP,^D11	;IF IN MINUTES(KSYS TIMER..) * BY 60
	IMULI	T1,^D60


	CALL	OTIM		;OUTPUT TIME..T1 HAS TIME IN IT

	RESTORE	T4		;RESTORE MILLS
	MOVE	TEMP,TYPFL	;GET TYPE
	CAIE	TEMP,^D10	;DO WE WANT TO OUTPUT MILLS TOO??
	GOTO	NOTIM
	MOVEI	T1,":"		;OUTPUT MILLS
	CALL	PBYT		;DUMP IT
	MOVE	T1,T4		;PUT MILLS IN ARG AC(T1)
	MOVEI	T5,3		;SET FIELD TO 3 DIGITS
	CALL	ONUM		;DUMP NUMBER

NOTIM:	SUBI	T3,@1(ARG)	;GET NUMBER OF CHARS WE'VE DUMPED.
	MOVEM	T3,@2(ARG)	;RETURN IT
	RESTORE	T1		;RESTORE AC'S
	SETZ	TEMP,
	SKIPA			
ENODAT:	SETO	TEMP,		;IF OK, SKIP THIS, ELSE SET ERROR.
	RETURN			;RETURN TO CALLING ROUTINE



ODAT:	IDIVI	TEMP,^D31	;GET DAYS
	AOS	T1		;INCRMENT TO DAY NUMBER
	MOVEI	T6," "		;USE SPACE INSTEAD OF 0 FOR PACKING
	MOVEI	T5,2		;HAVE TO HAVE 2 DIGITS
	CALL	ONUM		;OUTPUT THE DAYS TO STRING
	IDIVI	TEMP,^D12	;GET MONTHS
	MOVE	T2,MONAR(T1)	;GET LOC
	SKIPN	TYPFL		;IF 0, USE FANCY METHOD
	MOVE	T2,SPCMON(T1)	;SPECIAL MONTH SET
	SOS	T2
	HLL	T2,A5PNT	;MAKE IT A BYTE POINTER
DMMON:	ILDB	T1,T2		;GET BYTE FROM MON STRING
	JUMPE	T1,ENMN		;IF ZERO, END OF STRING
	CALL	PBYT		;DUMP IT TO DATE OUTPUT STRING
	GOTO	DMMON
ENMN:	ADDI	TEMP,^D1964	;ADD OFFSET
	IDIVI	TEMP,^D100	;DIVIDE 100
	SAVE	T1		;SAVE YEARS OF CENTURY
	MOVE	T1,TEMP
	CAIN	T1,CENTUR	;IF CENTURY MATCHES THISUN
	SKIPN	TYPFL		;IF ZERO, USE FANCY FORMAT
	CALL	ONUM		;DUMP CENTURY
	RESTORE	T1		;GET BACK SUB CENTURY YEARS
	MOVEI	T5,2		;ALWAYS HAVE TO DUMP 2 CHARS
	CALL	ONUM		;DUMP EM
	RETURN	




OTIM:	SKIPGE	T1		;IF NEG, MAKE POSITIVE
	MOVNS	T1
	SKIPE	INTIM		;IF <>0, THEN OUTPUT TIME AS INTEGER.
	GOTO	INTIME
	IDIVI	T1,^D60		;GET SECONDS.
	SAVE	T2		;SAVE SECONDS
	IDIVI	T1,^D60		;GET MINUTES.
	SAVE	T2		;SAVE MINUTES
	MOVEI	T5,2		;SET FIELD TO 2 DIGITS.
	MOVEI	T6," "		;PADDING CHAR.
	CALL	ONUM		;HOURS ARE IN T1, DUMP EM.
	MOVEI	T1,":"		;SEPARATOR.
	CALL	PBYT		;DUMP IT.
	RESTORE	T1		;DUMP MINUTES
	MOVEI	T5,2		;2 DIG FIELD WIDTH.
	CALL	ONUM		;AND DUMP THOSE
	MOVEI	T1,":"		;ANOTHER SEPARATOR
	CALL	PBYT
	RESTORE	T1		;POP OFF SECONDS
	MOVEI	T5,2		;DUMP THEM, TOO
	CALL	ONUM
	RETURN			;AND RETURN

INTIME:	CALL	ONUM		;DUMP NUMBER.  INTEGER TIME.
	RETURN			;AND RETURN

ONUM:	MOVEI	T4,"0"		;SET DEFAULT PADDING CHAR
	SAVE	[-2]		;SAVE FLAG(SAYS END OF NUMBER)
ILP:	IDIVI	T1,^D10		;WANT IT A DIGIT AT A TIME
	ADD	T2,T4		;ADD PADDING CHAR
	SAVE	T2		;SAVE THE DIGIT CHAR
	SOS	T5		;DECREMENT FIELD WIDTH COUNTER.
	SKIPE	T1		;WANT AT LEAST ONE DIGIT
	GOTO	ILP		;IF ZERO, WE'VE SAVED A "0"
	MOVE	T4,T6		;NEW CHAR.  IF " ", REPLACES "0"
	SKIPLE	T5		;IF WE HAVE TO PAD
	GOTO	ILP		;CONTINUE WITH THE ZERO VALUE,
OLP:				;ELSE DUMP THE NUMBER
	RESTORE	T1		;NOW WE DUMP EM
	CAMN	T1,[-2]		;IS IT END OF NUMBER FLAG?
	GOTO	ENM		;IF SO, QUIT.
	CALL	PBYT		;DUMP IT
	GOTO	OLP		;GET ANOTHER.
ENM:	SETZ	T5,		;SET FIELD WIDTH TO DEFAULT NOPADDING
	MOVEI	T6,"0"		;SET DEFAULT PAD CHAR TO "0"
	RETURN			;RETURN TO CALLING CODE.



PBYT:				;DUMPS ONE CHARACTER.
	LSH	T1,^D29		;DUMPS SINGLE CHAR..MAKE A1 FORMAT.
	MOVEM	T1,(T3)		;MAKE IT A1 FORMAT..SAVE IT IN STRING
	AOS	T3		;DUMP IT, AND INC CHAR COUNTER
	CAMG	T3,MXLEN	;R WE PAST END OF MAXSTRING??
	RETURN			;IF NOT, WE RETURN NORMALLY
DMSTK:	RESTORE	T1		;DUMP STACK UNTIL WE HIT THAT -1
	CAME	T1,[-1]		;WE THEN KNOW WE'VE COME TO END OF
	GOTO	DMSTK		;STACK. CAN THEN JUMP, INSTEAD OF POPJING.
	GOTO	ENODAT		;END OF STACK, JUMP TO RETURN ROUTINE

A5PNT:	POINT	7,0,35		;FOR USE IN DUMPING MONTHS

MONAR:	JA
	FE
	MA
	AP
	MY
	JU
	JL
	AU
	SE
	OC
	NO
	DE

SPCMON:	JAN
	FEB
	MAR
	APR
	MAY
	JUN
	JUL
	AUG
	SEP
	OCTO
	NOV
	DECE

JA:	ASCIZ/-Jan-/
FE:	ASCIZ/-Feb-/
MA:	ASCIZ/-Mar-/
AP:	ASCIZ/-Apr-/
MY:	ASCIZ/-May-/
JU:	ASCIZ/-Jun-/
JL:	ASCIZ/-Jul-/
AU:	ASCIZ/-Aug-/
SE:	ASCIZ/-Sep-/
OC:	ASCIZ/-Oct-/
NO:	ASCIZ/-Nov-/
DE:	ASCIZ/-Dec-/

JAN:	ASCIZ/-January-/
FEB:	ASCIZ/-February-/
MAR:	ASCIZ/-March-/
APR:	ASCIZ/-April-/
MAY:	ASCIZ/-May-/
JUN:	ASCIZ/-June-/
JUL:	ASCIZ/-July-/
AUG:	ASCIZ/-August-/
SEP:	ASCIZ/-September-/
OCTO:	ASCIZ/-October-/
NOV:	ASCIZ/-November-/
DECE:	ASCIZ/-December-/


IFE %HISEG,	<RELOC>		;LOW

MXLEN:	Z			;USED TO CHECK FOR EXCEEDING MAXSTRING
TYPFL:	Z			;TYPE FLAG
INTIM:	Z			;IF <> 0, THEN OUTPUT TIME AS INTEGER, NOT 0:0:0
SEPCHR:	Z			;SEPARATING CHARACTER
WRKDAT:	Z			;WORK AREA FOR DATE

IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	TITLE	INDAT				;PAGE 5
	SEARCH	PACK,UUOSYM
IFE %HISEG,	<TWOSEG	400000>

;	THIS SUBROUTINE GETS A DATE FROM THE INPUT STRING, AND GIVES IT
;	TO THE USER IN SYSTEM FORMAT
;
;	CALL	INDAT(ISTRNG,ILENG,IDATE)
;
;	WHERE	ISTRNG IS AN A1 FORMATTED ARRAY WITH
;		ILENG CHARACTERS IN IT.  
;		IDATE IS THE DATE RETURNED IN SYSTEM FORMAT.
;
;



	SYMMAX=100		;MAX OF SYMBOLS WE CAN PARSE
	CENTUR=^D1900		;THIS CENTURY

	ENTRY	INDAT



INDAT:	SAVE	ARG
	CALL	DATNOW		;SET DEFAULT DATE TO NOW
	MOVEM	TEMP,DATWRD	;SAVE IT
	SETZM	ERRFLG##	;INIT ERROR FLAG
	SETZM	DATSYM		;ZERO OUT SYMBOL TABLE
	MOVE	T1,[DATSYM,,DATSYM+1]
	BLT	T1,SYMPOS+SYMMAX
	MOVEI	T1,@0(ARG)	;GET LOC OF STRING
	MOVEM	T1,STRLC
	MOVE	T1,@1(ARG)	;GET LENGTH OF STRING
	MOVEM	T1,LNG		;SAVE IT
	CALL	PARS		;PARS THE STRING INTO SIXBIT SYMBOLS
	SETZ	T6,		;INIT SYMBOL POINTER
EXPLP:				;THEY WILL BE IN DATSYM, LOC IN SYMPOS.
	MOVE	T2,DATSYM(T6)	;GET SYMBOL.
	SETZM	NGFLG		;INIT NEG FLAG
	CAME	T2,DSH		;IF SYMBOL IS A "-"...SET NEG, ELSE
	GOTO	NTNEG		;THEN THIS IS NOT A NEGATIVE OFFSET
	SETOM	NGFLG		;IF WE ARE HERE, OFFSETS WILL SUBTRACT, NOT ADD.
	AOS	T6		;ALSO INC SYM POINTER
NTNEG:	SKIPE	T2		;IF A SPACE.  WE SKIP THE PARSER 
	GOTO	NTSP
	SKIPN	SYMPOS(T6)	;IF A SPACE, RATHER THAN END OF LINE
	GOTO	RTN		;IS OK, ELSE RETURN
	AOS	T6		;INC SYMBOL POINTER
	GOTO	EXPLP		;GET RID OF ALL PADDING SPACES,TABS
NTSP:	CALL	DATTIM		;GO PARSE A DATE OR TIME EXPRESSION
	JFCL			;JUST IN CASE WE HAVE A WIERD RETURN
	SKIPE	ERRFLG##	;IF AN ERROR WAS FOUND ANYWHERE
	GOTO	RTN		;WE EXIT
NXSP:	AOS	T6		;OTHERWISE, SEE IF A COLON, ANOTHER EXPRESSION
	MOVE	T2,DATSYM(T6)	;GET SYMBOL
	CAMN	T2,COLN		;IS IT A COLON, OR SPACE??
	AOJA	T6,EXPLP	;WAS A COLON, INC PNTR, GET EXPRES
	SKIPN	SYMPOS(T6)	;IS IT THE END OF LINE??
	GOTO	RTN		;IF SO, RETURN..NO POS FOR NUL SYMBOL
	SKIPN	T2		;IF NOT A SPACE, ERROR, ELSE TRY AGAIN
	GOTO	NXSP		;GET RID OF ALL SPACES
	SETOM	ERRFLG##	;TELL EM THEY WERE VERY BAD KIDDIES.
RTN:	MOVE	T2,DATWRD	;GET THE DATE WE'VE GOTTEN
	SKIPE	ERRFLG##	;CHECK.  IF WE'VE GOTTEN AN ERROR
	SETZ	T2,		;WE ERASE THE GARBAGE FOR GOOD LUCK
	RESTORE	ARG		;AND POP THE ORIGINAL ARG POINTER BACK
	MOVEM	T2,@2(ARG)	;AND PASS IT BACK TO MAIN ROUTINE
	RETURN			;AND RETURN TO MAIN ROUTINE

PARS:	SETZ	T5,		;SYMBOL POINTER
	MOVEI	T6,@0(ARG)	;GET LOC OF STRING
	MOVE	TEMP,T6		;GONNA MAKE TEMP END OF STRING MARKER
	ADD	TEMP,@1(ARG)	;ADD LENG
	SOS	TEMP		;DECREMENT, CUZ LENG WAS NOT OFFSET
	MOVE	T1,(T6)		;GET FIRST CHAR
	LSH	T1,-^D29	;CONVERT FROM A1 TO ASCII
MNLP:	SETZB	T2,T3		;INIT SYMBOL ACCUMULATOR, AND CHARTYPE FLAG.
	CALL	INCRI		;INCREMENT CHAR POINTER
	GOTO	PRSRTN		;WE GET HERE IF END OF STRING
	MOVE	T4,T6		;OTHERWISE, HERE.  SAVE POSITION OF CHAR
	SUBI	T4,@0(ARG)	;AND MAKE IT A REAL POSITION
	CAILE	T1,137		;IF NOT LOWER CASE, FORGET IT...ELSE
	SUBI	T1,40		;MAKE IT UPPER CASE
	CAIL	T1,"A"		;IF ALPHA, THEN T3=-1, IF # THEN T3=1.  ELSE 0
	CAILE	T1,"Z"
	SKIPA
	SETO	T3,
	CAIL	T1,"0"
	CAILE	T1,"9"
	SKIPA
	MOVEI	T3,1
LPTWO:	TLNE	T2,770000	;CHECK TO SEE IF WE GOTTA DUMP FULL SYMBOL
	GOTO	SYMFUL		;IF SO.  DUMP IT.
	SUBI	T1," "		;GUESS WE CAN CRAM ANOTHER IN THERE
	JUMPL	T1,SYMFUL	;MAKE IT SIXBIT, AND IF - THEN A CONTROL CHAR
	LSH	T2,6		;MOVE WHAT WE GOT OVER 6 BITS
	ADD	T2,T1		;AND ADD ON THE CHAR WE GOT NOW
SYMFUL:	MOVE	T1,(T6)		;GET NEXT CHAR
	LSH	T1,-^D29	;MAKE IT ASCII.
	CAILE	T1,137		;IF LOWER CASE
	SUBI	T1,40		;MAKE IT UPPER
	CAIL	T1,"A"		;IF ALPHA
	CAILE	T1,"Z"
	JUMPLE	T3,DMPSYM	;BUT T3=-1 IF SYMBOL IS A #.  TIME TO DUMP.
	CAIL	T1,"0"		;IF A NUMBER
	CAILE	T1,"9"
	JUMPGE	T3,DMPSYM	;BUT T3=1 IF ALPHA.  TIME TO DUMP 
	CALL	INCRI		;CHAR IS SAME AS OTHERS ON SYMBOL.  GO ON.
	SKIPA			;IF END OF LINE.  SKIP AND DUMP LAST SYMBOL.
	GOTO	LPTWO		;ELSE GO BACK AND PUT CHAR ON SYMBOL
DMPSYM:	SKIPE	T3		;IF T3=0 THEN NOT ALPHANUMERIC. DELIMITER.
	GOTO	NOTDLM		;NOT DELIMITER, OTHERWISE, FORGET REPLICAS
	CAMN	T2,LSTSYM	;IF THIS DELIMITER IS SAME AS LAST DELIMITER
	GOTO	MNLP		;THEN FORGET IT. NO DUPLICATE DELIMITERS.
NOTDLM:	MOVEM	T4,SYMPOS(T5)	;DUMP THE FIRST CHAR OF THE SYMBOL AS POSITION
	JUMPE	T2,NOSHF	;IF A ZERO, NO LEFT JUSTIFICATION.
	SAVE	T1		;SAVE T1
	SETZ	T1,		;ZERO IT
	LSHC	T1,6		;SHIFT SYMBOL IN T2 OVER TO T1
	JUMPE	T1,.-1		;KEEP SHIFTING UNTIL WE HAVE CHAR
	LSHC	T1,-6		;THEN MOVE IT BACK.  LEFT JUSTIFIED.
	RESTORE	T1		;RESTORE T1.
NOSHF:	MOVEM	T2,DATSYM(T5)	;DUMP SYMBOL IN SYMBOL TABLE
	MOVEM	T2,LSTSYM	;SAVE SYMBOL FOR NEXT CHECK
	AOS	T5		;INCREMENT SYMTABLE POINTER
	CAIGE	T5,SYMMAX	;IF PAST END OF TABLE.  EXIT.
	GOTO	MNLP		;OTHERWISE, GO GET ANOTHER SYMBOL
PRSRTN:	RETURN			;RETURN TO INDAT


INCRI:	CAMGE	TEMP,T6		;IS STRING POINTER PAST END OF STRING?
	RETURN			;IF SO, THEN TAKE EXIT RETURN
	AOS	T6		;OTHERWISE, INCREMENT POINTER
	AOS	(STACK)		;INCREMENT RETURN ADDRESS
	RETURN			;AND RETURN TO THAT ADDR


DATTIM:	SKIPE	ERRFLG##	;IF AN ERROR HAS ALREADY BEEN SEEN, RETURN.
	RETURN	
	MOVE	T2,DATSYM(T6)	;GET SYMBOL
	MOVEM	T2,SYMBL	;SAVE IT
	SKIPN	.UHOFL		;DO WE HAVE EXTRA SYMBOL TABLE??
	GOTO	NOEXTR		;NOPE.  FLAG IS UNSET
	MOVEI	ARG,.UHOLI	;FLAG *WAS* SET
	CALL	ISRSIX##	;SEE IF SPECIAL USER DEFINED SYMBOL.
	MOVE	T2,TEMP		;INDEX RETURNED IN TEMP.  PUT IN T2
	JUMPL	T2,DATERR	;IF -1, THEN CONFLICT, ILL SYM 
	JUMPE	T2,NOEXTR	;IF 0, THEN NOT THERE AT ALL
	SOS	T2		;ELSE DECREMENT, MAKE 0 OFFSET 0, NOT 1
	GOTO	USRHOL		;AND GO USE IT.  SAME AS HOLIDA..SORTA.
NOEXTR:	MOVEI	ARG,SRCBLK	;GET ARGBLK FOR STANDARD SYMS
	CALL	ISRSIX##	;TUESDAY, ETC
	MOVE	T2,TEMP		;IND IN TEMP
	JUMPL	T2,DATERR	;IF <0, THEN ERROR, ALSO IF
	JUMPE	T2,GRGHOL	;ZERO, THEN TRY HOLIDAY SYMBOLS
	SOS	T2		;ELSE MAKE 0 OFFSET 0
	GOTO	@SYMLST(T2)	;AND USE INDEX TO GO TO CODE SEGMENT
GRGHOL:	MOVEI	ARG,GREGBL	;TRY OUT GREGORIAN HOLIDAYS
	CALL	ISRSIX##	;SEARCH IN SYMBOL TABLE
	MOVE	T2,TEMP		;GET INTO T2
	JUMPL	T2,DATERR	;IF NEG, THEN CONFLICT
	JUMPE	T2,NOTSYM	;IF 0, JUST PLAIN NOT THERE
	SOS	T2		;ELSE MAKE 0 INDEX 0
	GOTO	HOLIDA		;AND FIGGER IT(SAME AS USRHOL:, SORTA)
NOTSYM:	MOVE	T2,DATSYM+1(T6)	;NOT A SYMBOL.  TRY NEXT ONE
	JUMPN	T2,TRYOTH	;IF SOMETHING THERE.  USE IT
	SKIPE	DATSYM+2(T6)	;IF THIS ZERO
	GOTO	GDAT		;ELSE GET DATE(6 6 1982)
TRYOTH:	CAME	T2,SLSH		;IS IT A "/"
	CAMN	T2,DSH		;OF "-"???
	GOTO	GDAT		;IF SO, ITS A DATE
	CAMN	T2,CHRD		;IF NNND, ITS A DAY OFFSET
	GOTO	DATOFF		;FIGGER IT
	CAMN	T2,CHRH		;IF NNNH, ITS A HOUR OFFSET
	GOTO	TIMOFF
	GOTO	GTIM		;ELSE TRY CATCH ALL, TIME PARSER
DATERR:	SETOM	ERRFLG##	;SOME ROUTINES RETURN HERE ON ERROR
	RETURN			;RETURN TO INDAT



GDAT:				;GET DATE
	CALL	GNUM		;ASSUME 6-6-19?? FORMAT
	MOVE	T2,NUMBR	;GET NUMBER INTO T2 FROM STORAGE AREA.
GETDAY:	MOVE	TEMP,DATSYM(T6)	;GET NEXT SYMBOL
	CAME	TEMP,SLSH	;IF "/" OR "-"
	CAMN	TEMP,DSH
	GOTO	DELOK		;THEN WE KNOW ITS THE RIGHT FORMAT
	SKIPN	TEMP		;AND IF 0, WE WAIT AND SEE IF 6 6 19??.
	SKIPN	DATSYM+1(T6)	;IF NOT RIGHT
	GOTO	DATERR		;THEN BARF
DELOK:				;ELSE WE HAVE "6 6 19??" FORMAT
	AOS	T6		;INCREMENT SYM INDEX.
	CALL	GNUM		;GET NEXT NUMBER
	MOVE	T3,NUMBR	;PUT IT IN T3
	SKIPN	ERRFL		;IF ERROR
	GOTO	NOTMON		;THEN MAYBE "6 JUN 19??", ELSE.  USE IT.
	SOS	T6		;DECREMENT FOR NOW
	MOVE	T1,DATSYM(T6)	;GET THE SYMBOL AGAIN
	AOS	T6		;INCREMENT AGAIN
	MOVEM	T1,SYMBL	;SAVE IN WORKSPACE
	MOVEI	ARG,SRCBLK	;ET ARG BLOCK
	CALL	ISRSIX##	;AND SEE IF A MONTH NAME
	JUMPLE	TEMP,DATERR	;IF <=0, THEN A REAL ERROR
	SUBI	TEMP,^D14	;ELSE *WAS* A MONTH NAME
	MOVE	T3,T2		;FIRST NUM WAS DAY, NOT MONTH
	MOVE	T2,TEMP		;PUT MONTH IN T2
NOTMON:	SKIPE	T2		;DO WE HAVE AN ILLEGAL MONTH #
	CAILE	T2,^D12
	GOTO	DATERR		;IF SO, BARF.
	SKIPE	T3		;ILLEGAL DAY NUMBER??
	CAILE	T3,^D31
	GOTO	DATERR		;BARF ON THAT TOO
	SOS	T2		;DECREMENT MONTH NUMBER
	SOS	T3		;DECREMENT DAY NUMBER
	IMULI	T2,^D31		;MULT MONTH
	ADD	T2,T3		;ADD DAY.  DATE IS IN SYSTEM FORMAT
	DATE	TEMP,		;NOW GET DEFAULT YEAR
	IDIVI	TEMP,^D12*^D31	;WE ALREADY HAVE DAY AND MONTH
	MOVE	T3,DATSYM(T6)	;GET NEXT SPACING SYMBOL
	CAME	T3,DSH		;IF "/", OR "-"
	CAMN	T3,SLSH
	GOTO	YRTOO		;THEN WE HAVE TO GET A YEAR #
	JUMPN	T3,GOTYR	;ELSE WE USE THE DEFAULT YEAR
	SKIPN	DATSYM+1(T6)	;IF SPACE, MAYBE"6 6 19??" FORMAT
	GOTO	GOTYR		;IF NOT, WE STILL USE DEFAULT YEAR
YRTOO:	AOS	T6		;INCREMENT SYM INDEX
	MOVE	T3,DATSYM(T6)	;GET THIS SYMBOL
	CAMN	T3,COLN		;IF A COLON, NO YEAR
	JRST	GOTYR		;IN WHICH CASE, USE THE DEFAULT
	CALL	GYR		;GET THE YEAR
	MOVE	TEMP,NUMBR	;REPLACE DEFAULT YEAR IN TEMP.
	SKIPA			;SKIP
GOTYR:	SOS	T6		;INCREMENT INDEX
	IMULI	TEMP,^D12*^D31	;MULT YEAR SO WE CAN FIT MON-DAY IN
ADDYR:	ADD	TEMP,T2		;AND AD MON-DAY TO YEAR WE'VE GOTTEN.
	CAILE	TEMP,777777	;IS IT TOO BIG.  IF SO
	GOTO	DATERR		;WE BARF.
	HRLM	TEMP,DATWRD	;ELSE SAVE IT IN WORKSPACE DATIME WORD.
	RETURN			;AND RETURN TO INDAT.


DATOFF:	CALL	GNUM		;WE ARE GETTING A DAY OFFSET
ADDDAY:	HLLZ	TEMP,DATWRD	;GET DATE WE ALREADY HAVE
	MOVEM	TEMP,WRKDAT	;PUT IT IN WORKSPACE
	MOVEI	ARG,CNVBLK	;GET ARG BLOCK
	CALL	SYSUNV		;AND CONVERT TO UNIVERSAL FORMAT
	HLRZS	TEMP		;DATE IS NOW IN DAY OFFSET FORMAT
	MOVE	T1,NUMBR	;GET NUMBER FROM OTHER SEGS, OR FROM DATOFF
	SKIPE	NGFLG		;IF NEG FLAG IS SET
	MOVNS	T1		;WE MAKE OFFSET NEGATIVE
	ADD	TEMP,T1		;ADD TO THE DATE OFFSET WE NOW HAVE
	CAILE	TEMP,777777	;IF ILLEGAL, 
	GOTO	DATERR		;WE BARF
	HRLZM	TEMP,WRKDAT	;ELSE PUT BACK IN ARG WORD
	CALL	UNVSYS		;AND CONVERT BACK TO SYSTEM FORMAT
	HLLM	TEMP,DATWRD	;AND SAVE IT!!
	RETURN			;RE-TURN!



TIMOFF:	CALL	GNUM		;GET NUM OF TIME-TYPE OFFSET
	HRRZ	T1,DATWRD	;GET WHAT WE ALREADY HAVE
	MOVE	T2,NUMBR	;GET NUMBER WE GOT FROM GNUM.
	IMULI	T2,^D3600	;NUMBER IS IN HOURS
	GOTO	DMPTIM+1	;DMP TIME.  USES DATOFF TOO, IF OVER 24H

GTIM:	MOVE	T3,DATSYM(T6)	;GET SYMBOL
	CALL	GNUM		;GET NUMBER
	MOVE	T2,NUMBR
	JUMPN	T2,HOUROK	;IF NOT ZERO, MAYBE MINUTES, TOO
	IOR	T3,HRMSK	;BITMASK SYMBOL
	CAME	T3,HRMSK	;IF NOT EQUAL TO 0000
	GOTO	DATERR		;THEN ERROR
HOUROK:	IMULI	T2,^D3600	;MAKE NUMBER WE HAVE INTO HOURS
	MOVE	T1,DATSYM(T6)	;GET NEXT SYMBOL...AND REPEAT FOR MINS.
	CAME	T1,COLN		;IF ":"
	GOTO	DMPTIM		;SKIP THIS, ELSE DUMP THE HOURS
	AOS	T6		;INC SYMBOL TO MINUTES POSITION
	CALL	GNUM		;GET MINUTES
	MOVE	T3,NUMBR
	SKIPL	T3		;IF <0
	CAILE	T3,^D59		;OR >59.  ERROR
	GOTO	DATERR		;BARFIT
	IMULI	T3,^D60		;MULT BY 60 TO MAKE NUMBER INTO MINUTES.
	ADD	T2,T3		;AND ADD TO HOURS WE HAVE
	MOVE	T1,DATSYM(T6)	;GET NEXT SYMBOL
	CAME	T1,COLN		;IF EQUAL TO ":"
	GOTO	DMPTIM		;SKIP THIS, ELSE DUMP HOURS:MINS
	AOS	T6		;INC SYMBOL, THE GUYS EVEN GAVE SECONDS.
	CALL	GNUM		;GET SECONDS
	MOVE	T3,NUMBR
	SKIPL	T3		;IF 0<=NUM<=59, THEN OK
	CAILE	T3,^D59
	GOTO	DATERR		;ELSE WE BARF
	ADD	T2,T3		;ADD SECONDS TO HOUR:MINS
DMPTIM:	SETZ	T1,		;INIT
	SKIPE	NGFLG		;IF NEGATIVE
	MOVNS	T2		;IF NEGATIVE, INVERT TIME INTEGER.
	ADD	T2,T1		;IF FROM OTHER SEGS, T1 WILL BE <> 0.
	IDIVI	T2,^D86400	;DIVIDE..MAKE INTO UNIVERSAL FORMAT
	SKIPL	T3
	GOTO	POSOFF		
	AOS	T2		;IF NEG.  INCREMENT
	ADDI	T3,^D24*^D3600	;ALSO MAKE INTO 24H, NOT -24H!!
POSOFF:	HRRM	T3,DATWRD	;SAVE IT
	MOVEM	T2,NUMBR	;WE DIVIDED BY 24 HOURS, EXTRA DAYS IN
	GOTO	ADDDAY		;NUMBR NOW.  NOW WE USE ADDDAY TO
				;CREATE A DAYS OFFSET AS WELL


WKD:	DATE	T3,		;DAYE OF THE WEEK
	IDIVI	T3,7		;DIVIDE BY 7, DAY 0 IS WEDNESDAY
	AOS	T2		;INC
	SUB	T2,T4		;SUBTRACT FROM INDEX FROM DATTIM
	SKIPGE	T2		;IF >=0
	ADDI	T2,7		;THEN OK, ELSE ADD 7 TO MAKE NEXT WEEK.
	MOVEM	T2,NUMBR	;RETURN IT
	GOTO	ADDDAY		;AND ASSUME WE HAVE TO OFFSET BY DAYS

DAY:	SUBI	T2,^D8		;YESTERDAY,TOMORROW.  ETC.  CHANGE
	MOVEM	T2,NUMBR	;DATTIM INDEX TO OFFSET
	GOTO	ADDDAY		;YESTERDAY IS -1, TOMORROW IS 1.

NOW:	CALL	DATNOW		;GET DATE, TIME.
	MOVEM	TEMP,DATWRD	;SAVE IT
	RETURN			;RETURN

TIM:	SUBI	T2,^D10		;NOON,MIDNITE,MIDNIGHT, ETC
	IDIVI	T2,2		;WANT 0H, OR 24H
	IMULI	T3,^D12		;OR 12H
	IMULI	T3,^D3600	;MAKE INTO HOURS FROM OFFSET
	MOVE	T2,T3		;GET READY FOR
	GOTO	DMPTIM		;TIME OFFSET SEGMENT.



MON:	SUBI	T2,^D13		;MONTH NAME WAS FIRST SYMBOL
	AOS	T6		;INCREMENT SYMBOL POINTER, AND 
	GOTO	GETDAY		;GET THE REST OF DATE EXPRESSION.




LOGIN:	MOVE	T1,[-1,,.GTJLT]	;UNIVERSAL FORMAT.  LOGIN TIME.
	GETTAB	T1,
	SETOM	ERRFLG##	;IF ERR, BARF.
	HRRZS	T1		;GET RID OF DATE.  WANT ONLY TIME.
	RADIX	10		;CHANGE RADIX TO 10.
	MUL	T1,[24*60*60]	;CONVERT TIME TO SYSTEM FORMAT.
	ASHC	T1,17
	RADIX	8
	HRRM	T1,DATWRD	;AND SAVE IT
	RETURN			;RETURN.



USRHOL:	ADD	T2,.UHOLN	;USE OFFSET TO GET APPROPRIATE DATE
	SKIPA			;SORT OF LIKE BUILT IN HOLIDA SYMBOLS.
HOLIDA:	ADDI	T2,GREGNM	;SYM OFFSET IS POINTER TO GET DATE #'S.
	MOVE	T4,(T2)		;GET THE NUMBER, IN WHATEVER FORMAT
	AOS	T6		;INCREMENT POINTER

	DATE	TEMP,		;GET DEFAULT DATE
	IDIVI	TEMP,^D12*^D31	;GET DEFAULT YEAR
	MOVE	T3,DATSYM(T6)	;GET SYMBOL IN LIST
	CAME	T3,DSH		;IF "/" OR "-"
	CAMN	T3,SLSH
	GOTO	HOLYR		;THEN WE GOTTA GET YEAR FROM STRING.
	JUMPN	T3,GOTHYR	;AND IF NOT SPACE, WE USE DEFAULT YR.
	SKIPN	SYMPOS(T6)	;POSITION???
	GOTO	GOTHYR		;YUP.  ITS A SPACE. "LABORDAY 19??"
HOLYR:	AOS	T6		;INC SYMBOL INDEX
	MOVE	T3,DATSYM(T6)	;GET THIS SYMBOL
	CAMN	T3,COLN		;AND IF A COLON, FOR GET ABOUT THE YEAR.
	JRST	GOTHYR
	CALL	GYR		;GET YEAR
	SKIPE	ERRFL		;IF ERROR, BARF
	RETURN			;AND RETURN
	MOVE	TEMP,NUMBR	;REPLACE DEFAULT YEAR
	SKIPA			;SKIPIT.
GOTHYR:	SOS	T6		;INC SYM INDEX
	IMULI	TEMP,^D12*^D31	;MAKE YEAR INTO DATE WITHOUT MON-DAYS.
	HLRZ	T5,T4		;GET TYPE OF HOLIDA DATE
	HRRZS	T4		;WANT TYPE OF OFFSET, AND OFFSET
	MOVE	T2,T4		;MAKE COPY OF DATE OFFSET
	SKIPN	T5		;IF 0, THEN (MON-1)*31 + DAY-1
	GOTO	ADDYR		;MONTH, DAY OF MONTH..USE OFFSET SEGMNT.
	CAIE	T5,1		;IF 1, THEN WEEK OF YEAR, DAY OF WEEK
	GOTO	WEKMON		;1,,(WOY-1)*7 + DOW-1, ELSE

	HRLZM	TEMP,WRKDAT	;SET UP FOR CONVERSION
	MOVEI	ARG,CNVBLK	;WE'RE GONNA CONVERT TO UNIVERSAL
	CALL	SYSUNV
	HLRZS	TEMP		;JUST WANT DATE
	MOVE	T1,TEMP		;MAKE COPY
	IDIVI	T1,7		;FIND OUT WHAT DAY OF WEEK YEAR STARTS ON.
	MOVE	T1,T2		;USE T1 AGAIN
	ADDI	T1,3		;WEEK IN UNIVERSAL FORMAT STARTS ON WED.
	IDIVI	T1,7		;JUST WANT A WEEK OFFSET
	SUB	TEMP,T2		;SUBTRACT OFFSET
	ADD	TEMP,T4
RECON:	CAILE	TEMP,777777
	GOTO	DATERR
	HRLZM	TEMP,WRKDAT	;GET READY TO CONVERT TBACK TO SYS FORMAT
	CALL	UNVSYS
	HLLM	TEMP,DATWRD	;GET DATE OFFSET
	RETURN	

WEKMON:	CAIE	T5,2		;IF 2, THEN (MON-1)*6+WEK-1)*7+DAY-1
	CAIN	T5,3		;OR IF 3, THEN SAME, EXCEPT INC IF THE 1ST
	SKIPA			;OF THE MONTH..MAKE NEXT WEEK.
	GOTO	DATERR		;NOTHING <0 OR >2 YET. .  SOMEDAY.

	MOVE	T2,T4		;MAKE COPY OF OFFSET
	IDIVI	T2,^D6*^D7	;GET MON IN T2
	IDIVI	T3,^D7		;WEEK IN T3, DAY IN T4
	IMULI	T3,^D7		;PUT WEEK BACK
	ADD	T3,T4
				;WEK, DAY OF WEEK IN T3
	IMULI	T2,^D31		;GET READY TO ADD TO YEAR
	ADD	TEMP,T2		;WANT YEAR, MONTH.  OFFSET FROM THAT.

	HRLZM	TEMP,WRKDAT	;SET UP FOR CONVERSION
	MOVEI	ARG,CNVBLK
	CALL	SYSUNV		;CONVERT TO UNIVERSAL
	HLRZS	TEMP		;JUST WANT DATE
	MOVE	T1,TEMP		;MAKE COPY
	IDIVI	T1,7		;FIND OUT WHAT DAY OF WEEK MONTH STARTS ON.
	MOVE	T1,T2		;USE T1 AGAIN
	ADDI	T1,3		;WEEK IN UNIVERSAL FORMAT STARTS ON WED.
	IDIVI	T1,7		;JUST WANT A WEEK OFFSET
	SUB	TEMP,T2		;SUBTRACT OFFSET
	CAMGE	T4,T2		;IF LESS THAN OFFSET, THEN SHOULD BE ON NEXT W
	ADDI	T3,7
	ADD	TEMP,T3		;ADD WEEK OFFSET
	CAIE	T5,3		;IS IT ELECTION SPECIAL FORMAT??
	GOTO	RECON		;CONVERT BACK TO SYSTEM FORMAT

	CAMN	T3,T2		;IF THE 1ST, THEN WE WANT TO
	ADDI	TEMP,7		;ADD 7 DAYS TO MAKE IT NEXT WEEK
	GOTO	RECON		;AND CONVERT BACK TO SYSTEM FORMAT


GNUM:	SETZM	NUMBR		;INIT NUMBER ARG.
	SAVE	TEMP		;SAVE AC'S.
	SAVE	T1
	SAVE	T2
	SAVE	T3
	SAVE	T4
	SAVE	T5

	MOVE	T1,DATSYM(T6)	;GOTTA BE A DIGIT IN LEFTMOST CHAR OF SYMBOL
	SETZ	TEMP,		;GET READY FOR SHIFT.
	LSHC	TEMP,6		;GET LEFTMOST CHAR
	SETOM	ERRFL		;SET ERROR ON.
	CAIL	TEMP,'0'		;IF NOT A SIXBIT DIGIT
	CAILE	TEMP,'9'
	GOTO	NMRT		;RETURN WITH ERROR
	SETZM	ERRFL		;SET ERROR BACK TO NOERROR.

	MOVE	T1,LNG		;GET LENGTH TO STRING
	AOS	T1		;PLUS ONE
	SKIPE	SYMPOS+1(T6)	;IS THERE A NEXT SYMBOL??
	MOVE	T1,SYMPOS+1(T6)	;IF SO, END THE NUMBER AT THAT SYMBOL
	SUB	T1,SYMPOS(T6)	;MAKE STRING LENGTH INTO NUMBER LEN.
	MOVEM	T1,NLEN		;SAVE IT IN ARG LIST
	MOVE	T1,STRLC	;GET STRING LOCATION
	ADD	T1,SYMPOS(T6)	;ADD POSITION OF NUBER SYMBOL
	SOS	T1		;MINUES ONE, MAKES LOC OF # IN STRING.
	MOVEM	T1,NUMBLK	;SAVE IN ARG LIST
	MOVEI	T1,OVF		;SET OVERFLOW TRAPPING
	MOVEM	T1,.JBAPR
	MOVEI	T1,AP.FOV+AP.AOV
	APRENB	T1,
	MOVEI	ARG,NUMBLK	;GET ARG POINTER
	CALL	GETNUM##	;GET THE NUMBER FROM STRING, NOT SYM LST
NMRT:	AOS	T6		;INCREMENT SYMBOL INDEX
	RESTORE	T5		;RESTORE ALL THE AC'S.
	RESTORE	T4
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RESTORE	TEMP
	RETURN			;AND RETURN



OVF:	SETOM	ERRFLG##	;HERE ON OVERFLOW.  SET ERROR
	SETZM	DATWRD		;SET DAT WRD TO ZERO
	JRSTF	@.JBTPC		;AND RETURN



GYR:	SAVE	T1		;SAVE AC'S
	SAVE	T2
	CALL	GNUM		;GET THE YEAR NUMBER IN STRING
	DATE	T1,		;GET DEFAULT YEAR NUMBER
	IDIVI	T1,^D12*^D31	;ONLY WANT YEAR, NOT MON-DAY
	ADDI	T1,^D64		;SYS DATE STARTS AT JAN 1, 1964
	IDIVI	T1,^D10		;WANT DECADE IN T1, SUB DEC IN T2.
	IMULI	T1,^D10
	MOVE	T2,NUMBR	;GET NUMBER WE INPUTTED
	SKIPN	ERRFL		;IF ERROR.  BARF
	SKIPGE	T2		;OR IF NUMBER IS <0
	SETOM	ERRFLG##	;SET ERROR
	CAIGE	T2,^D10		;IF NUMBER IS <=9, THEN JUST WITHIN DEC.
	ADD	T2,T1		;JUST DECADE YEAR.  ADD IT
	SUBI	T2,^D64		;SUBTRACT 1964
	CAIL	T2,^D1900	;IF LESS THAN 1900
	SUBI	T2,^D1900	;SKIP THIS, ELSE MAKE "??",NOT "19??"
	MOVEM	T2,NUMBR	;SAVE IT FOR CALLING ROUTINE
	SOS	T6		;DECREMENT SYMBOL INDEX
	RESTORE	T2		;RESTORE AC'S
	RESTORE	T1
	RETURN			;AND RETURN





IFE %HISEG,	<RELOC>		;LOW

CNVBLK:	WRKDAT			;BLOCK FOR CONVERSIONS




WRKDAT:	Z			;DATE WORKSPACE.
DATWRD:	Z
ERRFL:	Z
LNG:	Z
DATSYM:	BLOCK	SYMMAX+1	;LIST OF SYMBOLS
SYMPOS:	BLOCK	SYMMAX+1	;LIST OF SYMBOL POSITIONS.
NUMSYM:	Z			;NUMBER OF SYMBOLS
MAXSYM:	SYMMAX			;MAX NUMBER OF SYMBOLS
LSTSYM:	Z
NGFLG:	Z			;NEGATION FLAG.  IF SET, NEGATE.
.UHOFL:	Z			;IF SET, USER HAS SUPPLIED USER SYMS.

.UHOLI:	Z			;POINTER TO USER SYMBOL LIST.
	SYMBL			;WORD BEING SEARCHED FOR.
	.UHOLL			;LENGTH OF LIST

.UHOLN:	Z			;POINTER TO LIST OF DATE OFFSETS.
.UHOLL:	Z			;LENGTH OF BOTH.

SRCBLK:	SYMTAB			;SEARCH ARG FOR WEEKDAY SYMS, ETC.
	SYMBL			;SYM BEING SEARCHED FOR
	[MXSYM]			;MAXIMUM SYMBOL POSITION.


GREGBL:	GREGSM			;SEARCH ARG FOR HOLIDAY SYMBOLS.
	SYMBL			;SYM SEARCHED FOR
	[MXGREG]		;MAX GREGORIAN SYMBOL


SYMBL:	Z			;SYMBOL BEING SEARCHED FOR.
HOLLOC:	Z			;LOCATION OF?????????




	-4,,0
NUMBLK:	Z			;BLOCK FOR GETTING NUMBER FROM STRING.
	NLEN			;NUMBER LENGTH
	NUMBR			;NUMBER TO BE RETURNED.
	BASE			;BASE (10)

STRLC:	Z			;STRING LOCATION.
NLEN:	Z			;LENGTH OF NUMBER.
NUMBR:	Z			;NUMBER RETURNED.
BASE:	^D10

IFE %HISEG,	<RELOC>		;HIGH



DSH:	SIXBIT/-     /		;SYMBOLS SEARCHED FOR
SLSH:	SIXBIT!/     !
COLN:	SIXBIT/:     /
CHRD:	SIXBIT/D     /
CHRH:	SIXBIT/H     /
HRMSK:	SIXBIT/000000/



SYMTAB:	SIXBIT/WEDNESTHURSDFRIDAYSATURDSUNDAYMONDAYTUESDA/
	SIXBIT/YESTERTODAY TOMORR/
	SIXBIT/MIDNIGNOON  MIDNITMIDDAY/

	SIXBIT/JANUARFEBRUAMARCH APRIL MAY   JUNE  /
	SIXBIT/JULY  AUGUSTSEPTEMOCTOBENOVEMBDECEMB/

	SIXBIT/LOGIN /
	SIXBIT/NOW   /
	MXSYM=.-SYMTAB

GREGSM:	SIXBIT/NEWYEAKINGS LINCOLVALENTWASHINSTPATRMEMORIFLAG  INDEPE/
	SIXBIT/COLUMBUN    HALLOWVETERACHRIST/

	SIXBIT/MOTHERARMEDFFATHERLABOR THANKS/

	SIXBIT/ELECTI/
	MXGREG=.-GREGSM


	RADIX	10
;			MONTH-1....DAY-1...MAKE INTO DATE, WITHOUT YEAR

GREGNM:	0		;NEWYEARS DAY..THIS METHOD ONLY GOOD FOR GREGORIAN CAL
	14		;MARTIN LUTHER KING, JR.  ...BIRTHDAY
	<1*31>+11	;LINCOLNS
	<1*31>+14	;VALENTINES DAY
	<1*31>+21	;WASHINGTONS BIRTHDAY
	<2*31>+16	;ST. PATRICKS DAY
	<4*31>+29	;MEMORIAL DAY
	<5*31>+13	;FLAG DAY
	<6*31>+3	;INDEPENDENCE DAY(4TH OF JULY)
	<9*31>+11	;COLUMBUS DAY
	<9*31>+23	;UNITED NATIONS DAY
	<9*31>+30	;HALLOWEEN
	<10*31>+10	;VETERANS DAY
	<11*31>+24	;CHRISTMAS


	2,,<4*6+1>*7+0	;MOTHER'S DAY( MAY, 2ND SUNDAY)
	2,,<4*6+2>*7+6	;ARMED FORCES DAY
	2,,<5*6+2>*7+0	;FATHERS DAY
	2,,<8*6+0>*7+1	;LABOR DAY
	2,,<10*6+3>*7+4	;THANKSGIVING


	3,,<10*6+0>*7+2	;ELECTION DAY(1ST TUESDAY, UNLESS ITS THE 1ST)

	RADIX	8



SYMLST:	WKD
	WKD
	WKD
	WKD
	WKD
	WKD
	WKD

	DAY
	DAY
	DAY

	TIM
	TIM
	TIM
	TIM

	MON
	MON
	MON
	MON
	MON
	MON
	MON
	MON
	MON
	MON
	MON
	MON

	LOGIN
	NOW

	ENTRY	SETHOL

;	CALL	SETHOL( HOLARR[, HOLNUM, ARRLEN] )
;	WHERE:	
;		HOLARR	IS AN ARRAY OF SIXBIT SYMBOLS REPRESENTING HOLIDAY NAMES.
;
;	      HOLNUM  IS AN ARRAY OF NUMBERS REPRESENTING EITHER:
;			1.  THE WEEK NUMBER, AND DAY OF WEEK THAT THE HOLIDAY
;			    FALLS ON, OR
;			2.  THE MONTH, AND DAY OF MONTH
;
;			WHERE WEEK-DAY OF WEEK IS REPRESENTED BY:
;				WEEK IN LH, WEEKDAY IN RH
;			     AND MONTH-DAY OF MONTH IS:
;			        (MONTH-1)*31+DAY-1


SETHOL:	SETZM	.UHOFL		;SET FLAG TO DEFAULT NOSPECIAL SYMS.
	SKIPN	@0(ARG)		;AND IF FIRST ARG IS 0, LEAVE IT THAT WAY
	RETURN			;AND RETURN.
	MOVEI	TEMP,@0(ARG)	;GET LOC OF SYMBOL ARRAY.
	MOVEM	TEMP,.UHOLI	;SAVE IT
	MOVEI	TEMP,@1(ARG)	;GET LOC OF VALUE ARRAY.
	MOVEM	TEMP,.UHOLN	;SAVE IT
	MOVE	TEMP,@3(ARG)	;GET LENGTH OF BOTH
	MOVEM	TEMP,.UHOLL	;SAVE IT
	SETOM	.UHOFL		;AND SET FLAG TO SPECIAL SYMS AVA
	RETURN			;RETURN.



;	IDATE = DATNOW(0)
;	WHERE:	IDATE WILL BE RETURNED WITH DATE-TIME IN SYSTEM FORMAT.


	ENTRY	DATNOW


DATNOW:	SAVE	T1		;SAVE AC'S
	SAVE	T2
	DATE	T1,		;GET DATE
	HRL	TEMP,T1		;SAVE IN FUNCTION RETURN AC
	MSTIME	T1,		;GET TIME IN MILLISECONDS.
	IDIVI	T1,^D1000	;MAKE INTO SECONDS.
	HRR	TEMP,T1		;SAVE IT
	RESTORE	T2		;RESTORE AC'S
	RESTORE	T1
	RETURN			;AND RETURN.


;	FIXES DATE IF ONLY A TIME, PUTS TODAYS DATE IN LH UNLESS TIME
;	IS PREVIOUS TO NOW, IN WHICH CASE IT USES TOMORROWS DATE.


	ENTRY	FIXDAT

FIXDAT:	SAVE	T2		;SAVE AC'S.
	SAVE	T3
	SAVE	T4
	CALL	DATNOW		;GET TODAYS DATE INTO TEMP
	HRRZ	T2,TEMP		;GET TIME
	HLRZS	TEMP		;AND TODAYS DATE INTO TEMP
	HLRZ	T3,@0(ARG)	;GET ARG
	HRRZ	T4,@0(ARG)
	SKIPN	T3		;IF NO DATE
	MOVE	T3,TEMP		;RETURN ONE
	CAMGE	T4,T2		;IF TIME IS LESS THAN NOW
	CAME	T3,TEMP		;AND IF DATE IS TODAY
	SKIPA
	AOS	T3		;THEN MAKE DATE TOMORROW
	HRRM	T4,@0(ARG)	;RETURN TIME
	HRLM	T3,@0(ARG)	;RETURN DATE
	RESTORE	T4		;RESTORE AC'S
	RESTORE	T3
	RESTORE	T2
	RETURN			;AND RETURN.

;	ISYSTM = UNVSYS( IUNIV )
;	IUNIVS = SYSUNV( ISYSTM )
;
;	WHERE:
;		UNVSYS CHANGES UNIVERSAL FORMAT INTO DATE, SECONDS
;		SYSUNV CHANGES DATE, SECONDS INTO UNIVERSAL FORMAT
;




	RADIX	10


	ENTRY	UNVSYS
UNVSYS:	SAVE	T1		;SAVE AC'S
	SAVE	T2
	SAVE	T3
	SAVE	T4
	MOVE	T1,@0(ARG)	;GET DATE/TIME
	JUMPL	T1,CNTDT6	;GET RID OF JUNK.
	HLRZS	T1		;GET DATE PART
	ADDI	T1,<1857-1500>*365+<1857-1500>/4-<1857-1500>/100+<1857-1500>/400+31+28+31+30+31+30+31+31+30+31+17
				;DAYS SINCE JAN 1, 1501
	IDIVI	T1,400*365+400/4-400/100+400/400
				;SPLIT INTO QUAD CENTURY.
	LSH	T2,2		;CONVERT TO QUARTER DAYS
	IDIVI	T2,<100*365+100/4-100/100>*4+400/400
				;SPLIT INTO CENTURY.
	IORI	T3,3		;DUMP DAY FRACTIONS
	IDIVI	T3,4*365+1	;SEPARATE INTO YEARS.
	LSH	T4,-2		;NO DAYS THIS YEAR.
	LSH	T1,2		;T1 IS 4*NO QUADCENTURIES
	ADD	T1,T2		;T1 IS NO CENTURIES
	IMULI	T1,100		;T1 IS 100*NO CENTURIES
	ADDI	T1,1501(T3)	;T1 HAS YEAR, T3 HAS DAY IN YEAR.
	MOVE	T2,T1		;SEE IF LEAP YEAR.
	TRNE	T2,3		;IS THE YEAR A MULTIPLE OF 4?
	GOTO	CNTDT0		;NOPE.  INDICATE NOT LEAP YEAR.
	IDIVI	T2,100		;SEE IF MULTIPLE OF 100
	SKIPN	T3		;IF NOT, THEN LEAP YEAR.
	TRNN	T2,3		;MULTIPLE OF 400?
	TDZA	T3,T3		;YES...ITS A LEAP YEAR, FER SURE.
CNTDT0:	MOVEI	T3,1		;SET LEAP FLAG.
CNTDT1:	SUBI	T1,1964		;SET TO SYSTEM FORMAT ORIGIN.
	IMULI	T1,31*12	;CHANGE TO SYSTEM PSEUDO-DAYS.
	JUMPN	T3,CNTDT2	;IF NOT LEAP YEAR
	CAIGE	T4,31+29	;LEAP YEAR. SEE IF PAST FEB 29.
	GOTO	CNTDT5		;NOPE
	SOS	T4		;YUP.  DECREMENT ONE DAY.
CNTDT2:	MOVSI	T2,-11		;LOOK THROUGH MONTH TABLE

CNTDT3:	CAMGE	T4,MONTAB+1(T2)	;BEYOND THIS MONTH?
	GOTO	CNTDT4		;YUP, FINISH
	ADDI	T1,31		;NOPE.  ADD TO SYSTEM MONTH COUNT
	AOBJN	T2,CNTDT3	;KEEP ON THROUGH MONTH COUNT.

CNTDT4:	SUB	T4,MONTAB(T2)	;GET DAYS IN MONTH.
CNTDT5:	ADD	T1,T4		;INCLUDE.
CNTDT6:	HRL	TEMP,T1		;SAVE ANSWER IN TEMP.
	HRRZ	T1,@0(ARG)	;GET TIME.
	MUL	T1,[24*60*60]	;CONVERT TO MILLISECONDS.
	ASHC	T1,17		;POSITION SHIFT.
	HRR	TEMP,T1		;PUT IN RH OF FUNCTION RETURN WORD.
	GOTO	NRMRTN		;AND RETURN


	ENTRY	SYSUNV
SYSUNV:	SAVE	T1		;SAVE AC'S
	SAVE	T2
	SAVE	T3
	SAVE	T4
	SAVE	T5
	HLRZ	T2,@0(ARG)	;GET DATE
	IDIVI	T2,12*31	;BEYOND 2217 AD?
	CAILE	T2,2217-1964
	GOTO	GETNW2		;YUP.  BARF IT.  ERRRROR.
	IDIVI	T3,31		;T3 IS MONTHS-JAN, T4 IS DAYS-1
	ADD	T4,MONTAB(T3)	;GET DAYS-JAN 1ST
	SETZ	T5,		;LEAP YEAR INCREMENT.  IF JAN, FEB.
	CAIL	T3,2		;CHECK MONTH.
	MOVEI	T5,1		;INCREMENT IF GREATER THAN FEB.
	MOVE	T1,T2		;SAVE YEARS FOR LATER.
	ADDI	T2,3		;OFFSET.  LEAP YEAR NOT COUNTED.
	IDIVI	T2,4		;HANDLE REG LEAP YEARS.
	CAIE	T3,3		;LEAP YEAR?
	SETZ	T5,		;NOPE, GET RID OF INCREMENT.
	ADDI	T4,<1964-1859>*365+<1964-1859>/4+<31-18>+31(T2)
				;DAYS BEFORE JAN 1, 1964 SINCE JAN 1.
	MOVE	T2,T1		;RESTORE YEARS
	IMULI	T2,365		;DAYS SINCE 1964
	ADD	T4,T2		;DAYS XCEPT FOR 100 YEARS
	HRREI	T2,64-100-1(T1)	;YEARS SINCE 2001
	JUMPLE	T2,GETNW1	;DONE IF < 2001 AD
	IDIVI	T2,100		;GET CENTURIES SINCE 2001.
	SUB	T4,T2		;ALLOW FOR LOST LEAP YEARS.
	CAIE	T3,99		;SEE IF LOST LEAP YEAR.
GETNW1:	ADD	T4,T5		;ALLOW FOR IT
	CAILE	T4,^O377777	;SEE IF OVERSIZED DATE RETURN.
GETNW2:	SETOM	ERRFLG##	;BARFIT IF SO.
	HRL	TEMP,T4		;SAVE IT IN LH OF FUNCTION RETURN.
	HRRZ	T1,@0(ARG)	;GET TIME
	SETZ	T2,		;GET READY FOR SHIFT
	ASHC	T1,-17		;FIX POSITION.
	DIV	T1,[24*60*60]	;AND CONVERT TO 1/(2**18) DAYS
	HRR	TEMP,T1		;INCLUDE TIME IN FUNCTION RETURN.
	RESTORE	T5		;RESTORE AC'S
NRMRTN:	RESTORE	T4		;RESTORE ALL OF EM
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RETURN			;RETURN WITH VALUE IN TEMP, FOR FUNCTION.

MONTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334,365
	RADIX	8
	PRGEND
	TITLE	USRSET				;PAGE 6
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

;	CALL USRSET( ISWTCH, IBIT )	GET OR SET TTY CHARACTERISTIC

	ENTRY	USRSET
USRSET:	SETZM	ERRFLG		;NO ERRORS YET
	MOVE	T1,@0(ARG)	;GET TERMINAL CHARACTERISTIC
	MOVEM	T1,ARGADR	;HE IS INTERESTED, STORE FOR TRMOP.
	MOVE	TEMP,@1(ARG)	;GET BIT HE WANT'S TO SET (IF SETTING)
	MOVEM	TEMP,ARGADR+2	;AND STORE FOR TRMOP.
	PJOB	TEMP,		;GET MY JOB NUMBER SO I CAN
	TRMNO.	TEMP,		;GET MY UDX
	SETOM	ERRFLG		;IF ERROR THEN DETACHED
	MOVEM	TEMP,ARGADR+1	;PUT UDX IN TRMOP BLOCK
	MOVE	TEMP,[XWD 3,ARGADR]	;SET UP FOR TRMOP.
	TRMOP.	TEMP,		;SET OR RETURN THAT TTY CHARACTERSTIC
	SETOM	ERRFLG		;OR SET ERROR
	CAIGE	T1,2000		;IF RETURNING THE VALUE
	MOVEM	TEMP,@1(ARG)	;HAND RETURNED VALUE BACK
	RETURN

IFE %HISEG,	<RELOC>		;HIGH
ARGADR:	BLOCK	3
IFE %HISEG,	<RELOC>		;LOW

	PRGEND
	TITLE	FILES				;PAGE 7

	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>

	EXTERN	ERRFLG,GETSTR,CONVRT
	EXTERN	SCAN,ORFILE,OWFILE,OFILE,RFILE,WFILE,RNFILE,AFILE


;	CALL RENAMF( ICHAN, 'FILESPEC' )	RENAME CHAN TO FILESPEC

	ENTRY	RENAMF
RENAMF:	SETZ	TEMP,		;SET OPERATION TO RENAME
	GOTO	SCANIT		;GO SCAN FILESPEC


;	CALL READF( ICHAN, 'FILESPEC' )		OPEN FILE FOR READING

	ENTRY	READF
READF:	MOVEI	TEMP,1		;SET OPERATION TO READ
	GOTO	SCANIT		;GO SCAN FILESPEC


;	CALL WRITEF( ICHAN, 'FILESPEC' )	OPEN FILE FOR WRITING

	ENTRY	WRITEF
WRITEF:	MOVEI	TEMP,2		;SET OPERATION TO WRITE
	GOTO	SCANIT		;GO SCAN FILESPEC


;	CALL APPENF( ICHAN, 'FILESPEC' )	APPEND TO FILESPEC

	ENTRY	APPENF
APPENF:	MOVEI	TEMP,3		;SET OPERATION TO APPEND


SCANIT:	SAVE	ARG		;SAVE ARG PTR
	SAVE	T2		;SAVE TEMPORARY
	SAVE	TEMP		;SAVE OPERATION
	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	MOVEM	TEMP,THECHN	;SET UP OPEN & FILE CHANNELS
	MOVN	T1,-1(ARG)	;GET LENGTH OF ARG BLOCK
	HLRZ	T1,T1		;PUT IT ON RIGHT SIZE
	SETZ	TEMP,		;SET DEFAULT MODE TO ZERO
	CAIN	T1,3		;IF THREE ARGUMENTS
	MOVE	TEMP,@2(ARG)	;GET THIRD ARGUMENT
	MOVEM	TEMP,MODE	;STORE MODE
	SKIPE	@1(ARG)		;CHECK TO SEE IF FILESPEC IS 0
	GOTO	NONZFL		;IF NOT, SKIP THIS
	MOVEI	ARG,GETBLK	;PREPARE TO READ A FILE SPEC
	CALL	GETSTR		;GET THE STRING
	GOTO	CALSCN		;AND GO SCAN IT

NONZFL:	MOVEI	TEMP,@1(ARG)	;GET ADDRESS OF FILESPEC
	MOVEM	TEMP,CONFRM	;SET UP ARG BLOCK TO CONVERT
	MOVEI	ARG,CONFRM	;GET ARG PTR TO CONVERT
	CALL	CONVRT		;CONVERT A5 TO A1 FORMAT
	SETZ	T1,		;SET INDEX TO ZERO

FINSPC:	SKIPN	T2,FILARA(T1)	;ARE WE ENDING WITH NULL BYTE?
	GOTO	EXFNSP		;IF SO, EXIT LOOP
	CAIE	T2," "		;ARE WE ENDING WITH A SPACE?
	AOJA	T1,FINSPC	;NO, INCREMENT AND LOOP

EXFNSP:	MOVEM	T1,LENFLA	;SETUP LENGTH FOR SCAN
CALSCN:	MOVEI	ARG,SCANRG	;GET ARG PTR TO SCAN BLOCK
	CALL	SCAN		;SCAN OUT A FILE SPEC
	MOVEI	ARG,OPENRG	;GET ARG PTR TO OPEN BLOCK
	RESTORE	T2		;GET CALL TYPE BACK
	SKIPE	ERRFLG		;CHECK IF WE FOUND AN ERROR
	GOTO	FAILED		;IF SO, EXIT ROUTINE
	CAIN	T2,1		;WAS IT A READ OPERATION?
	CALL	ORFILE		;IF SO, OPEN IT FOR READING
	CAIN	T2,2		;WAS IT A WRITE OPERATION?
	CALL	OWFILE		;IF SO, OPEN IT FOR WRITING
	CAIN	T2,3		;WAS IT A READ/WRITE OPERATION?
	CALL	OFILE		;IF SO, OPEN IT UP FOR BOTH
	SKIPE	ERRFLG		;CHECK IF WE FOUND AN ERROR
	GOTO	FAILED		;IF SO, EXIT ROUTINE

	MOVEI	ARG,FILERG	;GET BLOCK TO FILE OP
	CALL	@CALTBL(T2)	;CALL APPROPRIATE ROUTINE

FAILED:	RESTORE	T2
	RESTORE	ARG
	RETURN			;AND RETURN

	-4,,0			;FOUR ARGUMENTS
SCANRG:	[1]			;PLACE TO START SCANNING
	LENFLA			;PLACE TO STOP SCANNING
	FILARA			;ARRAY TO SCAN
	FILSPC			;PLACE TO PUT FILE SPEC

	-3,,0			;THREE ARGUMENTS
OPENRG:	THECHN			;CHANNEL TO OPEN
	FILSPC			;ARRAY OF FILE SPEC
	MODE			;MODE TO OPEN IT IN

	-2,,0			;TWO ARGUMENTS
FILERG:	THECHN			;CHANNEL TO READ/WRITE ETC
	FILSPC			;ARRAY OF FILE SPEC

CALTBL:	RNFILE			;CALL TABLE TO ROUTINES
	RFILE
	WFILE
	AFILE

IFE %HISEG,	<RELOC>		;LOW
CONFRM:	BLOCK	1		;PTR TO ORIGINAL ARRAY
	[%SCRWID]		;CONVERT EIGHTY CHARACTERS
	[5]			;STARTS IN A5 FORMAT
	FILARA			;PLACE TO PUT CONVERTED ARRAY
	[0]			;IN R1 FORMAT

	-3,,0			;LENGTH
GETBLK:	FILARA			;POINTER TO PLACE FOR INPUT
	[%SCRWID]		;MAXIMUM INDEX TO ARRAY
	LENFLA			;PLACE TO PUT LENGTH

THECHN:	BLOCK	1		;CONTAINS CHANNEL TO OPEN
MODE:	BLOCK	1		;CONTAINS MODE TO OPEN DEVICE
FILARA:	BLOCK	%SCRWID		;ARRAY TO HAND TO SCAN
LENFLA:	BLOCK	1		;NUMBER CHARS USED
FILSPC:	BLOCK	^D13		;ARRAY FOR FILE SPEC
IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	TITLE	OUTPUT				;PAGE 8
	SEARCH	PACK, UUOSYM

;THE BELOW IS SORT OF A PACKAGE OF ROUTINES TO TAKE THE PLACE OF
;FORTRAN I/O WHICH (IN MY OPINION) IS RATHER AWFUL.  I HAVE ROUTINES
;WHICH WILL OUTPUT A STRING, A NUMBER OR CURSOR CONTROL INFO IF
;APPROPRIATE.  ALSO, THERE IS A PACKAGE HERE WHICH ALLOWS AN ENTIRE
;SCREEN TO BE MANIPULATED AND ONLY UPDATED AS RARELY AS POSSIBLE.

IFE %HISEG,	<TWOSEG 400000>

	EXTERN	FILPUT,	OUTBUF,	ERRFLG


;	CALL TTYTYP( ITYPE )	SET TERMINAL TYPE
;				TYPES KNOWN ARE:
;				0 - ADDS580
;				1 - ADM3A
;				2 - VT52
;				3 - ISC
;				4 - ISC (A7 ON)
;				5 - PE550
;				6 - ADDS980
;				7 - ACT-V
;				8 - VT100
;				9 - ADVANTAGE
;				10 - ANSI

	ENTRY	TTYTYP
TTYTYP:	MOVE	TEMP,@0(ARG)	;GET TTY TYPE
	MOVEM	TEMP,TFLAG	;STUFF IT AWAY FOR LATER
	CAIN	TEMP,3		;IF ITS ISC
	GOTO	SMALL		;MAKE SURE A7 IS OFF
	CAIE	TEMP,4		;IF ITS NOT ISCBIG
	RETURN			;RETURN, ELSE

.BIG:	MOVEI	CHAR,16		;A7 ON CHARACTER
	SKIPA			;AND OUTPUT IT

SMALL:	MOVEI	CHAR,17		;A7 OFF CHARACTER
	CALL	DCRNOW		;OUTPUT CHAR
	RETURN			;AND RETURN


;	CALL SELECT( ICHAN )	IF ICHAN IS POSITIVE, OUTPUT
;				GOES TO FILPUT, 0 TO TTY VIA
;				TRMOP., NEGATIVE, TTY'S INPUT
;				BUFFER.

	ENTRY	SELECT
SELECT:	MOVE	TEMP,@0(ARG)	;GET DESTINATION
	MOVEM	TEMP,CHAN	;REMEMBER IT
	RETURN


;	CALL SELTTY( TTYNUM )	SELECT DESTINATION FOR TRMOPS.

	ENTRY	SELTTY
SELTTY:	MOVE	TEMP,@0(ARG)	;GET THE TERMINAL NUMBER
	MOVEM	TEMP,TTYNUM	;AND REMEMBER IT
	RETURN

IFE %HISEG,	<RELOC>		;LOW
TFLAG:	-1			;GETS TERMINAL TYPE FLAG
XCOOD:	0			;CURRENT X-COORDINATE
YCOOD:	0			;CURRENT Y-COORDINATE

CURDIS:	0			;CHOICE OF 20 DISPLAYS, WHICH ONE?
DISADR:	SIXBIT/DISADR/		;AND HERE THE 20 ARE:
	BLOCK	20
XPOS:	SIXBIT/XPOS/		;HERE ARE THE 20 CURRENT X'S
	BLOCK	20
YPOS:	SIXBIT/YPOS/		;AND Y'S
	BLOCK	20
DISFG:	SIXBIT/DISFG/
	BLOCK	20
DISBG:	SIXBIT/DISBG/
	BLOCK	20

LINFLG:	0
GRFMOD:	0

OLDISP:	BLOCK	%SCRWDS		;WHAT THE LAST SCREEN HAD ON IT

TRMCOD:	0			;6 FOR OUTCHR, 21 FOR INPUT BUFFER
TRMUDX:	0			;UDX FOR DESTINATION TERMINAL
TRMARG:	0			;WHAT TO PUT OUT

TTYNUM:	-1			;DESTINATION FOR TRMOP.

CHAN:	0			;CHANNEL TO OUTPUT ON IF BUFFERD IO
IFE %HISEG,	<RELOC>		;HIGH


;	CALL CURSOR( IX, IY )	TAKE CURSOR TO CARTESIAN
;				X-Y COORDINATE

	ENTRY	CURSOR
CURSOR:	MOVE	T11,CURDIS	;GET SCREEN NUMBER, IF ZERO THEN
	JUMPLE	T11,NOTCRD	;WE ACTUALLY WANT TO MOVE THE CURSOR
	SKIPG	T1,@0(ARG)	;MAKE X-COORDINATE IN BOUNDS
	MOVEI	T1,1
	CAILE	T1,%SCRWID
	MOVEI	T1,%SCRWID
	MOVEM	T1,XPOS(T11)	;AND STORE IT AWAY AS CURRENT POS
	SKIPG	T1,@1(ARG)	;MAKE Y-COORDINATE IN BOUNDS
	MOVEI	T1,1
	CAILE	T1,%SCRLEN
	MOVEI	T1,%SCRLEN
	MOVEM	T1,YPOS(T11)	;AND STORE IT AWAY AS CURRENT POS
	RETURN

NOTCRD:	MOVE	T11,@0(ARG)	;HE ACTUALLY WANTED TO MOVE THE CURSOR
	SUBI	T11,1		;FUDGE COORDINATES FROM CARTESIAN
	MOVEM	T11,XCOOD	;SYSTEM (1..80, 1..24) TO SCREEN
	MOVEI	T11,%SCRLEN	;SYSTEM (0..23, 0..79)
	SUB	T11,@1(ARG)
	MOVEM	T11,YCOOD
	SKIPL	T11,TFLAG	;IF TTY TYPE LEGAL
	GOTO	@CTABLE(T11)	;JUMP TO ITS TYPE
	RETURN			;ELSE IGNORE HIM

CTABLE:	CADS58			;CURSOR JUMP TABLE
	CADM3A
	CVT52
	CISC
	CISCB
	CPE550
	CADS98
	CACTV
	CVT100
	CADVAN
	CANSI

CADS58:	MOVEI	CHAR,^D11	;CURSOR ROUTINE FOR ADDS580
	CALL	DCRNOW		;OUTPUT ASCII VERTICAL TAB
	MOVE	CHAR,YCOOD	;GET Y COORDINATE
	TRO	CHAR,100	;MAKE SURE RIGHT BIT IS ON
	CALL	DCRNOW		;AND OUTPUT IT TO MAKE CURSOR Y
	MOVEI	CHAR,^D16	;GET A HORIZONTAL TAB
	CALL	DCRNOW		;OUTPUT IT
	MOVE	CHAR,XCOOD	;NOW GET X COORDINATE
	IDIVI	CHAR,^D10	;DIVIDE UP INTO GROUPS OF TEN
	LSH	CHAR,4		;SHIFT OVER SO IT WILL BE A NUMBER
	ADD	CHAR,CHAR+1	;AND PUT IN THE "UNITS" DIGIT
	CALL	DCRNOW		;OUTPUT THAT
	RETURN

CADVAN:
CADM3A:	MOVEI	CHAR,33		;CURSOR ROUTINE FOR ADM'S.
	CALL	DCRNOW		;PRINT THE ESCAPE
	MOVEI	CHAR,"="	;AND AN EQUALS
	CALL	DCRNOW		;TO SAY THAT NEXT IS CURSOR JUMP
	MOVE	CHAR,YCOOD	;GET Y COORDINATE TO JUMP TO
	ADDI	CHAR," "	;MAKE IT READABLE BY TERMINAL
	CALL	DCRNOW		;AND DUMP IT
	MOVE	CHAR,XCOOD	;SAME FOR X COORDINATE
	ADDI	CHAR," "
	CALL	DCRNOW
	RETURN

CVT52:	MOVEI	CHAR,33		;CURSOR ROUTINE FOR VT52'S
	CALL	DCRNOW		;PRINT THE ESCAPE
	MOVEI	CHAR,"Y"	;AND A Y
	CALL	DCRNOW		;TO SAY THIS IS CURSOR MOVEMENT
	MOVE	CHAR,YCOOD	;GET Y COORDINATE
	ADDI	CHAR," "	;AND ADD SPACE TO MAKE IT TTY READABLE
	CALL	DCRNOW		;DUMP IT
	MOVE	CHAR,XCOOD	;DO THE SAME THING FOR X
	ADDI	CHAR," "
	CALL	DCRNOW
	RETURN

CISC:	MOVEI	CHAR,3		;CURSOR ROUTINE FOR ISC'S (NO A7)
	CALL	DCRNOW		;DUMP CONTROL-C (C, FOR CURSOR)
	MOVE	CHAR,XCOOD	;GET THE X COORDINATE
	CALL	DCRNOW		;DUMP IT
	MOVE	CHAR,YCOOD	;AND THE Y COORDINATE
	ADDI	CHAR,%SCRLEN	;ADD IN 24 BECAUSE SMALL SCREEN
	CALL	DCRNOW		;AND DUMP IT
	RETURN

CISCB:	MOVEI	CHAR,3		;CURSOR ROUTINE FOR ISC'S (A7 ON)
	CALL	DCRNOW		;DUMP CONTROL-C FOR CURSOR
	MOVE	CHAR,XCOOD	;GET X COORDINATE
	CALL	DCRNOW		;DUMP IT
	MOVE	CHAR,YCOOD	;AND Y COORDINATE
	ADDI	CHAR,^D22	;FUDGE TO MAKE SURE CURSOR
	IMULI	CHAR,2		;JUMPS TO CORRECT POSITION FOR
	ADDI	CHAR,24		;LARGE CHARACTER SET
	CALL	DCRNOW		;DUMP RESULTING CHARACTER
	RETURN

CPE550:	MOVEI	CHAR,33		;CURSOR ROUTINE FOR BANTAMS
	CALL	DCRNOW		;OUTPUT AN ESCAPE
	MOVEI	CHAR,"Y"	;AND A Y
	CALL	DCRNOW		;TO SAY THIS IS A CURSOR COMMAND
	MOVE	CHAR,XCOOD	;GET THE X COORDINATE
	ADDI	CHAR," "	;MAKE IT TTY READABLE
	CALL	DCRNOW		;AND PRINT IT
	MOVEI	CHAR,33		;GET WORDS SEPARATED WITH ESCAPES
	CALL	DCRNOW		;OUTPUT THAT
	MOVEI	CHAR,"X"	;GET X TO SAY WE ARE ABOUT TO SET Y
	CALL	DCRNOW		;DUMP IT	(STANDARDS ARE FUN)
	MOVE	CHAR,YCOOD	;GET Y COORDINATE
	ADDI	CHAR," "	;MAKE IT TTY READABLE
	CALL	DCRNOW		;AND DUMP IT
	RETURN

CADS98:	MOVEI	CHAR,^D11	;CURSOR ROUTINE FOR ADDS980S
	CALL	DCRNOW		;OUTPUT VERTICAL TAB
	MOVE	CHAR,YCOOD	;GET Y COORDINATE
	TRO	CHAR,100	;AND MAKE SURE THE RIGHT BIT IS ON
	CALL	DCRNOW		;DUMP IT
	MOVEI	CHAR,33		;GET AN ESCAPE
	CALL	DCRNOW		;DUMP IT
	MOVEI	CHAR,5		;GET A CONTROL E
	CALL	DCRNOW		;AND DUMP IT
	MOVE	CHAR,XCOOD	;NOW GET X COORDINATE THAT
	IDIVI	CHAR,^D10	;PREVIOUS SETS UP.  SET UP TO
	ADDI	CHAR,"0"	;OUTPUT AS A NUMBER
	CALL	DCRNOW		;OUTPUT LEADING DIGIT
	MOVE	CHAR,T12	;NOW GET REMAINDER AS LAST DIGIT
	ADDI	CHAR,"0"	;MAKE IT ASCII
	CALL	DCRNOW		;AND DUMP IT
	RETURN

CACTV:	MOVEI	CHAR,24		;CURSOR ROUTINE FOR ACT-5'S
	CALL	DCRNOW		;OUTPUT A CONTROL T FOR CURSOR
	MOVE	CHAR,YCOOD	;GET Y COORDINATE
	CALL	DCRNOW		;DUMP IT
	MOVE	CHAR,XCOOD	;AND X COORDINATE
	CALL	DCRNOW		;DUMP IT
	RETURN

CANSI:				;For now, we handle it like a VT100
CVT100:	MOVEI	CHAR,33		;GET AN ESCAPE
	CALL	DCRNOW		;DUMP IT
	MOVEI	CHAR,"["	;GET CURSOR CONTROL CHARACTER
	CALL	DCRNOW		;DUMP IT
	MOVE	TEMP,YCOOD	;GET THE Y COORDINATE
	ADDI	TEMP,1		;FUDGE (VT100'S SCREEN IS 1..24)
	IDIVI	TEMP,^D10	;LOP OFF FIRST DIGIT
	MOVE	CHAR,TEMP	;SETUP FOR DCRNOW
	ADDI	CHAR,"0"	;MAKE IT LOOK LIKE A DIGIT
	CALL	DCRNOW		;AND OUTPUT IT
	MOVE	CHAR,TEMP+1	;GET LAST DIGIT
	ADDI	CHAR,"0"	;MAKE IT LOOK LIKE A DIGIT
	CALL	DCRNOW		;AND OUTPUT IT
	MOVEI	CHAR,";"	;GET SEPARATOR
	CALL	DCRNOW		;AND OUTPUT IT
	MOVE	TEMP,XCOOD	;GET THE X COORDINATE
	ADDI	TEMP,1		;FUDGE (VT100'S SCREEN IS 1..80)
	IDIVI	TEMP,^D10	;LOP OFF FIRST DIGIT
	MOVE	CHAR,TEMP	;SETUP FOR DCRNOW
	ADDI	CHAR,"0"	;MAKE IT LOOK LIKE A DIGIT
	CALL	DCRNOW		;AND OUTPUT IT
	MOVE	CHAR,TEMP+1	;GET LAST DIGIT
	ADDI	CHAR,"0"	;MAKE IT LOOK LIKE A DIGIT
	CALL	DCRNOW		;AND OUTPUT IT
	MOVEI	CHAR,"H"	;GET THE FINAL CHARACTER
	CALL	DCRNOW		;OUTPUT IT
	RETURN			;AND RETURN


;	CALL CLRSCR		CLEAR SCREEN

	ENTRY	CLRSCR
CLRSCR:	MOVE	T11,CURDIS	;IF SCREEN NUMBER IS ZERO
	JUMPLE	T11,CLNTDS	;THEN ACTUALLY CLEAR THE SCREEN
	MOVE	T1,DISADR(T11)	;ELSE GET ADDRESS OF ARRAY TO CLEAR
	MOVE	TEMP,[COMPOSE(0,7," "),,COMPOSE(0,7," ")]	;GET SOME SPACES TO PUT IN IT
	MOVEM	TEMP,(T1)	;SET THE FIRST MEMBER TO SPACES
	HRL	T1,T1		;SET UP FOR BLT
	HRR	TEMP,T1
	ADDI	T1,1
	ADDI	TEMP,%SCRWDS-1	;SET DESTINATION TO INCLUDE LAST MEM
	HRLI	TEMP,(BLT	T1,0)	;GET THE BLT
	XCT	TEMP		;AND ZAP THAT CORE!
	RETURN

CLNTDS:	SKIPL	T11,TFLAG	;GET TERMINAL TYPE
	GOTO	@NTABLE(11)	;IF ITS LEGAL, GO TO APPROPRIATE PLACE
	RETURN			;ELSE IGNORE HIM

NTABLE:	NADS58			;JUMP TABLE FOR CLEARING SCREEN
	NADM3A
	NVT52
	NISC
	NISC			;FOR ISC BIG
	NPE550
	NADS98
	NACTV
	NVT100
	NADVAN
	NANSI

NADS58:	MOVEI	CHAR,14		;CLEAR ADDS580 SCREEN
	CALL	DCRNOW		;DUMP A CONTROL-L
	RETURN

NADM3A:	MOVEI	CHAR,32		;CLEAR ADM3 SCREEN
	CALL	DCRNOW		;DUMP A CONTROL-Z
	MOVEI	11,14		;SPECIAL TERMINAL (UNH MOD)
	CALL	DCRNOW		;FOLLOWED BY A CONTROL-L
	RETURN

NVT52:	MOVEI	CHAR,33		;CLEAR VT52 SCREEN
	CALL	DCRNOW		;DUMP ESCAPE
	MOVEI	CHAR,"H"	;FOLLOWED BY THE
	CALL	DCRNOW		;CHARACTER H
	MOVEI	CHAR,33		;FOLLOWED BY
	CALL	DCRNOW		;ANOTHER ESCAPE
	MOVEI	CHAR,"J"	;FOLLOWED BY THE
	CALL	DCRNOW		;CHARACTER J
	RETURN

NISC:	MOVEI	CHAR,14		;CLEAR ISC SCREEN
	CALL	DCRNOW		;DUMP A CONTROL-L
	GOTO	TWAIT		;AND WAIT UNTIL IT DOES IT

NPE550:	MOVEI	CHAR,33		;CLEAR BANTAM SCREEN
	CALL	DCRNOW		;OUTPUT AN ESCAPE
	MOVEI	CHAR,"K"	;FOLLOWED BY A K
	CALL	DCRNOW		;DUMP IT
	GOTO	TWAIT		;AND WAIT FOR A WHILE

NADS98:	MOVEI	CHAR,37		;CLEAR ADDS980 SCREEN
	CALL	DCRNOW		;OUTPUT CONTROL CODE
	MOVEI	CHAR,17		;FOLLOWED BY A CONTROL-O
	CALL	DCRNOW		;DUMP IT
	MOVEI	CHAR,14		;FOLLOWED BY A CONTROL-L
	CALL	DCRNOW
	RETURN

NACTV:	MOVEI	CHAR,14		;CLEAR ACT-5'S SCREEN
	CALL	DCRNOW		;DUMP A CONTROL-L
	RETURN

NANSI:				;For now, we handle it like a VT100
NVT100:	MOVEI	CHAR,33		;GET AN ESCAPE FOR SEQUENCE
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"["	;GET CURSOR SEQUENCE
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"2"	;CLEAR PARAMETER 2 (ENTIRE SCREEN)
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"J"	;FINAL CHAR
	CALL	DCRNOW		;OUTPUT IT
	GOTO	TWAIT		;AND WAIT FOR IT TO CLEAR

NADVAN:	MOVEI	CHAR,36		;GET CURSOR HOME CHARACTER
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,17		;GET CLEAR TO END OF SCREEN CHAR
	CALL	DCRNOW		;OUTPUT IT
	GOTO	TWAIT		;WAIT FOR IT TO HAPPEN

TWAIT:	MOVEI	TEMP,^D100	;OUTPUT NULL'S TILL SCREEN CAN
	SETZ	CHAR,		;CONTINUE
NULLOP:	CALL	DCRNOW
	SOJG	TEMP,NULLOP	;IF MORE, OUTPUT ANOTHER
	RETURN

ISCANS:				;MAP ISC TO ANSI COLORS
	"7"			;WHITE
	"4"			;BLUE
	"1"			;RED
	"6"			;LIGHT BLUE (CYAN)
	"5"			;MAGENTA (PURPLE)
	"2"			;GREEN
	"3"			;YELLOW
	"0"			;BLACK

ISCCOL:				;MAP ISC TO CHARACTER CODES FOR THOSE COLORS
	^D23			;WHITE
	^D20			;DARK BLUE
	^D17			;RED
	^D22			;LIGHT BLUE
	^D21			;PURPLE
	^D18			;GREEN
	^D19			;YELLOW
	^D16			;BLACK

FTABLE:	FADS58			;JUMP TABLE FOR CHANGE FOREGROUND
	FADM3A
	FVT52
	FISC
	FISC			;FOR ISC BIG
	FPE550
	FADS98
	FACTV
	FVT100
	FADVAN
	FANSI

GPCOLO:	SKIPG	T1,@0(ARG)	;GET THE NEW COLOR, BOUNDS CHECK
	FATAL(PCOLOR Color in register 1 less than 1)
	CAILE	T1,^D8
	FATAL(PCOLOR Color in register 1 greater than 8)
	RETURN			;COLOR IN T1

	ENTRY PCOLOR
PCOLOR:	MOVE	T11,CURDIS	;IF WE'RE NOT GOING TO A DISPLAY
	JUMPLE	T11,APCOLO	;SKIP TO ACTUAL HARDWARE MANIPULATION
	CALL	GPCOLO		;GET COLOR
	MOVEM	T1,DISFG(T11)	;SAVE IT
	RETURN

APCOLO:
	;RETURN
	SAVE	CHAR
	SAVE	T1
	SKIPL	T1,TFLAG	;GET TERMINAL TYPE AND SKIP IF UNSET
	GOTO	@FTABLE(T1)	;AND GO TO HANDLER

FADS58:				;NONE OF THESE TERMINALS DO COLOR
FADM3A:
FVT52:
FPE550:
FADS98:
FACTV:
FVT100:
FADVAN:
FDONE:	RESTORE	T1		;NO FINISH UP CODE - JUST RETURN
	RESTORE	CHAR
	RETURN

FISC:	MOVEI	CHAR,^D29	;SETUP ISC FOR COLOR CHANGE
	CALL	DCRNOW		;OUTPUT CHARACTER
	CALL	GPCOLO		;GET NEW COLOR AND BOUNDS CHECK
	MOVE	CHAR,ISCCOL-1(T1)	;GET MAP CHARACTER
	CALL	DCRNOW		;OUTPUT IT
	GOTO	FDONE

FANSI:	MOVEI	CHAR,33		;GET ESCAPE FOR BEGINNING OF ANSI
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"["	;GET NEXT CHAR
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"3"	;GET NEXT CHAR
	CALL	DCRNOW		;OUTPUT IT
	CALL	GPCOLO		;GET NEW COLOR AND BOUNDS CHECK
	MOVE	CHAR,ISCANS-1(T1)	;GET CHARACTER CORRESPONDING TO CODE
	CALL	DCRNOW		;OUTPUT
	MOVEI	CHAR,"m"	;GET LAST CHAR
	CALL	DCRNOW		;OUTPUT IT
	GOTO	FDONE

BTABLE:	BADS58			;JUMP TABLE FOR CHANGE BACKGROUND
	BADM3A
	BVT52
	BISC
	BISC			;FOR ISC BIG
	BPE550
	BADS98
	BACTV
	BVT100
	BADVAN
	BANSI

GPBACK:	SKIPG	T1,@0(ARG)	;GET THE NEW COLOR, BOUNDS CHECK
	FATAL(PBACK Color in register 1 less than 1)
	CAILE	T1,^D8
	FATAL(PBACK Color in register 1 greater than 8)
	RETURN			;COLOR IN T1

	ENTRY	PBACK
PBACK:	MOVE	T11,CURDIS	;IF WE'RE NOT GOING TO A DISPLAY
	JUMPLE	T11,APBACK	;SKIP TO ACTUAL HARDWARE MANIPULATION
	CALL	GPBACK		;GET NEW COLOR
	MOVEM	T1,DISBG(T11)	;SAVE IT
	RETURN

APBACK:
	;RETURN
	SAVE	CHAR
	SAVE	T1
	SKIPL	T1,TFLAG	;GET TERMINAL TYPE AND SKIP IF UNSET
	GOTO	@BTABLE(T1)	;AND GO TO HANDLER

BADS58:				;NONE OF THESE TERMINALS DO COLOR
BADM3A:
BVT52:
BPE550:
BADS98:
BACTV:
BVT100:
BADVAN:
BDONE:	RESTORE	T1		;NO FINISH UP CODE - JUST RETURN
	RESTORE	CHAR
	RETURN

BISC:	MOVEI	CHAR,^D30	;SETUP ISC FOR COLOR CHANGE
	CALL	DCRNOW		;OUTPUT CHARACTER
	CALL	GPBACK		;GET NEW COLOR AND BOUNDS CHECK
	MOVE	CHAR,ISCCOL-1(T1)	;GET MAP CHARACTER
	CALL	DCRNOW		;OUTPUT IT
	GOTO	BDONE

BANSI:	MOVEI	CHAR,33		;GET ESCAPE FOR BEGINNING OF ANSI
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"["	;GET NEXT CHAR
	CALL	DCRNOW		;OUTPUT IT
	MOVEI	CHAR,"4"	;GET NEXT CHAR
	CALL	DCRNOW		;OUTPUT IT
	CALL	GPBACK		;GET NEW COLOR AND BOUNDS CHECK
	MOVE	CHAR,ISCANS-1(T1)	;GET CHARACTER CORRESPONDING TO CODE
	CALL	DCRNOW		;OUTPUT
	MOVEI	CHAR,"m"	;GET LAST CHAR
	CALL	DCRNOW		;OUTPUT IT
	GOTO	FDONE

;	CALL NUMBER( NUM [, LENGTH [, BASE ]] )	OUTPUT
;				AN INTEGER OF LENGTH DIGITS
;				IN BASE BASE
;		OR
;
;	CALL NUMBER( RNUM, LENGTH, BASE, FIELD )	OUTPUT
;				A REAL NUMBER WITH INTEGER
;				PORTION LENGTH DIGITS AND
;				REAL PORTION FIELD DIGITS
;				IN BASE BASE

	ENTRY	NUMBER
NUMBER:	MOVN	T4,-1(ARG)	;GET FORTRAN'S NUMBER OF ARG'S.
	HLRZ	T4,T4		;PUT IT ON THE RIGHT OF THE WORD
	SETZM	NUMCHR		;HAVEN'T OUTPUTTED ANY CHAR'S YET
	SETZB	TEMP,T7		;DEFAULT LENGTH, NOT NEGATIVE YET
	CAIL	T4,2		;IF WE HAVE 2 OR MORE ARGS
	MOVE	TEMP,@1(ARG)	;GET LENGTH
	MOVEM	TEMP,LENGTH	;AND REMEMBER IT
	MOVEI	T1,^D10		;GET DEFAULT BASE
	CAIL	T4,3		;IF WE HAVE 3 OR MORE ARGS
	MOVE	T1,@2(ARG)	;GET BASE
	MOVE	TEMP,T1		;MAKE SURE ITS ABS VALUE > 1
	SKIPGE	TEMP
	MOVN	TEMP,1
	CAIGE	TEMP,2
	MOVEI	T1,^D10		;IF NOT, GET DEFAULT OF 10
	MOVEM	T1,BASE		;AND REMEMBER BASE
	MOVE	TEMP,@0(ARG)	;GET THE NUMBER ITSELF
	MOVE	T5,0(ARG)	;GET THE THING POINTING TO IT.
	JUMPGE	T1,NRMNUM	;IF POS BASE, AVOID SCREWY LOGIC
	TLNN	T5,200		;IS THIS A REAL NUMBER?  (FORTRAN SET)
	GOTO	NOTNEG		;IF IT ISN'T THEN WE WON'T HAVE A -
	JUMPLE	TEMP,NOTNEG	;OR IF NUMBER IS NEGATIVE
	GOTO	NEGSGN		;ELSE, WE WILL (NEGATIVE BASES ARE FUN)

NRMNUM:	JUMPGE	TEMP,NOTNEG	;NORMAL NUMBER, POS, NO -
NEGSGN:	SETO	T7,		;SET NEG FLAG
	SKIPLE	LENGTH		;AND DEC MAG OF LENGTH IF NOT ZERO
	SOS	LENGTH
	SKIPGE	LENGTH
	AOS	LENGTH
	MOVN	TEMP,TEMP	;GET POSITIVE OF LENGTH
NOTNEG:	TLNN	T5,200		;IS THIS A REAL NUMBER
	GOTO	OUTINT		;NO, OUTPUT IT AS IN INTEGER

	FIX	T5,TEMP		;GET INTEGER PORTION TO PRINT
	MOVEM	T5,T12		;AND REMEMBER IT
	FLTR	T5,T5		;ALSO EXTRACT REAL REMAINDER
	FSBR	TEMP,T5		;AND STICK THAT IN TEMP
	MOVEI	T10,1		;START POWER LOOP
	FLTR	T2,BASE		;GET NUMBER TO RAISE TO THE POWER
	MOVEI	T6,2		;DEFAULT NUMBER DIGS TO RIGHT OF .
	CAIL	T4,4		;DO WE HAVE ENOUGH ARGS?
	MOVE	T6,@3(ARG)	;YES, GET ACTUAL NUMBER OF DIGS
	MOVE	T5,T6		;AND USE IT TO LOOP
RLOOP:	FMPR	TEMP,T2		;RAISE NUMBER BY ONE POWER OF BASE
	IMUL	T10,BASE	;RAISE THE BASE BY ONE POWER
	SOJG	T5,RLOOP	;AND DO AGAIN UNTIL NO MORE DIGITS
	FIXR	TEMP,TEMP	;TRUNCATE THE TRAILING DIGITS AWAY
	IDIV	TEMP,T10	;AND EXTRACT THE FRACTIONAL PART
	ADD	TEMP,T12	;ADD IN WHAT WE KNEW WAS INTEGER
	MOVE	T5,T1		;REMEMBER FRACTIONAL PART
	CALL	OUTINT		;AND OUTPUT INTEGER PART IN TEMP
	SETZ	T7,		;MAKE SURE FRACTION HAS NO SIGN
	MOVNM	T6,LENGTH	;ALSO, MAKE SURE IT HAS LEADING ZEROS
	MOVEI	CHAR,"."	;GET A DECIMAL POINT TO PRINT
	SKIPL	T6		;IF < 0 DON'T PRINT POINT
	CALL	DCHAR		;ELSE DO
	SKIPG	T6		;IF POSITIVE GO OUTPUT FRACTION
	RETURN			;ELSE DON'T BOTHER
	AOS	NUMCHR		;ACCOUNT FOR .
	MOVE	TEMP,T5		;RECALL FRACTIONAL PART AND GO

OUTINT:	MOVE	T3,LENGTH	;GET LENGTH IN A COUNTER
	SKIPGE	T3		;IF ITS NEGATIVE, MAKE IT POSITIVE
	MOVN	T3,T3
	SETZ	T2,		;ZERO USED SO FAR
LOOP1:	IDIV	TEMP,BASE	;LOOP DIVIDING OFF LAST DIGITS
	SKIPL	BASE		;IF POSITIVE BASE
	GOTO	POSBAS		;WE CAN AVOID THIS
	JUMPGE	T1,POSBAS	;ALSO IF REMAINDER IS POSITIVE
	SUB	T1,BASE		;ELSE, DIGIT IS BASE - REMAINDER
	ADDI	TEMP,1		;THE NUMBER WE SUBTRACTED FROM CARRIES
				;AREN'T NEGATIVE BASES FUN?
POSBAS:	ADDI	T1,"0"		;ADD A ZERO TO MAKE IT ASCII
	CAILE	T1,"9"		;IF ITS GREATER THAN 9
	ADDI	T1,^D7		;AND MAKE IT ALPHABETIC.
	AOS	T2		;INCREMENT DIGITS USED
	SAVE	T1		;PUT DIGIT ON STACK TO GET IN REVERSE
	SOS	T3		;DECREMENT DIGITS ALLOWED TO USE
	SKIPL	LENGTH		;IF LENGTH NO NEGATIVE
	SKIPE	TEMP		;AND RESULT OF DIV WAS ZERO, EXIT LOOP
	JUMPN	T3,LOOP1	;ELSE, IF MORE DIGITS, GET THEM
	JUMPLE	T3,NPAD		;IF USER SPECIFIED MORE DIGITS, PAD
	MOVEI	CHAR," "	;SPACE TO PAD WITH
PAD:	CALL	DCHAR		;PADDING LOOP
	AOS	NUMCHR		;INCREMENT NUMBER OF CHARS
	SOJG	T3,PAD		;AND PAD SOME MORE
NPAD:	JUMPE	T7,LOOP2	;NOT NEGATIVE, AVOID THIS
	MOVEI	CHAR,"-"	;ELSE, IS NEGATIVE.  PUT OUT A -
	CALL	DCHAR
	AOS	NUMCHR		;IT IS A CHARACTER TOO

LOOP2:	RESTORE	T1		;NOW REMOVE DIGITS FROM STACK
	SKIPN	TEMP		;AND IT WE DON'T HAVE STUFF LEFT OVER
	MOVE	CHAR,T1		;USE DIGIT
	SKIPE	TEMP		;ELSE, THERE WAS STUFF LEFT OVER
	MOVEI	CHAR,"*"	;WHICH MEANS OVER FLOW, PRINT A *
	CALL	DCHAR		;IN ANY CASE, PRINT IT OUT
	AOS	NUMCHR		;IT WAS A CHARACTER, INC COUNT
	SOJG	T2,LOOP2	;AND GO BACK FOR MORE.
	RETURN

IFE %HISEG,	<RELOC>		;LOW
NUMCHR:	0			;NUMBER OF CHARS IN NUM
BASE:	0			;BASE OF NUMBER
LENGTH:	0			;LENGTH OF NUMBER (DIGITS TO LEFT OF .)
	-1,,0			;ARGUMENT BLOCK
CALBLK:	0			;ADDRESS HOLDER OF NUM TO CALL NUMBER
IFE %HISEG,	<RELOC>		;HIGH


;	CALL LNUMBR( NUM [, LENGTH [, BASE ]] )
;		OR
;	CALL LNUMBR( RNUM, LENGTH, BASE, FIELD )
;				OUTPUT INTEGER OR REAL LEFT JUSTIFIED

	ENTRY	LNUMBR
LNUMBR:	SAVE	@1(ARG)		;SAVE THE LENGTH SO WE CAN CHANGE IT
	SETZM	@1(ARG)		;MAKE IT ZERO SO NUMBER IS LEFT JUST
	CALL	NUMBER		;NOW OUTPUT NUMBER LEFT JUST
	RESTORE	@1(ARG)		;AND GET LENGTH BACK
	MOVE	T13,NUMCHR	;GET NUMBER OF SPACES WE HAVE PRINTED
	SUB	T13,@1(ARG)	;AND SUBTRACT THAT WHICH WE MUST PRINT
	MOVEI	CHAR," "	;(LEAVING - OF WHAT WE HAVE LEFT)
LNMLOP:	AOSLE	T13		;INCREMENT UNTIL NO MORE LEFT
	RETURN
	CALL	DCHAR		;OUTPUT THAT SPACE
	GOTO	LNMLOP		;AND GO BACK FOR ANOTHER


;	CALL OUTNUM( RNUM, INUM, INUM, . . . )
;				OUTPUT NUMBERS USING DEFAULTS

	ENTRY	OUTNUM
OUTNUM:	MOVN	T14,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T14,T14		;ON RIGHT SIDE OF WORD
	MOVE	T13,ARG		;SAVE AWAY ARG REGISTER
	MOVEI	ARG,CALBLK	;SET UP CALLING BLOCK TO NUMBER
CLOOP:	MOVE	T12,@T13	;GET WORD CONTAINING POINTER TO
	MOVEM	T12,CALBLK	;NUMBER (WITH REAL/INT FLAG)
	CALL	NUMBER		;OUTPUT THAT NUMBER
	SOSG	T14		;DECREMENT NUMBER LEFT TO DO
	RETURN			;NO MORE, EXIT
	MOVEI	CHAR,","	;OUTPUT SOME SEPARATORS
	CALL	DCHAR
	MOVEI	CHAR," "
	CALL	DCHAR
	AOJA	T13,CLOOP	;AND GO GET ANOTHER NUMBER


;	CALL STRING( STRARA [, IFRMAT [,LENGTH ]] )	OUTPUT STRING
;				STRARA IN IFRMAT OF LENGTH

	ENTRY	STRING
STRING:	MOVN	T2,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T2,T2		;ON RIGHT HALF OF WORD
	MOVEI	T1,5		;SET DEFAULT FORMAT TO A5
	CAIL	T2,T2		;IF ENOUGH ARGUMENTS, GET USERS'S
	MOVE	T1,@1(ARG)	;FORMAT
	SETZB	T3,SIXFRM	;ZERO #BYTES LEFT IN WORD, SIX FLAG
	SETZB	T6,EXONSP	;ZERO CHAR TO EXIT AND EX ON SPACE FLG
	CAIN	T1,6		;IF FORMAT IS SIXBIT,
	SETOM	SIXFRM		;SET THAT FLAG
	MOVEM	T1,NFRMAT	;REMEMBER THE FORMAT
	MOVEI	T4,@0(ARG)	;GET FIRST WORD
	SETOM	CFLAG		;HAVEN'T MET ANY ^'S YET.
	CAIGE	T2,T3		;IF NO MORE ARGS
	GOTO	LOOP4		;LET DEFAULT LENGTH = 0
	MOVE	T6,@2(ARG)	;ELSE GET USER'S LENGTH
	JUMPGE	T6,LOOP4	;AND IF WE NEED TO SET EX ON SPACE FLG
	SETOM	EXONSP		;DO
	MOVN	T6,T6		;AND REMEMBER ONLY THE POSITIVE LENGTH

LOOP4:	SOJG	T3,NLAST	;IF NO MORE WORDS TO THIS BYTE, GET NEW
	MOVE	T1,(T4)		;GET NEW WORD
	MOVE	T3,NFRMAT	;RESET NUM BYTES LEFT TO GO
	AOS	T4		;INCREMENT POINTER TO NEXT WORD
NLAST:	SETZ	TEMP,		;ZERO PLACE FOR CHAR TO GO
	SKIPE	SIXFRM		;AND IF SIXBIT
	GOTO	MAKSIX		;GO TO ITS OUTPUT ROUTINE

	SKIPN	NFRMAT		;IF R1 FORMAT
	LSH	T1,^D29		;MAKE IT LOOK LIKE A1 FORMAT
	LSHC	TEMP,7		;SO SHIFT WILL PUT CHAR IN TEMP
	GOTO	CFCCHR		;GO DUMP IT

MAKSIX:	LSHC	TEMP,6		;ELSE SHIFT IT AS SIXBIT
	ADDI	TEMP," "	;MAKE IT ASCII

CFCCHR:	SKIPE	CFLAG		;ARE WE A ^ CHAR?
	GOTO	NCTL		;NOPE
	CAIE	TEMP,"^"	;YES, IF ^ THEN ACTUALLY A ^
	SUBI	TEMP,100	;ELSE, MAKE IT A CONTROL CHAR
	SETOM	CFLAG		;AND TURN OFF THE CONTROL CHAR FLAG
	GOTO	EXIF		;GO EXIT LOOP IF POSSIBLE

NCTL:	CAIN	TEMP,"^"	;IF THIS ISN'T A ^,
	CAIE	T2,1		;OR NOT 1 ARGUMENT
	GOTO	EXIF		;THEN FOLLOWING IS NOT A CONTROL CHAR
	SETZB	TEMP,CFLAG	;ELSE FLAG THAT IT MIGHT BE
	GOTO	ECLOOP		;AND GO GET ANOTHER

EXIF:	CAIN	TEMP,2		;IS THIS A DUMP BUFFER CHAR?
	GOTO	CURBUF		;YES, (CONTROL-B) - GO DUMP IT
	SKIPE	EXONSP		;ARE WE SUPPOSED TO DIE ON A SPACE
	CAIE	TEMP," "	;WELL, WE GOT A SPACE
	CAIN	TEMP,5		;OR WE GOT A CONTROL-E
	RETURN			;GET OUT OF THIS LOOP!
	MOVE	CHAR,TEMP	;ELSE, PREPARE TO OUTPUT TEMP
	CALL	DCHAR		;DUMP IT
ECLOOP:	SOJN	T6,LOOP4	;ELSE, GO BACK FOR ANOTHER CHAR

	RETURN


;	CALL OUTSPC( FILESP )	OUTPUT A FILESPEC ARRAY

	ENTRY	OUTSPC
OUTSPC:	SAVE	ARG		;WILL BE CALLING STUFF, CAN'T DESTROY
	MOVEI	T14,@0(ARG)	;GET ADDRESS OF ARRAY
	MOVEI	ARG,SIXBLK	;GET BLOCK FOR OUTPUTTING SIXBIT
	MOVE	T13,1(T14)	;GET NODE FROM ARRAY
	JUMPE	T13,NONODE	;ZERO, IGNORE IT
	CALL	STRING		;ELSE PRINT IT OUT
	MOVEI	CHAR,"_"	;AND DELIMIT WITH AN UNDERSCORE
	CALL	DCHAR
NONODE:	MOVE	T13,2(T14)	;NOW GET DEVICE
	JUMPE	T13,NODEVI	;IF ZERO IGNORE IT
	CALL	STRING		;ELSE PRINT AND DELIMIT
	MOVEI	CHAR,":"
	CALL	DCHAR
NODEVI:	MOVE	T13,3(T14)	;GET FILENAME
	JUMPE	T13,NOFILE	;IF ZERO, IGNORE IT
	CALL	STRING		;ELSE OUTPUT IT
NOFILE:	SKIPN	4(T14)		;IS THERE AN EXTENSION
	GOTO	NOEXT		;NOPE
	MOVEI	CHAR,"."	;ELSE DELIMIT IT
	CALL	DCHAR
	HLLZ	T13,4(T14)	;GET IT AND
	CALL	STRING		;PRINT IT
NOEXT:	MOVNI	T13,3		;-3 MEANS 3 DIGITS, LEADING ZEROS
	MOVEM	T13,WIDBLK	;PUT IT IN NUMBER BLOCK
	MOVEI	CHAR,"<"	;GET DELIMITER
	CALL	DCHAR		;PRINT IT
	MOVEI	ARG,NUMBLK	;SET UP TO CALL NUMBER
	MOVE	T13,5(T14)	;GET PROTECTION
	CALL	NUMBER		;PRINT IT
	MOVEI	CHAR,">"	;GET OTHER DELIMITER
	CALL	DCHAR		;PRINT IT
	SKIPN	T13,6(T14)	;GET PROJECT
	GOTO	NOPATH		;IF ZERO, THERE IS NO PATH
	MOVEI	CHAR,"["	;PPN DELIMITER
	CALL	DCHAR		;PRINT IT
	SETZM	WIDBLK		;NO PARTICULAR LENGTH FOR PROJECTS
	CALL	NUMBER		;PRINT PROJECT
	MOVEI	CHAR,","	;GET SEPARATOR
	CALL	DCHAR		;PRINT IT
	MOVE	T13,7(T14)	;GET PROGRAMMER
	CALL	NUMBER		;PRINT IT
	MOVEI	T10,5		;GET MAX NUMBER SFD'S
	MOVEI	ARG,SIXBLK	;AND GO BACK TO SIXBIT BLOCK
SFDLOP:	SKIPN	T13,10(T14)	;GET SFD, CHECK IF IT WAS ZERO
	GOTO	EXSLOP		;IT WAS, EXIT LOOP
	MOVEI	CHAR,","	;GET SEPARATOR
	CALL	DCHAR		;PRINT IT
	CALL	STRING		;PRINT SFD NAME
	ADDI	T14,1		;AND INCREMENT POINTER INTO ARRAY
	SOJG	T10,SFDLOP	;IF MORE SFD'S, GO GET THEM
EXSLOP:	MOVEI	CHAR,"]"	;ELSE, GET DELIMITER
	CALL	DCHAR		;AND PRINT IT
NOPATH:	RESTORE	ARG		;AND RESTORE ARG PTR
	RETURN

SIXBLK:	T13			;WORD WILL BE IN REG T13
	[6]			;IT WILL BE SIXBIT
	[-6]			;IF WILL HAVE 6 CHAR'S, STOP ON SPACE

NUMBLK:	T13			;WORD WILL BE IN REG T13
	WIDBLK			;NUMBER OF DIGITS STORED IN WIDBLK
	[10]			;DEFAULT BASE WILL BE OCTAL

IFE %HISEG,	<RELOC>		;LOW
WIDBLK:	0			;-3 OR 0 FOR PROT AND PPN IN OUTSPC
EXONSP:	0			;FLAG, TRUE IF PRINT VAR WITH SPACE

SIXFRM:	0			;SIXBIT FLAG
NFRMAT:	0			;CONTAINS FORMAT NUMBER
CFLAG:	-1			;GETS CONTROL CHARACTER FLAG
IFE %HISEG,	<RELOC>		;HIGH


;	CALL CHROUT( ICHAR )	OUTPUT ICHAR (EITHER A1 OR R1 FORMAT)
;		OR
;	CALL REPEAT( ICHAR, NUMTMS )	OUTPUT ICHAR NUMTMS TIMES

	ENTRY	CHROUT,REPEAT
CHROUT:
REPEAT:	MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	TEMP,TEMP	;IN RIGHT HALF
	CAIE	TEMP,1		;IF ONLY 1, NUMTMS = 1
	MOVE	TEMP,@1(ARG)	;ELSE, NUMTMS SUPPLIED BY USER
	MOVE	CHAR,@0(ARG)	;GET CHAR TO OUTPUT
	TLNE	CHAR,-1		;IS IT A1?
	LSH	CHAR,^D-29	;ITS A1, MAKE IT R1
CRLOOP:	CALL	DCHAR		;OUTPUT IT
	SOJG	TEMP,CRLOOP	;AND IF MORE, OUTPUT IT AGAIN
	RETURN


;	CALL CRLF		OUTPUT A CRLF

	ENTRY	CRLF
CRLF:	MOVEI	CHAR,15		;GET A CARRIAGE RETURN
	CALL	DCHAR		;PRINT IT
	MOVEI	CHAR,12		;GET A LINE FEED
	CALL	DCHAR		;PRINT IT
	RETURN


;	CALL CURBUF		DUMP CURRENT BUFFER

	ENTRY	CURBUF
CURBUF:	SKIPG	CHAN		;IF CHANNEL IS NOT POSITIVE, NOT
	RETURN			;USING BUFFERRED IO, RETURN
	SAVE	ARG		;ELSE SAVE ARG REGISTER
	MOVEI	ARG,ARGPTR	;SET UP TO CALL OUTBUF
	CALL	OUTBUF		;DUMP THAT BUFFER!
	RESTORE	ARG		;GET BACK OLD ARG REGISTER
	RETURN


;	CALL CURPOS( XP, YP )	RETURN CURRENT CURSOR POSITION

	ENTRY	CURPOS
CURPOS:	MOVE	T1,CURDIS	;GET SCREEN NUMBER
	MOVE	TEMP,XPOS(T1)	;GET X POSITION FROM ARRAY
	MOVEM	TEMP,@0(ARG)	;RETURN IT
	MOVE	TEMP,YPOS(T1)	;GET Y POSITION FROM ARRAY
	MOVEM	TEMP,@1(ARG)	;RETURN IT
	RETURN


;	CALL SETDIS( IDIS )	SET CURRENT DEST FOR CALLS

	ENTRY	SETDIS
SETDIS:	SETOM	ERRFLG		;GUILTY UNTIL PROVEN INNOCENT
	SKIPL	T1,@0(ARG)	;IF ARGUMENT IS NOT IN
	CAILE	T1,20		;RANGE
	RETURN			;RETURN (ERROR SET)
	SKIPN	DISADR(T1)	;ELSE, IS SCREEN DEFINED
	RETURN			;NOPE
	SETZM	ERRFLG		;YES, HE SEEMS TO KNOW WHAT'S GOING ON
	MOVEM	T1,CURDIS	;REMEMBER THE CURRENT DISPLAY
	RETURN


;	CALL NEWSCR( IDIS )	PRINT FRESH VERSION OF SCREEN

	ENTRY	NEWSCR
NEWSCR:	CALL	CLNTDS		;THE FIRST THING TO DO IS CLEAR SCREEN
	SKIPN	GRFMOD		;IF NOT IN GRAPHIC MODE
	GOTO	NOSETP		;DON'T BOTHER SETTING TAPE ETC
	MOVEI	T1,SETAPE	;SET TAPE SO CR'S DON'T IMPLY LF'S
	MOVEI	T2,1		;(ONLY ONE THING TO SET)
	CALL	ISET		;GO SET IT

NOSETP:	MOVEI	T1,OLDISP	;MAKE SURE WE PRINT EVERYTHING
	MOVE	TEMP,[0]	;SO CLEAR ARRAY OUT
	MOVEM	TEMP,(T1)	;WITH THE BLT OP
	HRL	T1,T1
	HRRZ	TEMP,T1
	ADDI	T1,1
	ADDI	TEMP,%SCRWDS-1
	HRLI	TEMP,(BLT	T1,0)
	XCT	0		;NOW OLD DISPLAY GONE
				;FALL THROUGH TO UPDATE IT

;	CALL UPDATE( IDIS )	PRINT CHANGED SCREEN

	ENTRY	UPDATE
UPDATE:	SETOM	ERRFLG		;ASSUME HE GOT AN ERROR
	SKIPLE	T1,@0(ARG)	;SO IF HE GIVES A BAD
	CAILE	T1,20		;ARGUMENT
	RETURN			;HE GETS THE ERROR CODE
	SKIPN	T7,DISADR(T1)	;IF SCREEN NOT DEFINED YET
	RETURN			;RETURN WITH ERROR
	SETZM	ERRFLG		;OK, NO ERROR
	SAVE	ARG		;WE WILL NEED IT TO CALL CURSOR ETC.
	HRLI	T7,%SCRBP	;SET UP BYTE POINTER TO USER SCREEN
	MOVE	T10,[XWD %SCRBP,OLDISP]	;SET UP B-POINTER TO OLD ARRAY
	MOVEI	T6,1		;STARTING AT Y=1

YLOOP:	CAILE	T6,%SCRLEN	;INTO Y LOOP, STOP WHEN WE EXCEED 24
	GOTO	ENDYLP
	MOVEI	T5,1		;ELSE, INIT X = 1
	SETZM	LINFLG		;NEW LINE ALWAYS MOVES CURSOR

XLOOP:	CAILE	T5,%SCRWID	;GET OUT OF X LOOP WHEN X EXCEEDS 80
	AOJA	T6,YLOOP	;GO INC Y IF GETTING OUT
	ILDB	T11,T7		;GET VALUE FROM SCREEN
	ILDB	TEMP,T10	;GET VALUE FROM OLD ARRAY
	CAME	T11,TEMP	;IF THEY ARE NOT EQUAL
	GOTO	MAKCHG		;GO UPDATE THE SCREEN
	SETZM	LINFLG		;ELSE, IF WE UPDATE AGAIN, MOVE CURSOR
	AOJA	T5,XLOOP	;INCREMENT X AND TRY AGAIN

MAKCHG:	SAVE	T11		;CURSOR WILL USE T11, BUT WE NEED IT
	MOVEI	ARG,CARGPT	;GET ARGUMENT BLOCK FOR CURSOR
	SKIPN	LINFLG		;IF WE DON'T HAVE TO MOVE CURSOR, SKIP
	CALL	NOTCRD		;ELSE, MOVE CURSOR TO NEWEST POSITION
	RESTORE	T11		;GET BACK THAT CHARACTER
	SAVE	T7		;SAVE T7 FOR COLOR FUN
	MOVE	T7,T11		;GET COPY OF CHARACTER
	LSH	T7,-^D8		;GET BITS 8-WHATEVER
	ANDI	T7,7		;ONLY WANT BITS 8-10
	ADDI	T7,1
	MOVEI	ARG,CARCOL	;SETUP TO CALL PBACK
	SAVE	T11
	CALL	APBACK		;CALL PBACK
	RESTORE	T11
	MOVE	T7,T11		;NOW PLAY SAME GAME FOR BITS 11-13
	LSH	T7,-^D11
	ANDI	T7,7
	ADDI	T7,1
	SAVE	T11
	CALL	APCOLO		;AND CALL PCOLOR
	RESTORE	T11
	RESTORE	T7
	CALL	DCRNOW		;AND DUMP IT
	SETOM	LINFLG		;DON'T MOVE CURSOR UNLESS NECESARY
	DPB	T11,T10		;UPDATE OLD ARRAY
	AOJA	T5,XLOOP	;AND GET NEXT COORDINATE

ENDYLP:	RESTORE	ARG		;OUT OF LOOP, GET OLD ARG
	GOTO	CURBUF		;AND DUMP THE BUFFER

CARGPT:	T5			;X POSITION IN T5
	T6			;Y POSITION IN T6

CARCOL:	T7			;FOREGROUND AND BACKGROUND COLOR


;	I = ICHRAT( XP, YP )	RETURNS CHAR AT XP,YP

	ENTRY	ICHRAT
ICHRAT:	CALL	CURSOR		;IF WE OUTPUT A CHAR, MAKE AT XP YP
	MOVE	T1,CURDIS	;GET SCREEN COORDINATE
	CALL	GETBPT		;GET BYTE POINTER INTO IT
	LDB	TEMP,TEMP	;GET CHAR AT IT, LEAVE IN AC 0
	ANDI	TEMP,0177	;ONLY WANT THE CHARACTER
	RETURN

;	I = IBPTR(0)		;GET BYTE POINTER INDEX FOR DEBUG
	ENTRY	IBPTR
IBPTR:	MOVE	T1,CURDIS
	CALL	GETBPT
	RETURN

;	CALL DEFSCR( SCREEN, ARRAY )	DEFINE ARRAY FOR SCREEN

	ENTRY	DEFSCR
DEFSCR:	SETOM	ERRFLG		;ASSUME AN ERROR
	SKIPL	T1,@0(ARG)	;IF VALUE IS OUT
	CAILE	T1,20		;OF RANGE
	RETURN			;RETURN WITH ERROR
	SKIPE	DISADR(T1)	;IF SCREEN ALREADY DEFINED
	RETURN			;RETURN WITH ERROR
	SETZM	ERRFLG		;ELSE, NO ERROR
	MOVEI	TEMP,1		;SET CURRENT CURSOR POSITION TO 1,1
	MOVEM	TEMP,XPOS(T1)
	MOVEM	TEMP,YPOS(T1)
	MOVEI	TEMP,@1(ARG)	;GET ADDRESS OF ARRAY
	MOVEM	TEMP,DISADR(T1)	;REMEMBER IT
	SAVE	CURDIS		;SAVE CURDIS, CHANGE TO CLEAR SCREEN
	MOVEM	T1,CURDIS	;CHANGE CURDIS TO THIS SCREEN
	CALL	CLRSCR		;SO WE CAN CLEAR THE SCREEN
	RESTORE	CURDIS		;NOW GET CURDIS BACK
	RETURN


;	CALL DEFADR( SCREEN, ADDRES )

	ENTRY	DEFADR
DEFADR:	SETOM	ERRFLG		;ASSUME AN ERROR
	SKIPL	T1,@0(ARG)	;IF VALUE IS OUT
	CAILE	T1,20		;OF RANGE
	RETURN			;RETURN WITH ERROR
	SETZM	ERRFLG		;ELSE, NO ERROR
	MOVEI	TEMP,1		;SET CURRENT CURSOR POSITION TO 1,1
	MOVEM	TEMP,XPOS(T1)
	MOVEM	TEMP,YPOS(T1)
	MOVE	TEMP,@1(ARG)	;GET ADDRESS OF ARRAY
	MOVEM	TEMP,DISADR(T1)	;REMEMBER IT
	RETURN


;	CALL GRAFON

	ENTRY	GRAFON
GRAFON:	SETOM	GRFMOD		;TURN ON WIERD TTY CHARACTERISTICS
	MOVEI	T1,SETAPE	;GET TTY CHAR BLOCKS
	MOVEI	T2,^D9		;9 THINGS TO SET
	GOTO	ISET		;GO SET THEM


;	CALL GRAFOF

	ENTRY	GRAFOF
GRAFOF:	SETZM	GRFMOD		;TURNING OFF FUNNY TTY CHAR'S
	MOVEI	T1,RESTTY	;GET RESET TTY'S BLOCK
	MOVEI	T2,3		;AND ITS LENGTH
	GOTO	ISET		;GO SET THEM


DCHAR:	SETZM	ERRFLG		;LOCAL ROUTINE, OUTPUTS CHAR
	SAVE	TEMP		;WILL USE TEMP
	SAVE	T1		;AND T1
	SAVE	T5		;AND T5
	MOVE	T1,CURDIS	;GET CURRENT DISPLAY
	JUMPE	T1,NOTDIS	;IF NOT A DISPLAY, GO PRINT IT
	CAIN	CHAR,7		;IF BELL
	GOTO	NOTDIS		;THEN RING IT ANYWAY
	CAIE	CHAR,15		;IF CARRIAGE RETURN
	GOTO	DCNTCR
	MOVEI	TEMP,1		;RESET COORDINATES
	MOVEM	TEMP,XPOS(T1)
	GOTO	ENDCAR
DCNTCR:	CAIE	CHAR,12		;IF LINE FEED
	GOTO	DCNTLF
	SOSG	YPOS(T1)	;CHANGE Y
	AOS	YPOS(T1)	;BUT MAKING SURE IT DOESN'T LEAVE GRID
	GOTO	ENDCAR
DCNTLF:	CALL	GETBPT		;NOT LINE FEED, GET PLACE TO PUT CHAR
	AOS	XPOS(T1)	;INCREMENT X POSITION OR
	MOVE	T5,XPOS(T1)	;IF WE EXCEED LIMIT
	CAIG	T5,%SCRWID	;OF SCREEN, RESET IT
	GOTO	NPOL		;IT ACTS LIKE A <CRLF>
	MOVEI	T5,1
	MOVEM	T5,XPOS(T1)
	SOSG	YPOS(T1)
	AOS	YPOS(T1)
NPOL:	SAVE	T2
	SAVE	T3
	MOVE	T2,CHAR		;IN ANY CASE, GET CHAR
	CAIGE	T2," "		;IF ITS A CONTROL CHAR
	MOVEI	T2," "		;MAKE IT A SPACE
	MOVE	T3,DISFG(T1)	;GET FOREGROUND COLOR
	SUBI	T3,1		;STORED -1 TO TAKE FEWER BITS
	LSH	T3,^D11		;PUT IT IN POSITION
	IOR	T2,T3
	MOVE	T3,DISBG(T1)	;GET BACKGROUND COLOR
	SUBI	T3,1		;STORED -1 TO TAKE FEWER BITS
	LSH	T3,^D8		;PUT IT IN POSITION
	IOR	T2,T3
	DPB	T2,TEMP		;AND PUT IT IN THE ARRAY
	RESTORE	T3
	RESTORE	T2
	GOTO	ENDCAR

DCRNOW:	SAVE	TEMP		;DUMP TO OUTPUT DEVICE
	SAVE	T1
	SAVE	T5
NOTDIS:	MOVE	TEMP,CHAN	;GET CHANNEL DESTINATION
	JUMPG	TEMP,NORMIO	;IF POSITIVE, GIVE IT TO I/O
	MOVEI	T1,6		;ELSE GET APROPRIATE TRMOP ARGUMENT
	SKIPE	TEMP		;6 FOR OUTPUT
	MOVEI	T1,21		;21 FOR INPUT BUFFER
	MOVEM	T1,TRMCOD	;AND STORE THEM AWAY IN TRMOP BLOCK
	MOVEM	CHAR,TRMARG	;STORE CHARACTER AWAY
	JUMPE	TEMP,TRMOUT	;IF OUTPUTTING, GO DUMP IT
	SETZM	TRMARG		;ELSE, SHOULD BE A POINTER
	MOVE	TEMP,CHAR	;TO CHARACTER (IN TEMP)
	LSH	TEMP,^D29	;CONVERT IT TO ASCIZ
TRMOUT:	MOVE	T1,TTYNUM	;AND PREPARE TO DUMP IT
	JUMPGE	T1,ALLSET	;TTYNUM IS KNOWN, GO DUMP IT
	TRMNO.	T1,		;ELSE GET IT
	HALT			;SHOULD CERTAINLY NOT HAPPEN
	SKIPA			;NO POINT IN ADDING UDX
ALLSET:	ADDI	T1,.UXTRM	;ADD IN UDX FOR TRMOP
	MOVEM	T1,TRMUDX	;STICK THAT IN TRMOP BLOCK
	MOVE	T1,[XWD 3,TRMCOD]	;GET BLOCK POINTERS
	TRMOP.	T1,		;FINALLY, DUMP THAT CHARACTER
	SETOM	ERRFLG		;IF ERROR, SAY SO
ENDCAR:	RESTORE	T5		;AND RESTORE THOSE REGISTERS
	RESTORE	T1
	RESTORE	TEMP
	RETURN


NORMIO:	SAVE	ARG		;ON NORMAL FILE IO, WE WILL NEED ARG
	MOVEI	ARG,ARGPTR	;SET UP FOR CALL TO FILPUT
	CALL	FILPUT		;DUMP THAT CHARACTER
	RESTORE	ARG		;AND GET BACK ARG
	RESTORE	T5
	RESTORE	T1
	RESTORE	TEMP
	RETURN

ARGPTR:	CHAN			;CHANNEL TO DUMP TO
	CHAR			;CHARACTER TO DUMP

GETBPT:	MOVE	TEMP,YPOS(T1)	;ROUTINE RETURNS B-PTR TO X-Y
	SUBI	TEMP,1		;BEGIN ARRAY CALCULATIONS
	IMULI	TEMP,%SCRWID
	ADD	TEMP,XPOS(T1)
	SUBI	TEMP,1
	IDIVI	TEMP,%CRSPWD	;TO GET WORD IN TEMP, BYTE IN T1
	IMULI	T1,%BITSPW	;BYTES ARE %BITSPW BITS LONG
	SUBI	T1,%WSIZE-%BITSPW	;STARTING ON LEFT OF WORD
	MOVN	T1,T1		;WANT IT POSITIVE FOR LDB OR DPB
	LSH	T1,^D30		;CONSTRUCT B-PTR
	TLO	T1,%BPSIZE	;AND ADD FLAG THAT ITS EIGHTEEN BITS
	IOR	TEMP,T1		;WORD WITH POINTER MAKES B-PTR
	MOVE	T1,CURDIS	;GET DISPLAY NUMBER BACK
	ADD	TEMP,DISADR(T1)	;AND ADD IN ARRAY START TO B-PTR
	RETURN

ISET:	MOVNI	TEMP,1		;GET TERMINAL UDX
	TRMNO.	TEMP,		;FROM SYSTEM
	HALT			;ERROR RETURN
	MOVEM	TEMP,TTYADR+1	;STICK UDX IN TRMOP BLOCK
	MOVE	T3,[XWD 3,TTYADR]	;SET UP FOR TRMOP.
ITTYLP:	MOVE	TEMP,(T1)	;THIS ROUTINE SETS TTY CHAR'S
	ADDI	T1,1		;GET CHAR TO SET, INCREMENT NUMBER
	HLRZM	TEMP,TTYADR	;PUT FUNCTION IN TTYADR
	HRRZM	TEMP,TTYADR+2	;AND VALUE IN TTYADR + 2
	TRMOP.	T3,		;SET THAT CHARACTERISTIC
	HALT			;ERROR RETURN
	SOJG	T2,ITTYLP	;GO BACK FOR MORE.
	RETURN

SETAPE:	2002,,1			;TAPE MODE
	2007,,1			;NO ECHO
	2021,,0			;NO PAGE
	2006,,1			;FORMS
	2025,,0			;BLANK
	2005,,0			;NOTABS
	2010,,1			;NOCRLF
	2035,,0			;NO AUTO CR
	2036,,0			;NO RT

RESTTY:	2002,,0
	2007,,0
	2021,,1

IFE %HISEG,	<RELOC>		;LOW
TTYADR:	BLOCK	3
IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	TITLE	INPUT				;PAGE 9
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>

;	L = LTRUE( 0 )		;TRUE IF CARRIAGE RETURN IN INP BUFFER

	ENTRY	LSKIP
LSKIP:	SETO	TEMP,		;DEFAULT SAYS THERE IS
	SKPINL			;ASK MONITOR
	SETZ	TEMP,		;ERROR RETURN, GUESS NOT
	RETURN


;	L = CSKIP( 0 )		;TRUE IF CHAR IN INPUT BUFFER

	ENTRY	CSKIP
CSKIP:	SETO	TEMP,		;DEFAULT SAYS THERE IS ONE
	SKPINC			;FIND OUT FROM MONITOR
	SETZ	TEMP,		;GUESS NOT
	RETURN

;	CALL CHRBUF( INCHAR )	GET A CHAR FROM THE INPUT BUFFER

	ENTRY	CHRBUF
CHRBUF:	INCHRS	@0(ARG)		;ASK MONITOR FOR CHARACTER
	SETOM	@0(ARG)		;RETURN NEGATIVE ONE IF NONE
	RETURN

;	CALL CHRWAT( INCHAR )	GET A CHAR, WAIT IF NOT PRESENT

	ENTRY	CHRWAT
CHRWAT:	INCHRW	@0(ARG)		;GET CHAR FROM SYSTEM
	RETURN

;	CALL GETNUM( [ STRING, ] ILEN, NUM1,IBASE1, NUM2,IBASE2, . . .)
;				GET A NUMBER FROM STRING (ILEN LONG)
;				READ IN BASE IBASE AND PUT IT IN NUM

	ENTRY	GETNUM
GETNUM:	MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGUMENTS
	HLRZ	TEMP,TEMP	;IN RIGHT HALF
	SOS	TEMP		;RETRIEVE (N-1)/2 ARGUMENTS
	IDIVI	TEMP,2		;TO ACOUNT FOR NUM,BASE
	AOS	T1		;IF GETTING STRING
	MOVE	T3,ARG		;GET POINTER INTO ARGUMENTS
	ADD	T3,T1		;PLUS 2 IF FROM ARRAY, ELSE PLUS 1
	MOVEI	T2,@0(ARG)	;GET ADDRESS OF STRING IF STRING
	MOVE	T5,T2		;T5 WILL CONTAIN STOPPING PLACE
	ADD	T5,@1(ARG)	;ADD IN NUMBER TO FIND STOPPING PLACE
	SOJN	T1,NOTTRM	;IF T1-1=0 THEN STRING, NOT TTY
	SAVE	TEMP		;ELSE SET UP TO CALL GETSTR
	SAVE	T3
	SAVE	ARG
	MOVEI	ARG,ARGBLK	;GET ARGUMENT BLOCK
	CALL	GETSTR		;GET THAT STRING
	RESTORE	ARG
	RESTORE	T3
	RESTORE	TEMP
	MOVEI	T2,SLIST	;ARRAY NOW FROM SLIST
	MOVE	T5,T2		;NO RECALCULATE ENDING LOCATION
	ADD	T5,@0(ARG)	;BY ADDING IN ENDING PLACE

NOTTRM:	SETZ	T4,		;ZERO OUT NUMBER TO START
	MOVE	T12,0(T3)	;GET POINTER TO WORD
	LSH	T12,12		;SHIFT SO REAL WILL MAKE IT NEGATIVE
	SKIPGE	T10,@1(T3)	;GET BASE
	MOVN	T10,T10		;MAKE IT POSITIVE

LOOP1:	MOVE	T1,(T2)		;GET A CHARACTER
	JUMPE	T1,CLRARG	;IF NULL, GET OUT
	AOS	T2		;ELSE, INC CHAR POSITION
	CALL	MAKUCR		;MAKE IT UPPERCASE RIGHT JUSTIFIED
	CAIN	T1,"-"		;IF ITS A NEGATIVE
	GOTO	NEGAT		;GO HANDLE IT
	JUMPGE	T12,NOTFR1	;IF NOT REAL, AVOID THIS
	CAIN	T1,"."		;IS IT A DECIMAL POINT
	GOTO	FRACT		;THEN THIS IS FRACTION PART
NOTFR1:	CALL	MAKNUM		;IN ANY CASE, FIND WHAT DIGIT IT WAS
	SKIPE	BADCHR		;WAS IT A DIGIT
	GOTO	LOOP1		;NOPE, GO GET ANOTHER CHARACTER
	SETZM	NEGFLG		;YES, NO NEGATIVE SO CLEAR FLAG
	GOTO	MDLOOP		;GO GET THAT NUMBER

NEGAT:	SETOM	NEGFLG		;IT WAS NEGATIVE, SET FLAG
LOOP2:	SKIPE	T1,(T2)		;GET THE NEXT CHARACTER
	AOS	T2		;INCREMENT CHAR PTR IF NOT NULL
	CALL	MAKUCR		;MAKE IT UPPER CASE RIGHT JUSTIFIED
	JUMPGE	T12,NOTFR2	;IF NOT REAL NUMBER, AVOID
	CAIN	T1,"."		;ELSE IT MIGHT BE A DECIMAL POINT
	GOTO	FRACT		;IF SO, GET THE FRACTION
NOTFR2:	CALL	MAKNUM		;CONVERT THIS CHARACTER TO A DIGIT
	SKIPE	BADCHR 		;OR IF YOU CAN'T
	GOTO	EXLOOP		;DUMP THIS NUMBER, HEAD FOR NEXT
MDLOOP:	IMUL	T4,@1(T3) 	;ELSE, MULTIPLY IT BY ITS BASE
	ADD	T4,T1		;ADD IN THE DIGIT
	GOTO	LOOP2		;AND GO FOR ANOTHER DIGIT

FRACT:	FLTR	T6,@1(T3)	;FRACTION: PREPARE LEFT DIGITS
	MOVE	T7,T6		;SET UP POWER TO DIVIDE BY
	FLTR	T4,T4		;AND FLOAT NUMBER
	SETZ	T12,		;NUMBER IS ALREADY FLOATED, DON'T TELL
				;EXLOOP TO.  (VS. REAL NUM WITHOUT .)
FLOOP:	SKIPE	T1,(T2)		;GET NEXT CHARACTER
	AOS	T2		;INCREMENT CHAR PTR IF NOT NULL
	CALL	MAKUCR		;MAKE IT UPPERCASE RIGHT JUSTIFIED
	CALL	MAKNUM		;MAKE IT A DIGIT
	SKIPE	BADCHR		;OR IF IT ISN'T ONE
	GOTO	EXLOOP		;GET OUT OF THIS LOOP
	FLTR	T1,T1		;MAKE DIGIT REAL
	FDV	T1,T7		;DIVIDE BY WHATEVER POWER WE ARE AT
	FAD	T4,T1		;ADD INTO NUMBER
	FMP	T7,T6		;RAISE POWER BY ONE
	GOTO	FLOOP		;AND GET ANOTHER CHARACTER

EXLOOP:	SKIPGE	T12		;DO WE NEED TO MAKE IT REAL
	FLTR	T4,T4		;YES
	MOVEM	T4,@0(T3)	;PUT RESULT BACK IN ARGS
	SKIPE	NEGFLG		;IF IT WAS NEGATIVE
	MOVNM	T4,@0(T3)	;PUT BACK AS NEGATIVE
	SETZ	T4,		;PREPARE FOR A NEW NUMBER
	SOSG	TEMP		;IF NO NEW NUMBERS TO GET
	RETURN			;LEAVE
	ADDI	T3,2		;ELSE, INCREMENT ARG POINTER
	MOVE	T12,0(T3)	;ELSE GET NEXT POINTER TO WORD
	LSH	T12,12		;SHIFT SO REAL BIT IS SIGN BIT
	SKIPGE	T10,@1(T3)	;GET BASE
	MOVN	T10,T10		;MAKE IT POSITIVE
	GOTO	LOOP1		;AND GO GET ANOTHER NUMBER


CLRARG:	SETZM	@0(T3)		;ZERO OUT THIS ARG
	ADDI	T3,2		;INCREMENT ARG POINTER
	SOJG	TEMP,CLRARG	;IF MORE ARGS, GO CLEAR THEM
	RETURN

MAKNUM:	SETZM	BADCHR		;BY DEFAULT IT IS A GOOD CHAR
	CAMLE	T2,T5		;UNLESS IT IS OUTIDE OF ARRAY
	GOTO	BAD		;IN WHICH CASE IT IS BAD
	SUBI	T1,"0"		;MAKE IT A DIGIT
	JUMPL	T1,BAD		;IF < 0, THEN NOT DIGIT
	CAIGE	T1,^D10		;IF < 10
	GOTO	GOOD		;THEN WE NEEDN'T DO MORE CONVERTING
	SUBI	T1,7		;ELSE, ACCOUNT FOR ALPHANUMERICS
	CAIL	T1,^D10		;IT BETTER NOT BE IN BETWEEN
GOOD:	CAML	T1,T10		;AND IT HAD BETTER BE LESS THAN BASE
BAD:	SETOM	BADCHR		;ELSE IT IS BAD
	RETURN

MAKUCR:	TLNE	T1,-1		;IF ITS A1 FORMATTED
	LSH	T1,^D-29	;MAKE IT R FORMATTED
	CAIGE	T1,^D97		;IS IT LESS THAN LOWERCASE A
	RETURN			;IF SO, EXIT
	CAILE	T1,^D122	;IS IT GREATER THAN LOWERCASE Z
	RETURN			;IF SO, EXIT
	SUBI	T1,40		;ELSE MAKE IT UPPERCASE
	RETURN			;AND RETURN

	-3,,0			;ARG BLOCK FOR GETSTR
ARGBLK:	SLIST			;LOCATION OF ARRAY
	MAXNUM			;LOCATION OF MAXNUM
	NUMINL			;LOCATION OF NUMINL

IFE %HISEG,	<RELOC>		;LOW
SLIST:	BLOCK	^D132		;ARRAY LOCATION
MAXNUM:	^D132			;MAXIMUM NUMBER OF CHARACTERS
NUMINL:	0			;ACTUAL NUMBER OF CHARACTERS

BADCHR:	0			;BAD CHARACTER FLAG
NEGFLG:	0			;NEGATIVE FLAG
IFE %HISEG,	<RELOC>		;HIGH

;	CALL GETSTR( STRING, MAXLEN, LENGTH [, CHAN, LEOF ])
;				GET A STRING FROM THE TERMINAL AND
;				RETURN THE LENGTH (SET MAXIMUM LENGTH
;				WITH MAXLEN)

	EXTERN	FILGET

	ENTRY	GETSTR
GETSTR:	MOVN	T4,-1(ARG)	;GET NUMBER OR ARGS
	HLRZ	T4,T4		;IN RIGHT HALF
	MOVEI	T3,@0(ARG)	;GET ADDRESS OF ARRAY
	SETZ	T2,		;NO CHAR READ YET

LOOP3:	CAIE	T4,3		;IF THERE ARE MORE THAN 3 ARGS
	GOTO	GETCHR		;READING FROM FILE.  GO GET CHAR
	INCHRW	TEMP		;ELSE, GET CHAR WITH TTCALLS.
	CAIN	TEMP,177	;RUB-OUT
	GOTO	RUBOUT
	CAIN	TEMP,10		;BACKSPACE
	GOTO	BKSPAC
	CAIN	TEMP,27		;CONTROL-W
	GOTO	WRDBAK
	CAIN	TEMP,22		;CONTROL-R
	GOTO	READBK
	CAIN	TEMP,25		;CONTROL-U
	GOTO	READAG
	CAIE	TEMP,12		;LINE FEED
	CAIN	TEMP,13		;VERTICAL TAB
	GOTO	PCR
	CAIE	TEMP,7		;BELL
	CAIN	TEMP,33		;ESCAPE
	GOTO	PCRLF
	CAIN	TEMP,14		;FORM FEED
	GOTO	EOL
	CAIE	TEMP,15		;CARRIAGE RETURN
	GOTO	NOTCHR
	INCHRS	0		;GRAB EXTRA <LF>
	OUTCHR	LINFED
	GOTO	EOL

NOTCHR:	CAML	T2,@1(ARG)	;HAVE WE EXCEEDED WHAT WE CAN READ
	GOTO	LSTCHR		;YUP, GO FINISH UP
	AOS	T2		;INCREMENT NUMBER OF CHAR
	MOVE	T1,[ASCIZ/    /]	;NORMAL CHAR, ADD IN
	LSHC	TEMP,^D29	;TRAILING SPACES FOR A1 FORMAT
	MOVEM	TEMP,(T3)	;PUT IN ARRAY
	AOJA	T3,LOOP3	;INCREMENT ARRAY PTR, GET ANOTHER

LSTCHR:	MOVEM	T2,@2(ARG)	;STUFF NUMBER CHARS READ BACK IN ARG
	RETURN

RUBOUT:	OUTCHR	BAKSPC		;DELETE CHARACTER FROM SCREEN
BKSPAC:	OUTCHR	[ " " ]
	OUTCHR	BAKSPC
	SOS	T3		;DECREMENT ARRAY POINTER
	SOJG	T2,LOOP3	;CHAR'S READ AND GET ANOTHER
	SETZ	T2,		;OOPS, NO CHAR'S TO RUBOUT
	MOVEI	T3,@0(ARG)	;RESET TO BEGINNING OF LINE
	GOTO	LOOP3		;AND TRY AGAIN

WRDBAK:	OUTSTR	BACKUP		;ERASE THE W
WHTLOP:	OUTSTR	BACKUP		;ERASE THE LAST CHAR
	JUMPLE	T2,LOOP3	;ANYTHING TO ERASE?  IF NOT, EXIT LOOP
	MOVE	TEMP,-1(T3)	;GET FIRST CHAR TO ERASE
	LSH	TEMP,^D-29	;MAKE IT R FORMATTED
	CAILE	TEMP," "	;IF IT IS NOT WHITE SPACE
	GOTO	EXWTLP		;EXIT WHITE SPACE LOOP
	SOS	T2		;DECREMENT COUNTER
	SOJA	T3,WHTLOP	;AND LOOP

EXWTLP:	OUTSTR	BACKUP		;ERASE LAST CHARACTER
	MOVE	TEMP,-1(T3)	;GET THE CHARACTER
	SOS	T3		;DECREMENT ADDRESS POINTER
	SOS	T2		;AND NUMBER OF CHARS
	LSH	TEMP,^D-29	;MAKE IT R FORMATTED
	CALL	WRDCHR		;CHECK IF IT IS WORD CHARACTER
	GOTO	LOOP3		;IF IT IS NOT, GO BACK INTO INPUT

WRDLOP:	JUMPLE	T2,LOOP3	;IF NO CHAR'S EXIT LOOP
	MOVE	TEMP,-1(T3)	;GET THE CHARACTER
	LSH	TEMP,^D-29	;MAKE IT R FORMATTED
	CALL	WRDCHR		;CHECK IF IT IS WORD CHARACTER
	GOTO	LOOP3		;NO, GO BACK INTO INPUT
	OUTSTR	BACKUP		;ERASE THE CHARACTER
	SOS	T2		;DECREMENT CHAR COUNT
	SOJA	T3,WRDLOP	;AND LOOP

WRDCHR:	CAIL	TEMP,"A"	;IS ON LOWER SIDE OF A-Z RANGE
	CAILE	TEMP,"Z"	;OF ON GREATER SIDE OF A-Z RANGE
	SKIPA			;IF SO, SKIP
	GOTO	DELNCR		;IF IN RANGE, LOOP
	CAIL	TEMP,"0"	;IS ON LOWER SIDE OF 0-9 RANGE
	CAILE	TEMP,"9"	;IS ON GREATER SIDE OF 0-9 RANGE
	SKIPA			;IF SO, SKIP
	GOTO	DELNCR		;IF IN RANGE, LOOP
	CAIL	TEMP,^D97	;IS ON LOWER SIDE OF LOWER A-Z RANGE
	CAILE	TEMP,^D122	;IS ON GREATER SIDE OF LOWER A-Z RANGE
	RETURN			;ALL FAILED, MUST BE PUNCTUATION
DELNCR:	AOS	(STACK)		;INCREMENT RETURN LOCATION
	RETURN			;AND RETURN TO CALLER

READBK:	MOVEI	T3,@0(ARG)	;GO TO NEXT LINE AND PRINT WHAT WE HAVE
	OUTSTR	BACKUP		;GET RID OF ^R ECHO
	OUTSTR	BACKUP
	OUTSTR	OCRLF
	MOVE	T1,T2		;PREPARE TO LOOP, PRINTING CHAR'S
LOOP4:	SOJL	T1,LOOP3
	MOVE	TEMP,(T3)	;GET CHAR TO PRINT
	AOS	T3		;INCREMENT ARRAY POINTER
	LSH	TEMP,^D-29	;CONVERT CHAR TO R1 FORMAT
	OUTCHR	TEMP		;DUMP IT OUT
	GOTO	LOOP4		;AND GO GET ANOTHER

READAG:	MOVEI	T3,@0(ARG)	;TYPED ^U, KILL LINE SO FAR
	SETZ	T2,		;NO CHARACTERS
	OUTSTR	OCRLF		;GO TO NEXT LINE
	GOTO	LOOP3		;AND GO BACK FOR MORE

PCRLF:	OUTCHR	LINFED		;WE NEED TO PRINT BOTH <CR> AND <LF>

PCR:	OUTCHR	CARTRN		;JUST <CR>

EOL:	MOVEM	T2,@2(ARG)	;END OF LINE, STORE NUMBER CHAR
	MOVE	TEMP,@1(ARG)	;WHAT WAS IT SUPPOSED TO BE?
	SUB	TEMP,T2		;GET DIFFERENCE
	SKIPN	TEMP		;AND IF IT IS NOT ZERO
	RETURN
	MOVE	T2,[ASCIZ/     /]	;FILL IN REST WITH SPACES

LOOP5:	MOVEM	T2,(T3)		;PLACE SPACES IN ARRAY
	AOS	T3		;INCREMENT ARRAY POINTER
	SOJG	TEMP,LOOP5	;AND GO BACK FOR MORE
	RETURN

GETCHR:	SETZM	@4(ARG)		;READING FROM A FILE, EOF NOT TRUE
	MOVE	TEMP,@3(ARG)	;GET CHANNEL
	MOVEM	TEMP,CHAN	;STORE IT AWAY IN ARG BLOCK
	SAVE	T1		;PREPARE TO CALL FILGET
	SAVE	ARG
	MOVEI	ARG,ARBLOK
	CALL	FILGET		;GET THE CHARACTER
	RESTORE	ARG
	RESTORE	T1
	SKIPE	EOF		;IF END OF FILE
	SETOM	@4(ARG)		;FLAG IT
	SKIPE	EOF
	GOTO	EOL		;AND TREAT IT LIKE A CARRIAGE RETURN
	CAIN	TEMP,15		;IF THIS IS A CARRIAGE RETURN
	GOTO	GETCHR		;GO BACK AND GET THE LINE FEED
	CAIN	TEMP,12		;IF IT IS A LINE FEED
	GOTO	EOL		;WE ARE DONE
	GOTO	NOTCHR		;ELSE, GO STICK IT IN THE ARRAY

ARBLOK:	CHAN			;ARG BLOCK FOR CALL TO FILGET
	TEMP			;RESULT LEFT IN AC 0
	EOF			;WILL BE TRUE IF NOTHING IN FILE

BAKSPC:	10			;CHAR TO BACKUP ON MOST TTY'S
LINFED:	12			;GO DOWN ONE LINE
CARTRN:	15			;GO TO BEGINNING OF LINE
BACKUP:	BYTE(7) 10,40,10,0	;STRING GETS RID OF ONE CHARACTER
OCRLF:	BYTE(7) 15,12,0		;<CRLF>

IFE %HISEG,	<RELOC>		;LOW
CHAN:	0			;CHANNEL TO READ FROM
EOF:	0			;TRUE IF END OF FILE
IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	TITLE	STROPR				;PAGE 10
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>

;	I = ISERCH( ARRAY, IWORD, ISTOP )	SEARCH FOR IWORD

	ENTRY	ISERCH
ISERCH:	SAVE	T2		;BECAUSE THIS IS A FUNCTION
	MOVEI	T1,@0(ARG)	;GET ADDRESS OF ARRAY
	MOVE	TEMP,@2(ARG)	;GET WHERE TO STOP
ILOOP1:	MOVE	T2,0(T1)	;GET CHARACTER
	ADDI	T1,1		;INCREMENT ARRAY POINTER
	CAME	T2,@1(ARG)	;IF CHAR'S NOT EQUAL
	SOJG	TEMP,ILOOP1	;LOOP AGAIN
	JUMPE	TEMP,ESRCH1	;DIDN'T FIND IT, LEAVE
	SUB	TEMP,@2(ARG)	;ELSE, CALCULATE WHERE WE FOUND IT
	MOVN	TEMP,TEMP	;RETURN POSITIVE VALUE
	ADDI	TEMP,1		;ARRAYS START AT 1, NOT ZERO
ESRCH1:	RESTORE	T2
	RETURN


;	I = NSERCH( ARRAY, IWORD, ISTOP )	SEARCH FOR NON IWORD

	ENTRY	NSERCH
NSERCH:	SAVE	T2		;BECAUSE THIS IS A FUNCTION
	MOVEI	T1,@0(ARG)	;GET ADDRESS OF ARRAY
	MOVE	TEMP,@2(ARG)	;GET WHERE TO STOP
ILOOP2:	MOVE	T2,0(T1)	;GET CHARACTER
	ADDI	T1,1		;INCREMENT ARRAY POINTER
	CAMN	T2,@1(ARG)	;IF CHAR'S EQUAL
	SOJG	TEMP,ILOOP2	;LOOP AGAIN
	JUMPE	TEMP,ESRCH2	;DIDN'T FIND IT, LEAVE
	SUB	TEMP,@2(ARG)	;ELSE, CALCULATE WHERE WE FOUND IT
	MOVN	TEMP,TEMP	;RETURN POSITIVE VALUE
	ADDI	TEMP,1		;ARRAYS START AT 1, NOT ZERO
ESRCH2:	RESTORE	T2
	RETURN


;	I = ISLAST( ARRAY, IWORD, ILEN )	FIND LAST OCCURANCE

	ENTRY	ISLAST
ISLAST:	SAVE	T2		;BECAUSE THIS IS A FUNCTION
	MOVEI	T2,@0(ARG)	;GET ADDRESS OF FIRST ARRAY
	ADD	T2,@2(ARG)	;START AT END
	SUBI	T2,1		;FORTRAN STARTS ARRAYS WITH 1 VS 0
	MOVE	TEMP,@2(ARG)	;GET INDEX
NSLOP1:	MOVE	T1,0(T2)	;GET VALUE TO CHECK
	CAMN	T1,@1(ARG)	;ARE THEY EQUAL?
	GOTO	ENS1		;IF SO, EXIT
	SUBI	T2,1		;ELSE DECREMENT ADDRESS
	SOJG	TEMP,NSLOP1	;DECREMENT INDEX AND LOOP
ENS1:	RESTORE	T2		;RESTORE THE REGISTER
	RETURN			;AND LEAVE


;	I = NSLAST( ARRAY, IWORD, ILEN )	FIND LAST NON OCCURANCE

	ENTRY	NSLAST
NSLAST:	SAVE	T2		;BECAUSE THIS IS A FUNCTION
	MOVEI	T2,@0(ARG)	;GET ADDRESS OF FIRST ARRAY
	ADD	T2,@2(ARG)	;START AT END
	SUBI	T2,1		;FORTRAN STARTS ARRAYS WITH 1 VS 0
	MOVE	TEMP,@2(ARG)	;GET INDEX
NSLOP2:	MOVE	T1,0(T2)	;GET VALUE TO CHECK
	CAME	T1,@1(ARG)	;ARE THEY EQUAL?
	GOTO	ENS2		;IF SO, EXIT
	SUBI	T2,1		;ELSE DECREMENT ADDRESS
	SOJG	TEMP,NSLOP2	;DECREMENT INDEX AND LOOP
ENS2:	RESTORE	T2		;RESTORE THE REGISTER
	RETURN			;AND LEAVE


;	I = ISRSIX( ARRAY, IWORD, ISTOP )	RETURN INDEX OF
;				;SIXBIT WORD THE MATCHES ABBREVIATION
;				;IWORD.  IF NOT FOUND, ZERO, IF AMBIG
;				;RETURN NEGATIVE INDEX OF FIRST OCCUR.

	ENTRY	ISRSIX
ISRSIX:	SAVE	T2		;BECAUSE THIS IS A FUNCTION
	SAVE	T3		;SAVE VALUES, BECAUSE FORTRAN
	SAVE	T4		;USES THEM
	SAVE	T5
	SAVE	T6
	SAVE	T7
	SETZB	TEMP,T7		;WE HAVEN'T FOUND ANY MATCH YET
	MOVEI	T1,@0(ARG)	;GET ADDRESS OF ARRAY
	SETZ	T2,		;INDEX (NOT PTR) INTO ARRAY
ALOOP:	ADDI	T2,1		;INCREMENT INDEX
	MOVE	T3,0(T1)	;GET WORD
	CAMN	T3,@1(ARG)	;IF ITS A PERFECT MATCH
	GOTO	PRFMAT		;LEAVE HAPPILY
	HRLI	T3,440600	;ELSE, SET UP FOR GRABBING 6-BITS
	MOVEI	T4,6		;SIX 6-BITS IN WORD
LETLOP:	HRRI	T3,@1(ARG)	;SET UP BYTE POINTER TO MATCHEE
	ILDB	T5,T3		;GET THAT BYTE
	JUMPE	T5,MATCH	;IF NULL END OF WORD, FOUND MATCH
	HRRI	T3,0(T1)	;ELSE, GET POINTING INTO ARRAY
	LDB	T6,T3		;GET BYTE FROM ARRAY
	CAME	T5,T6		;IF THERE ARE NOT EQUAL
	GOTO	TRYNXT		;GO TO NEXT WORD
	SOJG	T4,LETLOP	;ELSE, MATCH ANOTHER LETTER
MATCH:	ADDI	T7,1		;INCREMENT NUMBER OF FINDS
	MOVE	TEMP,T2		;REMEMBER INDEX OF FIND
TRYNXT:	CAMGE	T2,@2(ARG)	;ANY MORE WORDS
	AOJA	T1,ALOOP	;YES, GO GET THEM
	SOJLE	T7,ENDIRS	;IF <= 1 THEN NOT AMBIGUOUS
	MOVN	TEMP,TEMP	;ELSE FLAG THAT IT IS
	SKIPA			;AND RETURN

PRFMAT:	MOVE	TEMP,T2		;PERFECT MATCH, RETURN INDEX

ENDIRS:	RESTORE	T7		;AND RESTORE THE WORLDS
	RESTORE	T6
	RESTORE	T5
	RESTORE	T4
	RESTORE	T3
	RESTORE	T2
	RETURN


;	I = COMPAR( ARRAY1, ARRAY2, ILEN )	COMPARE ARRAYS

	ENTRY	COMPAR
COMPAR:	SAVE	T2
	SAVE	T3
	MOVEI	T1,@0(ARG)	;GET ADDRESSES OF ARRAYS
	MOVEI	T2,@1(ARG)
	MOVE	T3,@2(ARG)	;AND LENGTH OF BOTH OF THEM

LOOP2:	MOVE	TEMP,(T1)	;GET WORD FROM FIRST ARRAY
	CAME	TEMP,(T2)	;DOES IT MATCH SECOND
	GOTO	NOTMAT		;NOPE, EXIT
	AOS	T1		;ELSE, TRY NEXT WORD
	AOS	T2
	SOJG	T3,LOOP2	;DECREMENT WORDS LEFT TO GO AND LOOP
	SETO	TEMP,		;NO MORE TO GO, RETURN TRUE
	SKIPA

NOTMAT:	SETZ	TEMP,		;FOUND ONE THAT DIDN'T MATCH, FALSE
	RESTORE	T3
	RESTORE	T2
	RETURN

;	CALL ALLCAP( ARRAY, LENGTH )

	ENTRY	ALLCAP
ALLCAP:	MOVE	TEMP,@1(ARG)	;GET LENGTH
	MOVEI	T1,@0(ARG)	;GET ARRAY'S ADDRESS
LOOP3:	MOVE	T2,(T1)		;GET WORD
	CAML	T2,[605004,,020100]	;LOWER CASE "A"
	CAMLE	T2,[751004,,020100]	;LOWER CASE "Z"
	SKIPA			;NOT IN LOWER CASE RANGE
	TLZ	T2,200000	;ELSE, TURN OFF BIT MAKING IT LOWER
	MOVEM	T2,(T1)		;AND PUT IT BACK
	AOS	T1		;INCREMENT ADDRESS
	SOJG	TEMP,LOOP3	;AND GO BACK FOR ANOTHER
	RETURN

;	CALL PARSE( ARRAY, LENGTH, SIXARA, NUMWRD, MAXWRD )
;		OR
;	CALL PARSE( ARRAY, LENGTH, SIXARA, NUMWRD, MAXWRD, PARPOS )
;				RETURN SIXBIT WORDS FROM ARRAY (A1)
;				SEPARATED BY NO ALPHABETIC CHARS.
;				OPTIONAL PARPOS CONTAINS INDEX EACH
;				TOKEN STARTS AT.

	ENTRY	PARSE
PARSE:	SETZB	T6,@3(ARG)	;ZERO TOKEN COUNTS
	MOVEI	T1,@0(ARG)	;GET ADDRESS OF ARRAY
	MOVEI	T4,@2(ARG)	;AND ADDRESS OF TOKEN ARRAY
	MOVE	T2,@1(ARG)	;GET LENGTH OF ARRAY TO PARSE
	MOVN	T7,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T7,T7		;ON RIGHT SIDE
	SUBI	T7,4		;SET UP T7 SO IF NOT 6 ARGS
	SOSLE	T7		;SUBTRACTION YIELDS ZERO
	MOVEI	T7,@5(ARG)	;ELSE, ADDRESS OF 6TH ARG

LOOP4:	CALL	NXTCHR		;GO GET A CHARACTER
	CALL	FNDWRD		;NOW PUT IT IN A WORD
	JUMPGE	T2,LOOP4	;GO BACK FOR NEXT WORD
	RETURN			;ALL DONE, LEAVE

NXTCHR:	SOSGE	T2		;DECREMENT NUMBER OF CHAR'S
	GOTO	NOTCHR		;NO MORE
	MOVE	TEMP,(T1)	;GET A CHARACTER FROM THE ARRAY
	AOS	T1		;INCREMENT ARRAY POINTER
	TLNE	TEMP,-1		;IF ITS A1 FORMAT
	LSH	TEMP,^D-29	;CONVERT IT TO R1 FORMAT
	CAIL	TEMP,141	;IF IT IS LOWER CASE
	CAILE	TEMP,172	;(BETWEEN A AND Z )
	SKIPA
	SUBI	TEMP,40		;MAKE IT UPPER CASE
	SUBI	TEMP," "	;CONVERT TO SIXBIT CODES
	JUMPLE	TEMP,NOTCHR	;IT WAS A CONTROL CHAR, BARF
	CAIGE	TEMP,'0'	;CHECK TO SEE IF IT IS A DIGIT
	GOTO	NOTALN		;LESS THAN 0, NOPE
	CAIG	TEMP,'9'	;GREATER THAN 9, MIGHT BE LETTER
	RETURN
NOTNUM:	CAIGE	TEMP,'A'	;IF IT IS BETWEEN A
	GOTO	NOTALN
	CAIG	TEMP,'Z'	;AND Z
	RETURN			;IT IS IN WORD
NOTALN:	AOS	T6		;ELSE ITS A TERMINATOR
	CAMLE	T6,@4(ARG)	;HAVE WE EXCEEDED THE NUMBER OF WORDS
	GOTO	NOTCHR		;YES, EXIT THE LOOP
	LSH	TEMP,^D30	;NOPE, MAKE IT SIXBIT
	MOVEM	TEMP,(T4)	;STICK IT IN PARSED ARRAY
	AOS	T4		;INCREMENT ARRAY POINTER
	AOS	@3(ARG)		;INCREMENT NUMBER OF WORDS PARSED
	JUMPE	T7,NOTCHR	;SHOULD WE STORE NUMBER OF INDICES
	MOVE	T10,T1		;GET ARRAY COUNTER
	SUBI	T10,@0(ARG)	;SUBTRACT ADDRESS TO GET COUNTER
	MOVEM	T10,(T7)	;STUFF INDEX INTO ARRAY
	AOS	T7		;INCREMENT ARRAY POINTER

NOTCHR:	AOS	(STACK)		;MAKE IT AN ERROR RETURN
	RETURN

FNDWRD:	AOS	T6		;INCREMENT NUMBER OF PARSED WORDS
	CAMLE	T6,@4(ARG)	;IF WE HAVE EXCEEDED OUR LIMIT
	GOTO	NOTCHR		;LEAVE THE LOOP
	SETZM	(T4)		;START THE PARSED WORD AT NULL
	HRLZI	T3,440600	;GET BYTE POINTER
	HRR	T3,T4		;ADD IN ADDRESS OF OUTPUT ARRAY
	AOS	T4		;SO NEXT WORD GOES IN NEXT SLOT
	AOS	@3(ARG)		;INCREMENT NUMBER WORDS PARSED
	MOVEI	T5,6		;GET MAX CHARS PER WORD
	JUMPE	T7,LOOP5	;IF HE DIDN'T ASK FOR INDICES, AVOID
	MOVE	T10,T1		;GET ADDRESS OF CURRENT CHAR
	SUBI	T10,@0(ARG)	;SUBTRACT ADDRESS OF ARRAY
	MOVEM	T10,(T7)	;PUT INDEX IN ARRAY
	AOS	T7		;AND INCREMENT ITS POINTER

LOOP5:	IDPB	TEMP,T3		;STICK CHARACTER INTO ARRAY
	CALL	NXTCHR		;GET NEXT CHARACTER
	SKIPA			;IF ERROR
	RETURN			;GET OUT OF THIS
	SOJG	T5,LOOP5	;ELSE, GET NEXT CHARACTER

EATWRD:	CALL	NXTCHR		;THIS SWALLOWS UP EXTRA CHARS IN WORD
	GOTO	EATWRD		;(THAT IS CHARS AFTER 6TH ONE)
	RETURN			;ERROR RETURN EXITS LOOP

;	I = IRAD50( ISIX )	CONVERTS SIXBIT TO RADIX-50

	ENTRY	IRAD50
IRAD50:	SAVE	T2
	SAVE	T3
	MOVEI	T3,6		;GET NUMBER CHAR IN A WORD
	SETZB	TEMP,T1		;WORDS START AS NULL
	MOVE	T2,@0(ARG)	;GET WORD TO SHIFT
LOOP:	LSHC	T1,6		;SHIFT OVER ONE SIXBIT CHARACTER
	CAIL	T1,'0'		;IS IT A DIGIT?
	CAILE	T1,'9'
	GOTO	NOTDIG		;NOPE
	SUBI	T1,'0'-1	;YES, MAKE TRANSFORM 0 TO 1
	GOTO	NEXT		;AVOID STUFF FOR LETTERS
NOTDIG:	CAIL	T1,'A'		;IS IT NOT IN ALPHABET
	CAILE	T1,'Z'
	GOTO	NOTALP		;NO, TRY FUNNY CHARACTERS
	SUBI	T1,'A'-13	;YES, TRANSFORM A TO AN 13
	GOTO	NEXT		;AND GRAB NEXT
NOTALP:	CAIL	T1,'$'		;IS IT ONE OF $ OR %?
	CAILE	T1,'%'
	GOTO	CHECKP		;NOPE
	ADDI	T1,2		;MAKE THESE THE LAST POSSIBLE CHAR
	GOTO	NEXT		;AND GRAB ANOTHER

CHECKP:	CAIE	T1,'.'		;IF ITS NOT A PERIOD
	GOTO	SPACE		;THEN IT MAKE IT A SPACE (0)
	MOVEI	T1,45		;GET RAD-50 CODE FOR PERIOD
NEXT:	IMULI	TEMP,50		;MULTIPLY BY APPROPRIATE BASE
	ADD	TEMP,T1		;AND ADD IN DIGIT
SPACE:	SETZ	T1,		;DON'T BOTHER WITH SPACES
	SOJG	T3,LOOP		;GO GET ANOTHER CHARACTER
	RESTORE	T3
	RESTORE	T2
	RETURN
	PRGEND
	TITLE	CONVRT				;PAGE 11
	SEARCH	PACK, UUOSYM


IFE %HISEG,	<TWOSEG 400000>

;	CALL CONVRT( INSTR, NCHAR, IBYTE1, IOSTR, IBYTE2 )
;				CONVERT THE STRING INSTR OF NCHAR WORDS
;				IN IBYTE1 FORMAT TO IOSTR IN IBYTE2
;				FORMAT.

	ENTRY	CONVRT
CONVRT:	MOVE	TEMP,@1(ARG)	;GET THE NUMBER OF CHAR'S TO CONVERT
	MOVEI	T1,@0(ARG)	;GET ADDRESS OF ARRAY TO CONVERT
	SUBI	T1,1		;SO WE CAN ADD FIRST IN LOOP
	MOVEI	T2,@3(ARG)	;GET ADDRESS OF DESTINATION ARRAY
	SUBI	T2,1		;SO WE CAN ADD FIRST IN LOOP
	MOVE	T3,@2(ARG)	;GET FORMAT FOR FIRST ARRAY
	MOVE	T4,@4(ARG)	;GET FORMAT FOR SECOND ARRAY
	SETZB	T5,T6		;ZERO OUT COUNTERS
	MOVE	T10,[ASCII/     /]	;GET SPACING TO PAD WORDS

CONVLP:	SOSGE	TEMP		;IF NO MORE CHARACTERS,
	RETURN			;THEN DONE
	SOJG	T5,INR1		;IF MORE CHAR'S IN WORD, AVOID
	MOVE	T5,T3		;RESET BYTE COUNTER
	ADDI	T1,1		;POINT TO NEXT WORD
	HRLI	T1,444400	;SET IT UP IN R1 FORMAT
	JUMPLE	T5,INR1		;IF IT WAS R1 FORMAT, DONE
	HRLI	T1,440700	;SET UP FOR PACKED ASCII
	CAIL	T5,6		;UNLESS IT IS SIXBIT
	HRLI	T1,440600	;IN WHICH CASE, SET UP BYTE POINTER

INR1:	ILDB	T7,T1		;GET BYTE
	CAIL	T3,6		;IF SIXBIT
	ADDI	T7," "		;MAKE IT ASCII
	SOJG	T6,NOTAFR	;IF MORE ROOM IN WORD, AVOID
	MOVE	T6,T4		;RESET BYTE COUNTER
	ADDI	T2,1		;GO ON TO NEXT WORD TO FILL
	SETZM	(T2)		;MAKE SURE WORD STARTS AT ZERO
	HRLI	T2,444400	;SET UP FOR PUTTING IN R1 FORMAT
	JUMPLE	T6,NOTAFR	;IF IT WAS R1 FORMAT, DONE
	HRLI	T2,440600	;SET UP FOR SIXBIT
	CAIL	T4,6		;IF NOT IN ASCII
	GOTO	NOTAFR		;DONE
	HRLI	T2,440700	;SET UP FOR ASCII
	MOVEM	T10,(T2)	;AND MAKE IT SPACES INSTEAD

NOTAFR:	CAIGE	T4,6		;IF NOT CONVERTING TO SIXBIT
	GOTO	NOTSIX		;SKIP SIXBIT LOGIC
	CAIL	T7,^D97		;IF NOT LC, SKIP
	SUBI	T7,^D32		;ELSE CONVERT TO UC
	SUBI	T7," "		;MAKE IT A SIXBIT CODE
NOTSIX:	SKIPGE	T7		;IF NOT LEGAL VALUE
	SETZ	T7,		;MAKE IT A LEGAL VALUE
	IDPB	T7,T2		;PLACE ASCII CODE OR SIXBIT IN WORD
	GOTO	CONVLP		;AND GO BACK FOR ANOTHER


;	ICHAR = ICON( ICHAR )	;MAKE R1 ICHAR A1,  OR A1 ICHAR R1

	ENTRY	ICON
ICON:	MOVE	TEMP,@0(ARG)	;GET THE CHARACTER
	TLNE	TEMP,-1		;IF ITS A1 FORMAT
	GOTO	CRTONM		;GO MAKE IT R1 FORMAT
	LSH	TEMP,^D29	;ELSE, SHIFT IT OVER
	IOR	TEMP,[1004020100]	;ADD TRAILING SPACES
	RETURN

CRTONM:	LSH	TEMP,^D-29	;RIGHT JUSTIFY IT
	RETURN

;	ISIX = ISXBIT( IVEC )	;RETURN SIXBIT OF 2 WORD A5 STRING

	ENTRY	ISXBIT
ISXBIT:	SAVE	T2
	SAVE	T3
	MOVE	T2,@0(ARG)	;GET FIRST WORD
	MOVEI	T3,5		;5 CHARS IN THIS WORD
	SETZ	TEMP,		;ZERO FUNCTION RESULT

LOOP:	SETZ	T1,		;ZERO PLACE TO TAKE SHIFT FROM T2
	LSHC	T1,7		;GET ASCII CHAR FROM T2
	CAIL	T1,141		;IF ITS LOWER CASE
	SUBI	T1," "		;MAKE IT UPPER CASE
	SUBI	T1," "		;MAKE IT SIXBIT ANYWAY
	SKIPG	T1		;IF ITS NOT LEGAL SIXBIT
	SETZ	T1,		;MAKE IT LEGAL SIXBIT
	IOR	TEMP,T1		;AND LEAVE IN FUNCTION RETURN
	LSH	TEMP,6		;SHIFT IT OVER FOR NEXT CHAR
	SOJG	T3,LOOP		;AND GO GET ANOTHER

	MOVEI	T2,@0(ARG)	;GET POINTER INTO VECTOR
	MOVE	T2,1(T2)	;GET NEXT WORD
	SETZ	T1,		;ZERO FOR SHIFT
	LSHC	T1,7		;GET THE CHARACTER
	CAIL	T1,141		;IF ITS LOWER CASE
	SUBI	T1," "		;MAKE IT UPPER CASE
	SUBI	T1," "		;MAKE IT SIXBIT
	SKIPG	T1		;IF ITS LEGAL SIXBIT, SKIP
	SETZ	T1,		;ELSE MAKE IT LEGAL SIXBIT
	IOR	TEMP,T1		;IOR INTO FUNCTION
	RESTORE	T3
	RESTORE	T2
	RETURN
	PRGEND
	TITLE	JOBCON				;PAGE 12
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

;	CALL RPROG( FILESP, INC )
;				RUN A PROGRAM WITH START INCREMENT INC

	ENTRY	RPROG
IFE %HISEG,	<RELOC>		;LOW
RPROG:	MOVE	TEMP,[XWD -1,.GTSGN]	;FIND OUT IF HE'S GOT A HISEG
	GETTAB	TEMP,		;GO ASK MONITOR
	HALT			;SHOULDN'T HAPPEN
	SETZM	GETLOC		;BY DEFAULT HE DOESN'T
	SKIPG	TEMP		;IF HE DOESN'T, DON'T BOTHER
	GOTO	NOHISG
	HRL	T1,TEMP		;ELSE, PREPARE TO FIND ITS NAME
	HRRI	T1,.GTDEV	;GET ITS DEVICE
	GETTAB	T1,
	HALT
	MOVEM	GETLOC		;REMEMBER IT
	HRL	T1,TEMP
	HRRI	T1,.GTPRG	;ITS NAME
	GETTAB	T1,
	HALT
	MOVEM	GETLOC+1	;REMEMBER IT
	HRL	T1,TEMP
	HRRI	T1,.GTPPN	;ITS ORIGINATING PPN
	GETTAB	T1,
	HALT
	MOVEM	T1,GETLOC+4	;REMEMBER IT

NOHISG:	MOVEI	T1,@0(ARG)	;GET ADDRESS OF FILEPSEC ARRAY
	MOVE	TEMP,2(T1)	;GET DEVICE
	MOVEM	TEMP,LOC	;PUT IN RUN BLOCK
	MOVE	TEMP,3(T1)	;GET FILE
	MOVEM	TEMP,LOC+1	;PUT IN RUN BLOCK
	MOVE	TEMP,4(T1)	;GET EXTENSION
	MOVEM	TEMP,LOC+2	;PUT IN RUN BLOCK
	HRL	TEMP,6(T1)	;GET P AND PN
	HRR	TEMP,7(T1)
	MOVEM	TEMP,LOC+4	;PUT IN RUN BLOCK
	HRL	TEMP,@1(ARG)	;GET RUN INCREMENT
	HRRI	TEMP,LOC
	RUN	TEMP,		;RUN THE FILE
				;UNFORTUNATELY, THE RUN UUO
				;BLOWS AWAY THE HISEGMENT
	SKIPN	GETLOC		;THUS THE FOLLOWING.  HISEG?
	RETURN			;NOPE.  RETURN TO CALLER
	MOVEI	TEMP,GETLOC	;SET UP FOR GETSEG
	GETSEG	TEMP,		;GET THAT HISEGMENT
	HALT			;CAN'T GET HISEG BACK
	RETURN

LOC:	0			;DEVICE
	0			;FILE NAME
	0			;EXTENSION
	0			;NOT USED
	0			;P,,PN
	0			;ZERO,,CORE ASSIGNMENT

GETLOC:	0			;HISEGMENT DEVICE
	0			;FILE NAME
	0			;EXTENSION
	0			;NOT USED
	0			;P,,PN
	0			;ZERO,,CORE ASSIGNMENT

IFE %HISEG,	<RELOC>		;HIGH

;	CALL NAME( IPRGNM )	CHANGE PROGRAM NAME
;				(ROUTINE: TURNS OFF .JACCT AND
;				.XONLY BITS)

	ENTRY	NAME
NAME:	MOVE	TEMP,@0(ARG)	;GET NAME TO CHANGE TO
	SETNAM	TEMP,		;CHANGE IT
	RETURN			;RETURN TO CALLER

;	CALL TSTOP		TEMPORARILY STOP PROGRAM

	ENTRY	TSTOP
TSTOP:	EXIT	T1,		;STOP, ALLOW A CONTINUE
	RETURN

;	CALL DETACH		DETACH USER

	ENTRY	DETACH
DETACH:	HRLZI	TEMP,-1		;SET UP TO DETACH THIS JOB
	ATTACH	TEMP,		;DO IT
	OUTSTR	[ASCIZ/?USP Could not detach job
/]
	RETURN

;	CALL NAP( MILSEC [, IFLAG1 + IFLAG2 + IFLAG3 . . .])
;				SLEEP FOR MILSEC MILLISECONDS
;				OR UNTIL IFLAG IS MET

	ENTRY	NAP
NAP:	MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	TEMP,TEMP	;ON RIGHT SIDE
	SOSE	TEMP		;IF WE HAVE FLAGS
	HRL	TEMP,@1(ARG)	;GET THEM
	HRR	TEMP,@0(ARG)	;GET TIME TO SLEEP FOR
	HIBER	TEMP,		;AND GO TO SLEEP
	HALT			;SHOULDN'T HAPPEN
	RETURN

;	CALL RESCAN		RESCAN INPUT BUFFER

	ENTRY	RSCAN
RSCAN:	SETOM	ERRFLG		;ASSUME NO INPUT BUFFER
	RESCAN	T1		;GO ASK MONITOR IF IT IS THERE
	SETZM	ERRFLG		;IT IS
	RETURN


;	CALL REENTR		MAKE REENTER ADDRESS NEXT
;				INSTRUCTION

	ENTRY	REENTR
REENTR:	MOVE	TEMP,(STACK)	;GET ADDRESS OF CALLER
	MOVEM	TEMP,.JBREN
	RETURN

;	CALL QGONE		QUIETLY LOG OFF USER

	LOC	.JBCST		;LEAVE A FLAG IN CUST DEF. FOR ROUTINE
	QGONE			;CONTAINS THIS ROUTINE
	RELOC

	ENTRY	QGONE
QGONE:	HRLZI	TEMP,-1		;SET UP FOR DETACH
	ATTACH	TEMP,		;DO IT
	JFCL	TEMP		;IGNORE ERROR
	MOVEI	TEMP,BYEADR	;SET UP FOR RUN UUO
	RUN	TEMP,		;GO RUN LOGOUT
	CALLI	12		;WELL, IF ALL ELSE FAILS, EXIT

BYEADR:	SIXBIT/SYS   /		;LOGOUT BLOCK
	SIXBIT/LOGOUT/
	BLOCK	4

;	CALL ASSIGN( DEVICE, LOGNAM )	ASSIGN LOGICAL NAME TO
;					DEVICE

	ENTRY	ASSIGN
ASSIGN:	SETZM	ERRFLG		;ASSUME NO ERROR
	MOVE	TEMP,@0(ARG)	;GET ACTUAL DEVICE NAME
	MOVE	T1,@1(ARG)	;GET LOGICAL NAME
	DEVLNM	TEMP,		;DO THE ASSIGN
	SETOM	ERRFLG		;FLAG AN ERROR IF WE HAVE ONE
	RETURN

;	CALL PSTOP		STOP AND LEAVE NOTHING

	ENTRY	PSTOP
PSTOP:	MOVEI	17,%MXCHN		;20 CHANNELS TO RELEASE
	HRLI	TEMP,(RELEAS)	;GET RELEASE INSTRUCTION
SLOOP:	XCT	TEMP		;RELEASE THE CHANNEL
	ADD	TEMP,[40,,0]	;MAKE IT THE NEXT CHANNEL
	SOJG	17,SLOOP	;AND GO BACK FOR MORE
	SETZ	17,		;CLEAR THE NAME
	SETNAM	17,		;TELL MONITOR
	MOVE	17,[XWD BLTADR,0];SET UP TO BLT INTO AC'S
	BLT	17,6		;PUT EXIT & CORE IN AC0-6
	GOTO	2		;AND GO EXECUTE IT

BLTADR:	377777,,777		;KILL HISEG, REDUCE TO 1 PAGE
	6,,7			;FOR BLT COPY

	CORE	TEMP,		;KILL MOST OF CORE
	JFCL			;DON'T CARE ABOUT ERRORS
	BLT	T1,777		;AND ZERO OUT 1ST PAGE
	EXIT
	0

	PRGEND
	TITLE	IPCF				;PAGE 13
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

;	CALL SEND( JOB, NARG, VECTOR )	SEND VECTOR (NARG LONG)
;					TO JOB WITH IPCF

	ENTRY	SEND
SEND:	SETZM	ERRFLG		;ASSUME NO ERROR

	MOVE	TEMP,[XWD .PAGCD,SETBLK]	;SET UP TO GET PAGE 377
	PAGE.	TEMP,		;GET THAT PAGE
	JFCL			;WE ALREADY HAD IT
	SETZM	IPCBLK+1	;ZERO SENDERS PID
	HRLI	TEMP,IP.CFP	;SET UP IPCF SO NO STOP ON RCV
	HRRI	TEMP,IP.CFV	;AND SENDING A FULL PAGE
	MOVEM	TEMP,IPCBLK	;STORE FLAGS IN BLOCK
	MOVE	TEMP,@0(ARG)	;GET DESTINATION
	MOVEM	TEMP,IPCBLK+2	;STUFF IT IN BLOCK

	MOVE	TEMP,@1(ARG)	;GET NUMBER OF WORDS TO SEND
	MOVEM	TEMP,377000	;THAT WILL BE FIRST WORD RECEIVED
	ADDI	TEMP,377000	;IT WILL ALSO BE END ADDR FOR BLT
	HRLI	TEMP,(BLT 1,0)	;MAKE IT A BLT INSTRUCTION
	HRRI	T1,377001	;GET START OF WHERE TO PUT ARRAY
	HRLI	T1,@2(ARG)	;AND ADDRESS OF ARRAY TO PUT
	XCT	TEMP		;COPY ARG'S ARRAY TO PAGE 377
	MOVE	TEMP,[XWD 4,IPCBLK]	;SET UP FOR IPCF SEND
	IPCFS.	TEMP,		;SEND THE PAGE
	SETOM	ERRFLG		;ERROR RETURN
	RETURN

SETBLK:	1			;NUMBER OF PAGES TO CREATE
	377			; PAGE TO CREATE


;	CALL RCEIVE( JOB, NARG, VECTOR )	RECEIVE VECTOR
;						(JOB IS RETURNED)

	ENTRY	RCEIVE
RCEIVE:	SETZM	ERRFLG		;ASSUME NO ERROR

	MOVE	TEMP,[XWD 1,KILBLK]	;KILL PAGE, ROOM FOR NEW PAGE
	PAGE.	TEMP,		;KILL THAT PAGE
	JFCL			;NONE TO KILL
	SETZM	@0(ARG)		;IF NO MESSAGE, JOB = 0
	HRLI	TEMP,IP.CFP	;SET UP IPCF SO NO STOP ON RCV
	HRRI	TEMP,IP.CFV	;AND RECEIVING A FULL PAGE
	MOVEM	TEMP,IPCBLK	;STUFF FLAGS IN BLOCK
	MOVE	TEMP,[XWD 6,IPCBLK]	;SET UP TO GET PAGE
	IPCFR.	TEMP,		;GET THE MESSAGE
	GOTO	ARETRN		;NONE THERE, RETURN WITH JOB = 0

	HRRZ	TEMP,IPCBLK+5	;GET JOB NUMBER
	MOVEM	TEMP,@0(ARG)	;GIVE IT TO USER
	HRRI	T1,@2(ARG)	;GET DESTINATION ARRAY
	HRLI	T1,377001	;GET START OF RECEIVED PAGE
	MOVE	TEMP,377000	;GET NUMBER OF WORDS SENT
	MOVEM	TEMP,@1(ARG)	;TELL USER
	HRLZI	TEMP,(BLT 1,0)	;CREATE INSTRUCTION
	HRRI	TEMP,377000	;SET IT UP SO IT KNOWS WHERE TO STOP
	ADDI	TEMP,@2(ARG)	;ADD IN THE WORD COUNT
	XCT	TEMP		;TRANSFER THE ARRAY

ARETRN:	RETURN			;AND RETURN TO USER

IFE %HISEG,	<RELOC>		;LOW
IPCBLK:	0			;FLAGS
	0			;SENDER'S PID
	0			;RECEIVER'S PID
	1000,,377		;LENGTH,,PAGE NUMBER OF INFO
	0			;SENDER'S PPN
	0			;SENDER'S CAPABILITIES
IFE %HISEG,	<RELOC>		;HIGH

KILBLK:	1			;NUMBER OF WORDS IN BLOCK
	400000,,377		;DELETE PAGE 377
	PRGEND
	TITLE	TEMP				;PAGE 14
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

;	CALL MAKTMP( ITEMP, NDAT, VECTOR )
;				CREATE A TMP FILE (NDAT LONG)

	ENTRY	MAKTMP
MAKTMP:	SETZM	ERRFLG		;NO ERROR YET
	MOVE	TEMP,@0(ARG)	;GET TMP FILE NAME
	MOVEM	TEMP,TMPADR	;REMEMBER IT
	MOVN	TEMP,@1(ARG)	;GET SIZE OF ARRAY TO KEEP
	HRLM	TEMP,TMPADR+1	;REMEMBER IT
	MOVEI	TEMP,@2(ARG)	;GET ADDRESS TO KEEP
	SOS	TEMP		;STARTS AT 0, NOT AT 1
	HRRM	TEMP,TMPADR+1	;REMEMBER ADDRESS OF WHERE TO PUT IT
	MOVE	TEMP,[XWD .TCRWF,TMPADR]	;SET UP TO WRITE
	TMPCOR	TEMP,		;WRITE THE TEMP FILE
	SETOM	ERRFLG		;REMEMBER ERROR
	RETURN

IFE %HISEG,	<RELOC>		;LOW
TMPADR:	0			;TEMP FILE NAME
	0			;BUFFER LENGTH,,BUFFER ADDRESS
IFE %HISEG,	<RELOC>		;HIGH


;	CALL GETEMP( TEMP, NDAT, VECTOR )	GET & DELETE TEMP FILE

	ENTRY	GETEMP
GETEMP:	SETZM	ERRFLG		;NO ERROR YET
	MOVE	TEMP,@0(ARG)	;GET FILE NAME
	MOVEM	TEMP,TMPADR	;REMEMBER IT
	MOVEI	TEMP,@2(ARG)	;GET ADDRESS OF WHERE TO PUT IT
	SOS	TEMP		;STARTS AT 0, NOT 1
	HRRM	TEMP,TMPADR+1	;PUT THAT IN TEMP DESTINATION
	MOVN	TEMP,@1(ARG)	;GET NUMBER OF WORDS TO RECEIVE
	HRLM	TEMP,TMPADR+1	;REMEMBER IT
	MOVE	TEMP,[XWD .TCRRF,TMPADR]	;SET UP TO READ
	TMPCOR	TEMP,		;READ THE TMP FILE
	SETOM	ERRFLG		;REMEMBER ERROR
	RETURN
	PRGEND
	TITLE	MATH				;PAGE 15
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

DTRCON:	0.017453		; PI / 180 DEGREES


;	R = REALOF( I )		FOOL FORTRAN
;	I = INTOF( R )		ALLOW EASY CONVERSIONS

	ENTRY	REALOF,INTOF
REALOF:
INTOF:	MOVE	TEMP,@0(ARG)	;JUST RETURN THE VALUE GIVEN
	RETURN


;	R = AINT( RNUM )	GET THE FLOOR OF RNUM

	ENTRY	AINT
AINT:	FIX	TEMP,@0(ARG)	;GET THE INT OF THE NUMBER
	FLTR	TEMP,TEMP	;AND MAKE RESULT REAL
	RETURN


;	R = NEGATE( R )		;RETURN THE NEGATIVE OF R

	ENTRY	NEGATE
NEGATE:	MOVN	TEMP,@0(ARG)	;GET THE NEGATIVE OF FIRST ARG
	RETURN


;	R = DEGRAD( DEG )	CONVERT DEGREES TO RADS

	ENTRY	DEGRAD
DEGRAD:	MOVE	TEMP,@0(ARG)	;GET NUMBER TO CONVERT
	FMPR	TEMP,DTRCON	;MULTIPLY IT BY CONVERSION FACTOR
	RETURN			;RETURN RESULT IN AC0


;	D = RADDEG( RAD )	CONVERT RADS TO DEGREES

	ENTRY	RADDEG
RADDEG:	MOVE	TEMP,@0(ARG)	;GET NUMBER TO CONVERT
	FDVR	TEMP,DTRCON	;MULTIPLY IT BY CONVERSION FACTOR
	RETURN


;	I = ISGN( NUM )		CONVENIENT SGN FUNCTION

	ENTRY	ISGN
ISGN:	SETZ	TEMP,		;RESULT BY DEFAULT IS ZERO
	SKIPGE	@0(ARG)		;UNLESS IT'S NEGATIVE
	MOVNI	TEMP,1		;IN WHICH CASE, RETURN -1
	SKIPLE	@0(ARG)		;OR ITS POSITIVE
	MOVEI	TEMP,1		;IN WHICH CASE, RETURN 1
	RETURN


;	R = ASGN( ANUM )	CONVENIENT REAL SGN FUNCTION

	ENTRY	ASGN
ASGN:	CALL	ISGN		;GET INTEGER SIGN OF IT
	FLTR	TEMP,TEMP	;MAKE IT REAL
	RETURN


;	R = TAND( DEGREE )	TAKE TANGENT IN DEGREES

	ENTRY	TAND
TAND:	CALL	COSD		;TAN IS SIN/COS
	SAVE	TEMP		;SAVE RESULT OF COS
	CALL	SIND		;GET SINE
	RESTORE	T1		;PREPARE FOR DIVISION
	FDVR	TEMP,T1		;DO DIVISION FOR TANGENT
	RETURN			;RETURN VALUE


;	R = TAN( RADIAN )	TAKE TANGENT IN RADIANS

	ENTRY	TAN
TAN:	CALL	COS		;TAN IS SIN/COS
	SAVE	TEMP		;SAVE COS
	CALL	SIN		;GET SINE
	RESTORE	T1		;PREPARE FOR DIVISION
	FDVR	TEMP,T1		;GET TANGENT
	RETURN


;	D = ASIND( R )		RETURN ARCSIN IN DEGS

	ENTRY	ASIND
ASIND:	CALL	ASIN		;GET ARC SINE
	FDVR	TEMP,DTRCON	;CONVERT RESULT
	RETURN


;	D = ACOSD( R )		RETURN ARCCOS IN DEGS

	ENTRY	ACOSD
ACOSD:	CALL	ACOS		;GET ARC COSINE
	FDVR	TEMP,DTRCON	;CONVERT RESULT
	RETURN


;	D = ATAND( R )		RETURN ARCTAN IN DEGS

	ENTRY	ATAND
ATAND:	CALL	ATAN		;GET ARC TANGENT
	FDVR	TEMP,DTRCON	;CONVERT RESULT
	RETURN


;	I = IFACTR( N )		RETURN FACTORIAL

	ENTRY	IFACTR
IFACTR:	MOVEI	TEMP,1		;SET INITIAL VALUE TO 1
	SKIPG	T1,@0(ARG)	;GET NUMBER OF TIMES TO MULTIPLY
	RETURN			;ITERATIONS < 1
FACLOP:	IMUL	TEMP,T1		;DO THE MULTIPLICATION
	SOJG	T1,FACLOP	;GO DO IT AGAIN
	RETURN			;RETURN WHEN NO MORE


;	CALL TVAR( OUTARA )	;JUMP TO ARRAY AND START EXECUTING

	ENTRY	TVAR
TVAR:	MOVEI	TEMP,@0(ARG)	;GET ADDRESS OF WHERE TO JUMP
	GOTO	@0		;AND GO


;	CALL DEFUNC( NAME, NUMARG )	;DEFINE FUNCTION FOR CMPCOD
;	    CALL NAME

	ENTRY	DEFUNC
DEFUNC:	MOVE	T1,(STACK)	;GET RETURN ADDRESS FROM STACK
	MOVE	TEMP,1(T1)	;GET PUSHJ INSTR. AFTER RETURN
	MOVE	T1,NUMFNC	;GET THE NUMBER OF FUNCTIONS DEFINED
	AOS	NUMFNC		;INCREMENT IT
	HRL	TEMP,@1(ARG)	;GET NUMBER OF ARGUMENTS
	MOVEM	TEMP,FNCADR(T1)	;PLACE ADDRESS,#ARGS IN TABLE
	MOVE	TEMP,@0(ARG)	;GET ITS SIXBIT NAME
	MOVEM	TEMP,FNCNAM(T1)	;PUT IT IN TABLE
	MOVEI	TEMP,2		;GOING TO SKIP 2 INSTRUCTIONS
	ADDM	TEMP,(STACK)	;INCREMENT RETURN PC
	RETURN			;AND RETURN SKIPPING MOVEI AND PUSHJ


;	CALL CMPCOD( FRMARA, LENGTH, CODARA, MAXLEN, ACTLEN
;		[ , NAME1,VAR1, NAME2,VAR2, NAME3,VAR3 ... ] )

	ENTRY	CMPCOD
CMPCOD:	SETO	TEMP,		;GET -1 TO MARK BEGINNING OF STACK
	SAVE	TEMP		;PUT IT ON THE STACK
	SETZM	ERRFLG		;NO ERROR YET
	MOVEI	T1,@0(ARG)	;GET POINTER INTO FORMULA ARRAY
	MOVE	T2,@1(ARG)	;GET LENGTH OF ARRAY
	MOVE	T3,T1		;GET POINTER TO REPLACE WITH FIRST PASS
	SETZB	T4,NUMNMS	;PASS 1 NOT STARTED, NO NUMS FOUND

ANOTHR:	CALL	GETCHR		;GET NEXT CHARACTER

PASS1:	CAIL	TEMP,"A"	;CHECK FOR ID, IS IT A LETTER?
	CAILE	TEMP,"Z"	;IF OUTSIDE OF A-Z RANGE
	GOTO	NOTID		;NO, ALL ID'S START WITH LETTERS

;***	ID HANDLING CODE	***

	SETZ	T7,		;ZERO OUT WORD FOR SIXBIT
	MOVE	T5,[440600,,7]	;GET A BYTE POINTER TO MAKE SIXBIT WORD
	MOVEI	T6,6		;AND MAX NUMBER OF CHAR IN WORD

IDLOOP:	SUBI	TEMP," "	;MAKE IT SIXBIT
	SOSL	T6		;DECREMENT NUMBER LEFT, SKIP IF NO FIT
	IDPB	TEMP,T5		;ELSE PUT THE BYTE IN
	CALL	GETCHR		;GET NEXT CHARACTER
	CAIL	TEMP,"0"	;CAN BE EITHER DIGIT OR LETTER
	CAILE	TEMP,"Z"	;CHECK IF IT IS IN RANGE 0-Z
	GOTO	ENDIDL		;NOPE, NEITHER DIGIT OR LETTER, LEAVE
	CAILE	TEMP,"9"	;IS IT IN THE RANGE OF ASCII
	CAIL	TEMP,"A"	;9 - A?
	GOTO	IDLOOP		;NO, THEN ITS LEGAL, GO PUT IT IN

ENDIDL:	MOVN	T5,-1(ARG)	;HAVE COMPLETED ID, GET NUMBER ARGS
	HLRZ	T5,T5		;ON RIGHT HALF
	SUBI	T5,5		;DON'T CARE ABOUT FIRST FIVE
	IDIVI	T5,2		;FIND NUMBER OF NAME,VAR PARS
	JUMPN	T6,SERROR	;IF NOT JUST PAIRS, ERROR
	JUMPE	T5,NOTVAR	;IF NO ARGS, TRY FUNCTION
	HRRZ	T6,ARG		;GET A POINTER TO ARG LIST

FINVAR:	CAMN	T7,@5(T6)	;DOES IT MATCH NAME FIELD?
	GOTO	ITSVAR		;YES, IT WAS THAT VARIABLE
	ADDI	T6,2		;NOPE, CHECK NEXT IN LIST OF ARGS
	SOJG	T5,FINVAR	;DECREMENT NUMBER LEFT TO GO AND LOOP

NOTVAR:	SKIPG	T5,NUMFNC	;NO A VARIABLE, GET NUMBER FUNCTIONS
	GOTO	SERROR		;NONE?  DON'T RECOGNIZE ID
	SETZ	T6,		;ZERO OUT TABLE POINTER

FINFNC:	CAMN	T7,FNCNAM(T6)	;DOES ID MATCH FUNCTION NAME?
	GOTO	ITSFNC		;YES, HANDLE AS A FUNCTION
	ADDI	T6,1		;ELSE, CHECK NEXT IN FNC LIST
	SOJG	T5,FINFNC	;DECREMENT NUMBER LEFT TO GO AND LOOP
	GOTO	SERROR		;DON'T KNOW ABOUT ID, ERROR

ITSFNC:	MOVE	T7,T6		;GET ADDRESS OF FUNCTION
	TLOA	T7,100000	;FLAG THAT IT'S A FUNCTION

ITSVAR:	HRRZI	T7,@6(T6)	;GET ADDRESS OF VARIABLE
	TLO	T7,400000	;FLAG THAT IT IS NOT A SIMPLE SYMBOL
	MOVEM	T7,(T3)		;STORE AWAY THE POINTER & FLAG
	ADDI	T3,1		;INCREMENT THE ADDRESS
	ADDI	T4,1		;AND THE NUMBER OF THINGS KEPT
	GOTO	NOTFRA		;AND GO DEAL WITH LAST CHAR READ

NOTID:	HRLI	T6,(1.0)	;SET UP FOR NUMBER
	SETZ	T5,		;NUMBER STARTS AT 0
	CAIL	TEMP,"0"	;IS IT IN RANGE
	CAILE	TEMP,"9"	;OF 0 - 9?
	GOTO	NOTNUM		;NOPE, CAN'T BE START OF NUMBER

;***	NUMBER HANDLING CODE	***

NUMLOP:	FMP	T5,[10.0]	;SHIFT NUMBER OVER A DECIMAL PLACE
	SUBI	TEMP,"0"	;MAKE ASCII A DIGIT
	FLTR	TEMP,TEMP	;MAKE IT A REAL DIGIT
	FADR	T5,TEMP		;ADD IT IN
	CALL	GETCHR		;GET ANOTHER CHARACTER
	CAIN	TEMP,"."	;IF ITS A POINT
	GOTO	INFRAC		;DEAL WITH IT AS THAT
	CAIL	TEMP,"0"	;ELSE CHECK IF IT IS IN RANGE
	CAILE	TEMP,"9"	;OF 0 - 9
	GOTO	ENDNUM		;IF NOT, NO NORE NUMBER
	GOTO	NUMLOP		;OTHERWISE, GO SHIFT & ADD ETC.

NOTNUM:	CAIE	TEMP,"."	;IF IT WASN'T A POINT
	GOTO	NOTFRA		;THEN NOT FRACTIONAL PART

INFRAC:	CALL	GETCHR		;ELSE GET NEXT CHARACTER
	CAIL	TEMP,"0"	;CHECK IF IT IS IN RANGE
	CAILE	TEMP,"9"	;OF 0 - 9
	GOTO	ENDNUM		;IF NOT, END NUMBER
	SUBI	TEMP,"0"	;ELSE, MAKE ASCII A DIGIT
	FLTR	TEMP,TEMP	;MAKE IT A REAL DIGIT
	FMPR	T6,[0.1]	;SHIFT THE PLACE TO THE RIGHT
	FMPR	T6,TEMP		;GET NUMBER OF NTHS
	FADR	T5,T6		;AND ADD IT INTO ORIGINAL NUMBER
	GOTO	INFRAC		;GO GET ANOTHER DIGIT

ENDNUM:	SETZ	T7,		;ZERO INDEX INTO TABLE
	MOVE	T6,NUMNMS	;GET THE NUMBER OF NUMBER
	JUMPE	T6,NONENC	;IF ZERO, ADD THIS TO LIST

FNDNUM:	CAMN	T5,NUMTBL(T7)	;ELSE CHECK IF THIS MATCHES ENTRY
	GOTO	NUMFND		;YES, GO HANDLE IT
	ADDI	T7,1		;NO, INCREMENT POINTER
	SOJG	T6,FNDNUM	;DECREMENT NUMBER LEFT AND LOOP

NONENC:	AOS	NUMNMS		;NONE FOUND, INCREMENT NUMBER OF NUMS
	MOVEM	T5,NUMTBL(T7)	;AND PUT ENTRY IN TABLE

NUMFND:	TLO	T7,600000	;FLAT THAT ITS A CONSTANT
	MOVEM	T7,(T3)		;STORE ENTRY IN PASS RESULTS
	ADDI	T3,1		;INCREMENT POINTER
	ADDI	T4,1		;AND NUMBER OF ENTRIES
	GOTO	PASS1		;GO BACK FOR ANOTHER

;***	SYMBOL HANDLING CODE	***

NOTFRA:	MOVE	T7,NUMSYM	;ELSE, GET NUMBER OF SYMBOLS
	SOJL	T7,SERROR	;EXIT IF ZERO OPS

SYMLOP:	CAMN	TEMP,SYMS(T7)	;CHECK IT AGAINST TABLE
	GOTO	FNDSYM		;MATCH, SYMBOL FOUND
	SOJGE	T7,SYMLOP	;NOPE, TRY NEXT ONE
	CAIN	TEMP," "	;IS END OF STRING?
	GOTO	EOPAS1		;IF IT IS A SPACE, END OF PASS
	GOTO	SERROR		;NO MORE TO CHECK, ERROR

FNDSYM:	MOVEM	T7,(T3)		;PUT SYMBOL NUMBER IN PASS LIST
	ADDI	T3,1		;INCREMENT POINTER
	ADDI	T4,1		;AND NUMBER OF SYMBOLS
	GOTO	ANOTHR		;GO GET ANOTHER CHARACTER

;*********************** END OF FIRST PASS **********************

EOPAS1:	JUMPLE	T4,SERROR	;PASS 1 GENERATED NOTHING, ERROR
	SETZB	T5,T2		;ZERO OUT PAREN LEVEL, NUM INS
	SETZ	T12,		;ZERO NUMBER NUMS ON STACK
	MOVEI	T1,@2(ARG)	;GET POINTER INTO CODE ARRAY
	SUBI	T3,1		;MAKE PASS START AT END OF ARRAY
	MOVE	TEMP,[PUSH	17,2]
	CALL	PUTINS		;CODE SAVES AC 2
	MOVE	TEMP,[PUSH	17,16]
	CALL	PUTINS		;CODE SAVES AC 16
	MOVE	TEMP,[MOVEI	16,FNCBLK]
	CALL	PUTINS		;MAKE IT SET UP ARG BLOCK FOR FNC CALLS
	MOVE	TEMP,[PUSHJ	17,GETPC]
	CALL	PUTINS		;MAKE IT CALL A ROUTINE TO RETURN PC
	HRLZI	TEMP,(ADDI	T2,)
	CALL	PUTINS		;GET OFFSET INTO ROUTINE FOR CONSTANTS

;***	CODE GENERATING STUFF	***

PASS2:	MOVE	TEMP,(T3)	;GET LAST WORD IN LIST
	SUBI	T3,1		;DECREMENT POINTER
	JUMPGE	TEMP,MSTBOP	;IF 1ST BIT NOT SET, OPERATOR
	TLNE	TEMP,100000	;IS IT A FUNCTION?
	GOTO	HNDLFN		;YES, GO HANDLE THE FUNCTION
	TLNN	TEMP,200000	;IS IT A CONSTANT?
	GOTO	VARFRM		;NOPE, ASSUME ITS A VARIABLE
	HRLI	TEMP,(PUSH 17,0(2))	;CONSTANT FORMAT
	SKIPA			;DON'T USE VARIABLE FORMAT
VARFRM:	HRLI	TEMP,(PUSH	17,)
	CALL	PUTINS		;PUT CODE IN ARRAY
	AOJA	T12,EOP2LP	;INCREMENT NUM ON STACK AND LOOP

HNDLFN:	HRL	TEMP,T5		;GET NUMBER PARS IN FOR FNC
	TLO	TEMP,20		;FUNCTIONS ARE PRECEDENCE #16
	MOVE	T6,TEMP		;SET UP FOR COMLOP
	HLLZ	T10,TEMP	;AND FOR COMPARISON
	GOTO	COMLOP		;GO DEAL WITH IT

MSTBOP:	SKIPE	TEMP		;IS IT LEFT PAREN?
	GOTO	NOTLPR		;NOPE
	ADDI	T5,100		;YES, INCREASE PRECEDENCE OF OPS
	GOTO	EOP2LP		;AND GET THE NEXT CHARACTER

NOTLPR:	CAIE	TEMP,1		;IS IT RIGHT PAREN?
	GOTO	NOTRPR		;NOPE
	SUBI	T5,100		;NO, DECREASE PRECEDENCE OF OPS
	JUMPL	T5,SERROR	;IF MORE LPAREN'S THEN RPARENS, BARF
	GOTO	EOP2LP		;AND GET THE NEXT CHARACTER

NOTRPR:	MOVE	T6,TEMP		;GET COPY OF OP
	LSH	TEMP,-1		;MAKE TEMP THE PRECEDENCE
	ADD	TEMP,T5		;ADD IN FACTOR OF PARENS
	HRL	T6,TEMP		;STORE PRECEDENCE IN THEOP
	HRLZ	T10,TEMP	;SET FOR COMPARISON LOOP

COMLOP:	CAMLE	T10,(STACK)	;IF THIS OPERATOR DOESN'T TAKE PREC
	GOTO	ECMLOP		;NO POINT IN CLEARING OUT OLD OPS
	RESTORE	T7		;GET OPERATION STUFF
	HLR	TEMP,T7		;CHECK PRECEDENCE
	ANDI	TEMP,37		;ONLY CHECK LAST 5 BITS
	CAIG	TEMP,1		;IS IT THE COMMA OP?  (NOOP)
	GOTO	ECMLOP		;YES, IGNORE IT
	CAIG	TEMP,3		;IS IT LOW PRECEDENCE OP?
	GOTO	LOPROP		;YES
	CAIE	TEMP,20		;IS IT A FUNCTION?
	SUBI	T7,10		;LIKE CALL TO RAISE & NEGATE?
	GOTO	HANFNC		;GO HANDLE "FUNCTION"

LOPROP:	SOJLE	T12,SERROR	;NOTHING NOTHING ON STACK?
	HLRZ	TEMP,-1(T1)	;GET LAST INSTRUCTION
	ANDI	TEMP,777000	;GET INSTRUCTION PART
	CAIE	TEMP,(PUSH)	;IS IT A PUSH INSTRUCTION?
	GOTO	NOTPSH		;NOPE, GOING TO DO IT THE LONG WAY

	MOVE	TEMP,-1(T1)	;GET THE WORD AGAIN
	TLZ	TEMP,777740	;TURN OFF OP BITS
	TLO	TEMP,(MOVE)	;MAKE IT A MOVE INSTRUCTION
	SUBI	T1,1		;DECREMENT ADDRESS
	SUBI	T2,1		;DECREMENT SIZE OF CODE ARRAY
	CALL	PUTINS		;AND REPLACE WORD IN ARRAY
	MOVE	TEMP,MEMINS(T7)	;GET INSTRUCTION TO PUT IN CODE
	CALL	PUTINS		;PUT INSTRUCTION IN CODE ARRAY
	GOTO	COMLOP		;GO BACK FOR NEXT

NOTPSH:	HRLZI	TEMP,(POP	17,0)	;HAVE TO GET ARG OFF STACK
	CALL	PUTINS		;PUT THAT INSTRUCTION IN CODE ARRAY
	MOVE	TEMP,MEMINS(T7)	;GET THE INSTRUCTION FOR THE OP
	CALL	PUTINS		;PUT THE OP IN THE ARRAY
	GOTO	COMLOP		;GET ANOTHER

HANFNC:	HLRZ	T11,FNCADR(T7)	;GET NUMBER OF ARGS IN FUNCTION
	SKIPG	T11		;IF NOT GREATER THAN ZERO
	MOVEI	T11,1		;MAKE IT 1
	CAIL	T11,10		;IF TOO MANY ARGS
	GOTO	SERROR		;ITS AN ERROR
	MOVEI	TEMP,ARGBLK	;GET POINTER INTO ARGBLK

ARGLOP:	SOJL	T12,SERROR	;NOTHING ON STACK?
	HRLI	TEMP,(POP	17,)
	CALL	PUTINS		;ADD INSTRUCTION TO CODE ARRAY
	ADDI	TEMP,1		;INCREMENT POSITION IN ARGBLK
	SOJG	T11,ARGLOP	;AND GO BACK FOR ANOTHER ARG

	MOVE	TEMP,FNCADR(T7)	;GET ADDRESS OF FUNCTION
	HRLI	TEMP,(PUSHJ	17,)
	CALL	PUTINS		;PUT CALL IN CODE ARRAY
	HRLZI	TEMP,(PUSH	17,0)
	CALL	PUTINS		;PUT RESULT SAVER IN CODE ARRAY
	AOJA	T12,COMLOP	;AND GO GET ANOTHER

ECMLOP:	SAVE	T6		;AND PUT CURRENT OP ON STACK
EOP2LP:	SOJG	T4,PASS2	;GO GET ANOTHER WORD IF AVAILABLE
	SETZ	T10,		;ZERO COMPARISON REGISTER
	JUMPE	T4,COMLOP	;CLEAR OUT REST OF STACK
	JUMPN	T5,SERROR	;IF CODE IS MISSING PAREN'S, ERROR
	SOJN	T12,SERROR	;IF ANYTHING ON CODE'S STACK, DIE
	RESTORE	TEMP		;GET LAST GARBAGE OFF STACK
	HLRZ	TEMP,-1(T1)	;GET LAST INSTRUCTION GENERATED
	ANDI	TEMP,777000	;ONLY GET OP PART
	CAIE	TEMP,(PUSH)	;IS IT A PUSH INSTRUCTION?
	GOTO	MSTPOP		;NOPE, MUST POP RESULTS

	MOVE	TEMP,-1(T1)	;YES, GET INSTRUCTION AGAIN
	TLZ	TEMP,777740	;TURN OFF OP BITS
	TLO	TEMP,(MOVE)	;AND MAKE IT MOVE INSTRUCTION
	SUBI	T1,1		;DECREMENT ADDRESS
	SUBI	T2,1		;DECREMENT SIZE OF CODE ARRAY
	CALL	PUTINS		;AND REPLACE WORD
	GOTO	ENDNPS		;AND SKIP THE FOLLOWING

MSTPOP:	HRLZI	TEMP,(POP	17,0)
	CALL	PUTINS		;MAKE IT GET RESULTS OFF STACK

ENDNPS:	MOVE	TEMP,[POP	17,16]
	CALL	PUTINS		;MAKE SURE CODE RESTORES ARG REGISTER
	MOVE	TEMP,[POP	17,2]
	CALL	PUTINS		;MAKE SURE CODE RESTORES AC 2
	HRLZI	TEMP,(POPJ	17,)
	CALL	PUTINS		;MAKE SURE CODE RETURNS TO CALLER
	MOVE	TEMP,T2		;REMEMBER SIZE TO END OF CODE ITSELF
	ADD	T2,NUMNMS	;GET NUMBER OF NUMBERS TO ADD TO CODE
	CAMLE	T2,@3(ARG)	;CHECK IF THAT IS LEGAL
	GOTO	SERROR		;NOT ENOUGH ROOM, ERROR
	MOVEM	T2,@4(ARG)	;ELSE STORE SIZE OF CODE ARRAY
	SUBI	TEMP,4		;TO ACCOUNT FOR BEGINNING INSTRUCTIONS
	MOVEI	T3,@2(ARG)	;GET BEGINNING POINTER AGAIN
	HRRM	TEMP,4(T3)	;PUT INCREMENT ON ADDI 2, INSTRUCTION
	SKIPG	T2,NUMNMS	;IF NO NUMBERS TO ADD TO CODE
	GOTO	ENDCMP		;DON'T PUT THE NUMBER LIST AT END

	ADD	T2,T1		;ELSE FIND ENDING ADDRESS
	HRLI	T1,NUMTBL	;GET BEGINNING ADDRESS
	SUBI	T2,1		;FROM 0 TO LENGTH-1, NOT 1 TO LENGTH
	HRLI	T2,(BLT	T1,)	;SETUP INSTRUCTION
	XCT	T2		;MOVE FROM NUMTBL INTO CODE ARRAY
ENDCMP:	RESTORE	TEMP		;GET THE -1 OFF THE STACK
	AOSN	TEMP		;IF IT WAS -1
	RETURN			;RETURN, ELSE IT WAS AN ERROR

SERROR:	RESTORE	TEMP		;GET SOME GARBAGE OFF STACK
	AOJN	TEMP,SERROR	;IF IT WASN'T THE -1, DO IT AGAIN
	SETOM	ERRFLG		;SET THE ERROR FLAG
	RETURN			;AND RETURN

;	LOCAL ROUTINE GETS A CHARACTER FROM STRING, REMOVING BLANKS
;AND CHANGING ALL LOWER CASE TO UPPER CASE

GETCHR:	MOVEI	TEMP," "	;FLAG FOR END OF LINE
	SOSGE	T2		;DECREMENT NUMBER CHARACTERS LEFT
	RETURN			;NONE LEFT, RETURN WITH FLAG
	MOVE	TEMP,(T1)	;GET THE CHARACTER
	ADDI	T1,1		;INCREMENT ADDRESS
	TLNE	TEMP,-1		;IS IT IN A1 FORMAT?
	LSH	TEMP,^D-29	;YES, MAKE IT R1 FORMAT
	CAIG	TEMP," "	;IS IT A SPACE OR CONTROL CHAR?
	GOTO	GETCHR		;YES, IGNORE IT
	CAIGE	TEMP,^D97	;IS IT LESS THAN A LOWER CASE A?
	RETURN			;YES, THEN ITS FINE
	CAIG	TEMP,^D122	;IS IT LESS THAN OR EQUAL TO LOWER Z
	SUBI	TEMP,40		;YES, CONVERT IT TO UPPER CASE
	RETURN			;AND RETURN IT

PUTINS:	CAMN	TEMP,[MOVE 0,0]	;INADVERTANTLY INSERTING NOOP?
	RETURN			;YUP, DON'T BOTHER
	ADDI	T2,1		;INCREMENT NUMBER WORDS IN CODE ARRAY
	CAMLE	T2,@3(ARG)	;OVER MAXIMUM?
	GOTO	SERROR		;YES, ERROR
	MOVEM	TEMP,0(T1)	;PUT INSTRUCTION IN CODE ARRAY
	ADDI	T1,1		;INCREMENT ADDRESS
	RETURN

GETPC:	MOVE	2,(17)		;GET RETURN ADDRESS
	RETURN			;AND RETURN

FNCBLK:	ARGBLK
	ARGBLK+1
	ARGBLK+2
	ARGBLK+3
	ARGBLK+4
	ARGBLK+5
	ARGBLK+6
	ARGBLK+7

NUMSYM:	^D10
SYMS:	")"
	"("
	","
	";"
	"+"
	"-"
	"*"
	"/"
	"^"
	"_"

MEMINS:	HALT			;PAREN'S SHOULD NEVER BE EXECUTED
	HALT
	HALT			;OR COMMA'S
	HALT
	FADRM	0,(17)		;ADD, LEAVE RESULTS ON STACK
	FSBRM	0,(17)		;SUBTRACT, RESULTS ON STACK
	FMPRM	0,(17)		;MULTIPLY, RESULTS ON STACK
	FDVRM	0,(17)		;DIVIDE, RESULTS ON STACK

IFE %HISEG,	<RELOC>		;LOW
ARGBLK:	BLOCK	10

NUMFNC:	^D25
FNCNAM:	SIXBIT/RAISE NEGATECOS   COSD  SIN   SIND  LOG   LN    ABS   /
	SIXBIT/ASIN  ACOS  ATAN  SINH  COSH  TANH  TAN   TAND  SGN   /
	SIXBIT/DEGRADRADDEGASIND ACOSD ATAND RAN   INT   /
	BLOCK	20

	EXTERN	EXP3.,COS,COSD,SIN,SIND,ALOG10,ALOG,ABS,ASIN,ACOS
	EXTERN	ATAN,SINH,COSH,TANH,ARAN
FNCADR:	2,,EXP3.
	EXP	NEGATE,COS,COSD,SIN,SIND,ALOG10,ALOG,ABS,ASIN,ACOS
	EXP	ATAN,SINH,COSH,TANH,TAN,TAND,ASGN,DEGRAD,RADDEG
	EXP	ASIND,ACOSD,ATAND,ARAN,AINT
	BLOCK	20

NUMNMS:	0			;NUMBER OF REAL NUMBERS IN TABLE
NUMTBL:	BLOCK	40		;TABLE TO STORE THEM IN BEFORE IN CODE
IFE %HISEG,	<RELOC>		;LOW
	PRGEND
	TITLE	CNTRLC				;PAGE 16
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>

;	CALL ENABLE		TURN ON CONTROL-C TRAP

	ENTRY	ENABLE
ENABLE:	MOVEI	TEMP,NOTHIN	;GET ADDRESS OF A *DULL* ROUTINE
	HRRM	TEMP,INTBLK	;PUT IT IN ^C BLOCK
	RETURN

;	CALL DISABL		TURN OFF CONTROL-C TRAP

	ENTRY	DISABL
DISABL:	SETZ	TEMP,		;GET A ZERO
	HRRM	TEMP,INTBLK	;TO PUT IN ADDRESS TO CALL ON ^C
	RETURN

;	CALL CTRAP			CALL FOLLOWING SUBROUTINE
;	CALL SUBROU( ARG1, ARG2 ... )	ON ^C AND SKIP SUBROUTINE
;					CALL AFTER CTRAP

	ENTRY	CTRAP
CTRAP:	MOVE	T1,(STACK)	;GET ADDRESS OF CALLER
	MOVE	TEMP,0(T1)	;GET WORD AT THAT ADDRESS (MOVEI 16,?)
	MOVEM	TEMP,ARGADR	;REMEMBER IT FOR THE CALL DURING ^C
	MOVE	TEMP,1(T1)	;GET WORD AFTER (PUSHJ 17,?)
	MOVEM	TEMP,SUBCAL	;AND REMEMBER THAT
	MOVEI	TEMP,CALSUB	;GET ADDRESS OF THIS "ROUTINE" CALLER
	HRRM	TEMP,INTBLK	;PUT THAT IN INTERUPT BLOCK
	MOVEI	TEMP,2		;GOING TO SKIP NEXT 2 OF CALLERS INS
	ADDM	TEMP,(STACK)	;SO INCREMENT STACK BY 2
	RETURN

NOTHIN:	SAVE	INTBLK+2	;REMEMBER WHERE TO RETURN TO
	SETZM	INTBLK+2	;CLEAR INTERUPT BLOCK
	RETURN			;AND LEAVE

CALSUB:	SAVE	INTBLK+2	;REMEMBER WHERE TO RETURN TO
	SETZM	INTBLK+2	;CLEAR THE CALLER
	SKIPE	BEEN		;DON'T TRAP INSIDE ROUTINE
	RETURN
	SETOM	BEEN		;FLAG THAT WE'RE IN ROUTINE
	SAVE	TEMP		;AND SAVE ALL AC'S
	SAVE	T1
	SAVE	T2
	SAVE	T3
	SAVE	T4
	SAVE	T5
	SAVE	T6
	SAVE	T7
	SAVE	T10
	SAVE	T11
	SAVE	T12
	SAVE	T13
	SAVE	T14
	SAVE	T15
	SAVE	ARG
	MOVEI	ARG,@ARGADR	;CALL ROUTINE WITH ORIGINAL ARGS
	CALL	@SUBCAL		;JUMP TO THAT RETURN
	RESTORE	ARG		;AND RESTORE ALL AC'S
	RESTORE	T15
	RESTORE	T14
	RESTORE	T13
	RESTORE	T12
	RESTORE	T11
	RESTORE	T10
	RESTORE	T7
	RESTORE	T6
	RESTORE	T5
	RESTORE	T4
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RESTORE	TEMP
	SETZM	BEEN		;AND ALLOW ROUTINE TO BE CALLED AGAIN
	RETURN

IFE %HISEG,	<RELOC>		;LOW
INTBLK:	4,,0			;NUMBER WORDS IN BLOCK, HANDLER
	ER.ICC			;INTERUPT ON CONTROL-C'S
	0			;LAST USER PC
	0			;INTERUPT CONDITIONS

ARGADR:	0			;WHERE ARG BLOCK FOR ROUTINE IS
SUBCAL:	0			;ADDRESS OF ROUTINE TO CALL
BEEN:	0			;TRUE IF IN THE ROUTINE.

	LOC	.JBINT
	INTBLK
IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	TITLE	EXADEP				;PAGE 17
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	
	EXTERN	ERRFLG

;	CALL E( ILOC, IVAL )	RETURN VALUE AT LOCATION

	ENTRY	E,IE
E:
IE:	MOVE	T1,@0(ARG)	;GET ADDRESS TO RETURN VALUE OF
	MOVE	TEMP,(T1)	;GET VALUE AT THAT ADDRESS
	MOVN	T1,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T1,T1		;IN RIGHT HALF
	CAIL	T1,2		;IF A PLACE FOR VALUE IN ARG BLOCK
	MOVEM	TEMP,@1(ARG)	;PUT IT THERE
	RETURN

;	CALL D( ILOC, IVAL )	PUT VALUE AT LOCATION

	ENTRY	D
D:	MOVE	TEMP,@1(ARG)	;GET VALUE TO PLACE
	MOVE	T1,@0(ARG)	;GET ADDRESS FOR VALUE
	MOVEM	TEMP,(T1)	;PUT VALUE IN MEMORY
	RETURN

;	CALL CCORE( ILOW, IHIGH )	CHANGE CORE LIMITS

	ENTRY	CCORE
CCORE:	SETZM	ERRFLG		;NO ERROR YET
	MOVE	TEMP,@0(ARG)	;GET LOW LIMIT
	HRL	TEMP,@1(ARG)	;PUT IN RIGHT LIMIT FOR CORE UUO
	CORE	TEMP,		;CHANGE CORE IMAGE
	SETOM	ERRFLG		;GOT AN ERROR, FLAG IT
	HRRZ	TEMP,.JBREL	;GET LOWCORE LIMIT
	HRLM	TEMP,.JBSA	;SET THIS... FOR
	HRRM	TEMP,.JBFF	;ETC.,ETC.
	HRLM	TEMP,.JBCOR	;SET THE THING SEEN BY ".SAV"
	RETURN

;	CALL HIPROT( ISWITCH )	CHANGE HISEGMENT WRITE PROTECT

	ENTRY	HIPROT
HIPROT:	SETZM	ERRFLG		;NO ERROR YET
	MOVE	TEMP,@0(ARG)	;GET WRITE PROTECT SWITCH
	SETUWP	TEMP,		;TRY TO SET/UNSET IT
	SETOM	ERRFLG		;IF ERROR, FLAG IT
	RETURN

;	CALL TCON( NEWLOC )	JUMP TO ADDRESS

	ENTRY	TCON
TCON:	HRLI	TEMP,(JRST 0,)	;GET JUMP INSTRUCTION
	HRR	TEMP,@0(ARG)	;PUT IN ADDRESS TO JUMP TO
	XCT	TEMP		;JUMP TO ADDRESS

;	CALL SHIFTC( IVAL0, IVAL1, INC )	LSHC VALUES BY INC

	ENTRY	SHIFTC
SHIFTC:	MOVE	TEMP,@0(ARG)	;GET VALUE IN LEFT WORD
	MOVE	T1,@1(ARG)	;GET VALUE IN RIGHT WORD
	MOVE	T3,@2(ARG)	;GET INCREMENT
	HRLI	T3,(LSHC 0,)	;MAKE IT INTO AN INSTRUCTION
	XCT	T3		;DO THE SHIFT
	MOVEM	TEMP,@0(ARG)	;REPLACE THE VALUES
	MOVEM	T1,@1(ARG)
	RETURN


;	CALL SHIFT( IVAL, INC, IRES )

	ENTRY	SHIFT,ISHIFT
SHIFT:
ISHIFT:	MOVE	TEMP,@0(ARG)	;GET VALUE TO SHIFT
	MOVE	T1,@1(ARG)	;GET NUMBER OF BITS TO SHIFT IT
	HRLI	T1,(LSH 0,)	;MAKE IT AN INSTRUCTION
	XCT	T1		;AND DO IT
	MOVN	T1,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T1,T1		;ON RIGHT SIDE
	CAILE	T1,2		;IF ROOM FOR ARG
	MOVEM	TEMP,@2(ARG)	;PUT IT THERE
	RETURN


MAKBYT:	MOVEI	T1,^D35		;GET MAX BIT IN WORD
	SUB	T1,@1(ARG)	;GET PLACE TO START IN WORD
	LSH	T1,6		;AND SHIFT IT OVER FOR BYTE INSTRUCTION
	ADD	T1,@1(ARG)	;ADD IN END BIT
	SUB	T1,@0(ARG)	;SUBTRACT START SO IT HAS BYTE WIDTH
	ADDI	T1,1		;ADD 1 SO NUM BITS, STEAD OF DIFF
	LSH	T1,^D24		;MAKE IT A BYTE POINTER
	IORI	T1,@2(ARG)	;GET WORD TO DO BYTE INS ON
	RETURN			;AND GO BACK TO CALLER


;	CALL GETBYT( ILBIT, IRBIT, INVAL, IOVAL )

	ENTRY	GETBYT,IGTBYT
GETBYT:
IGTBYT:	CALL	MAKBYT		;GET BYTE POINTER
	LDB	TEMP,T1		;GET WORD IN QUESTION
	MOVN	T1,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T1,T1		;IN RIGHT HALF
	CAILE	T1,3		;IF ROOM FOR ARG
	MOVEM	TEMP,@3(ARG)	;PUT IN ARG BLOCK
	RETURN


;	CALL PUTBYT( ILBIT, IRBIT, IVAL, IOP )

	ENTRY	PUTBYT
PUTBYT:	CALL	MAKBYT		;GET BYTE POINTER
	MOVE	TEMP,@3(ARG)	;GET VALUE TO PLACE IN WORD
	DPB	TEMP,T1		;PUT IT THERE
	RETURN


;	I = ILEFT( IVAL )	GET LEFT HALF OF WORD

	ENTRY	ILEFT
ILEFT:	HLRZ	TEMP,@0(ARG)	;GET LEFT SIDE OF WORD
	RETURN

;	I = IRIGHT( IVAL )	GET RIGHT HALF OF WORD

	ENTRY	IRIGHT
IRIGHT:	HRRZ	TEMP,@0(ARG)	;GET RIGHT HALF OF WORD
	RETURN

;	I = ICOMB( ILEFT, IRIGHT )	RECONSTRUCT A WORD

	ENTRY	ICOMB
ICOMB:	HRL	TEMP,@0(ARG)	;GET THE LEFT OF THE WORD
	HRR	TEMP,@1(ARG)	;AND RIGHT RIGHT OF THE WORD
	RETURN


;	CALL EXECUT( IWORD )	EXECUTE WORD

	ENTRY	EXECUT
EXECUT:	SETOM	ERRFLG		;ASSUME AN ERROR
	MOVE	T1,@0(ARG)	;GET THE INSTRUCTION TO EXECUTE
	XCT	T1		;EXECUTE IT
	RETURN			;ERROR RETURN IF IT EXISTS
	SETZM	ERRFLG		;ELSE NO ERROR
	RETURN

IFE %HISEG,	<RELOC>		;LOW
	ENTRY	BREFT
BREFT:	0
STACK:	BLOCK	1000
STKLOC:	IOWD	1000,STACK
IFE %HISEG,	<RELOC>		;HIGH

;	CALL PUSHVL( IVAL, PDLERR )	PUSH VALUE ONTO STACK

	ENTRY	PUSHVL
PUSHVL:	SETZM	@1(ARG)		;DON'T HAVE A PDL OVERFLOW YET
	MOVE	T1,STKLOC	;GET THE STACK
	MOVE	TEMP,T1		;CHECK FOR OVERFLOW
	HLR	TEMP,TEMP
	AOJE	TEMP,PDLERR
	MOVE	TEMP,@0(ARG)
	PUSH	T1,TEMP		;PUSH VALUE ON STACK
	MOVEM	T1,STKLOC	;REPLACE STACK
	RETURN


;	CALL POPVAL( IVAL, PDLERR )	RETURN VALUE FROM STACK

	ENTRY	POPVAL
POPVAL:	SETZM	@1(ARG)		;NO PDL UNDERFLOW
	MOVE	T1,STKLOC	;GET STACK
	CAMN	T1,[IOWD 1000,STACK]	;CHECK IF WE HAVE GONE PAST
	GOTO	PDLERR		;YUP
	POP	T1,TEMP		;GET VALUE BACK
	MOVEM	TEMP,@0(ARG)	;RETURN VALUE FROM STACK
	MOVEM	T1,STKLOC	;REPLACE STACK POINTER
	RETURN

PDLERR:	SETOM	@1(ARG)		;INDICATE SOMETHING WENT WRONG
	RETURN


;	ARCOPY( ARRAY1, ARRAY2, SIZE )	COPY ARRAY1 TO ARRAY2

	ENTRY	ARCOPY
ARCOPY:	HRLI	T1,@0(ARG)	;GET STARTING PLACE IN FIRST ARRAY
	HRRI	T1,@1(ARG)	;AND STARTING PLACE IN SECOND ARRAY
	HRRI	TEMP,@1(ARG)	;SET UP BLT INSTRUCTION
	ADD	TEMP,@2(ARG)	;ADD IN SIZE
	SUBI	TEMP,1		;ARRAYS START AT ZERO
	HRLI	TEMP,(BLT T1,)	;SET UP THE INSTRUCTION ITSELF
	XCT	TEMP		;COPY THE ARRAYS
	RETURN


;	CALL ARFILL( ARRAY, SIZE, WORD )	FILL ARRAY WITH WORD

	ENTRY	ARFILL
ARFILL:	MOVE	TEMP,@2(ARG)	;GET WORD TO FILL ARRAY WITH
	MOVEM	TEMP,@0(ARG)	;SET FIRST WORD IN ARRAY TO INITIAL VAL
	HRLI	T1,@0(ARG)	;GET ADDRESS OF ARRAY ON BOTH SIDES
	HRRI	T1,@0(ARG)
	ADDI	T1,1		;SET UP FOR COPY
	MOVEI	TEMP,-2(T1)	;GET ENDING ADDRESS OF BLT
	ADD	TEMP,@1(ARG)	;ADD IN SIZE FOR END
	HRLI	TEMP,(BLT T1,)	;SET UP BLT INSTRUCTION
	XCT	TEMP		;FILL THAT CORE
	RETURN


;	CALL MCALL1( CALLNO, AC, ERRFLG )	EXECUTE MONITOR CALL
;						NUM CALLNO WITH THE
;						VALUE IN AC.

	ENTRY	MCALL1
MCALL1:	SETZM	@2(ARG)		;NO ERROR YET
	MOVE	T1,@0(ARG)	;GET CALLI NUMBER
	HRLI	T1,(CALLI)	;MAKE IT AN INSTRUCTION
	MOVE	TEMP,@1(ARG)	;GET AC
	XCT	T1		;EXECUTE MONITOR CALL
	SETOM	@2(ARG)		;SET ERROR FLAG
	MOVEM	TEMP,@1(ARG)	;RETURN THE AC VALUE
	RETURN

;	CALL MCALL2( CALLNO, AC, ERRFLG, LENGTH, ARRAY )
				;EXECUTE MONITOR CALL NUM CALLNO WITH
				;AC CONSISTING OF LENGTH,,ARRAY
				;AND VALUE RETURNED IN AC

	ENTRY	MCALL2
MCALL2:	SETZM	@2(ARG)		;ASSUME ERROR
	MOVE	T1,@0(ARG)	;GET CALLI NUMBER
	HRLI	T1,(CALLI)	;CONSTRUCT INSTRUCTION
	HRL	TEMP,@3(ARG)	;GET LENGTH
	HRRI	TEMP,@4(ARG)	;GET ADDRESS
	XCT	T1		;EXECUTE MONITOR CALL
	SETOM	@2(ARG)		;FLAG ERROR
	MOVEM	TEMP,@1(ARG)	;RETURN VALUE OF AC
	RETURN


;	I = IGTAB( INDEX, ITABLE )	;RETURN VALUE AT GETTAB TABLE

	ENTRY	IGTAB
IGTAB:	SETZM	ERRFLG		;NO ERROR YET
	HRL	TEMP,@0(ARG)	;GET INDEX
	HRR	TEMP,@1(ARG)	;GET TABLE NUMBER
	GETTAB	TEMP,		;ASK SYSTEM
	SETOM	ERRFLG		;FLAG ERROR
	RETURN

	PRGEND
	TITLE	USRDDT				;PAGE 18
	SEARCH PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
	EXTERN	ERRFLG

	NUMEXT=20
	NUMDEV=177
	NUMMTC=200
	NUMUUO=202
LUOSYM:	BLOCK	40

SYMTAB:	0

	SIXBIT/CMPSL CMPSE CMPSLEEDIT  CMPSGECMPSN CMPSG /
	SIXBIT/CVTDBOCVTDBTCVTBDOCVTBDTMOVSO /
	SIXBIT/MOVST MOVSLJMOVSR XBLT  /

	BLOCK	17

	SIXBIT/CALL  INIT/

	BLOCK	5

	SIXBIT/CALLI OPEN  TTCALL/

	BLOCK	3

	SIXBIT/RENAMEIN    OUT   SETSTSSTATO GETSTSSTATZ INBUF OUTBUF/
	SIXBIT/INPUT OUTPUTCLOSE RELEASMTAPE UGETF USETI USETO LOOKUP/
	SIXBIT/ENTER UJEN  /

	BLOCK	3

	SIXBIT/JSYS  ADJSP /

	BLOCK	2

	SIXBIT/DFAD  DFSB  DFMP  DFDV  DADD  DSUB  DMUL  DDIV  DMOVE /
	SIXBIT/DMOVN FIX   EXTENDDMOVEMDMOVNMFIXR  FLTR  UFA   DFN   /
	SIXBIT/FSC   IBP   ILDB  LDB   IDPB  DPB   FAD   FADL  FADM  /
	SIXBIT/FADB  FADR  FADRI FADRM FADRB FSB   FSBL  FSBM  FSBB  /
	SIXBIT/FSBR  FSBRI FSBRM FSBRB FMP   FMPL  FMPM  FMPB  FMPR  /
	SIXBIT/FMPRI FMPRM FMPRB FDV   FDVL  FDVM  FDVB  FDVR  FDVRI /
	SIXBIT/FDVRM FDVRB MOVE  MOVEI MOVEM MOVES MOVS  MOVSI MOVSM /
	SIXBIT/MOVSS MOVN  MOVNI MOVNM MOVNS MOVM  MOVMI MOVMM MOVMS /
	SIXBIT/IMUL  IMULI IMULM IMULB MUL   MULI  MULM  MULB  IDIV  /
	SIXBIT/IDIVI IDIVM IDIVB DIV   DIVI  DIVM  DIVB  ASH   ROT   /
	SIXBIT/LSH   JFFO  ASHC  ROTC  LSHC  /
	0
	SIXBIT/EXCH  BLT   AOBJP AOBJN GOTO  JFCL  XCT   MAP   PUSHJ /
	SIXBIT/PUSH  POP   POPJ  JSR   JSP   JSA   JRA   ADD   ADDI  /
	SIXBIT/ADDM  ADDB  SUB   SUBI  SUBM  SUBB  CAI   CAIL  CAIE  /
	SIXBIT/CAILE CAIA  CAIGE CAIN  CAIG  CAM   CAML  CAME  CAMLE /
	SIXBIT/CAMA  CAMGE CAMN  CAMG  JUMP  JUMPL JUMPE JUMPLEJUMPA /
	SIXBIT/JUMPGEJUMPN JUMPG SKIP  SKIPL SKIPE SKIPLESKIPA SKIPGE/
	SIXBIT/SKIPN SKIPG AOJ   AOJL  AOJE  AOJLE AOJA  AOJGE AOJN  /
	SIXBIT/AOJG  AOS   AOSL  AOSE  AOSLE AOSA  AOSGE AOSN  AOSG  /
	SIXBIT/SOJ   SOJL  SOJE  SOJLE SOJA  SOJGE SOJN  SOJG  SOS   /
	SIXBIT/SOSL  SOSE  SOSLE SOSA  SOSGE SOSN  SOSG  SETZ  SETZI /
	SIXBIT/SETZM SETZB AND   ANDI  ANDM  ANDB  ANDCA ANDCAIANDCAM/
	SIXBIT/ANDCABSETM  SETMI SETMM SETMB ANDCM ANDCMIANDCMMANDCMB/
	SIXBIT/SETA  SETAI SETAM SETAB XOR   XORI  XORM  XORB  IOR   /
	SIXBIT/IORI  IORM  IORB  ANDCB ANDCBIANDCBMANDCBBEQV   EQVI  /
	SIXBIT/EQVM  EQVB  SETCA SETCAISETCAMSETCABORCA  ORCAI ORCAM /
	SIXBIT/ORCAB SETCM SETCMISETCMMSETCMBORCM  ORCMI ORCMM ORCMB /
	SIXBIT/ORCB  ORCBI ORCBM ORCBB SETO  SETOI SETOM SETOB HLL   /
	SIXBIT/HLLI  HLLM  HLLS  HRL   HRLI  HRLM  HRLS  HLLZ  HLLZI /
	SIXBIT/HLLZM HLLZS HRLZ  HRLZI HRLZM HRLZS HLLO  HLLOI HLLOM /
	SIXBIT/HLLOS HRLO  HRLOI HRLOM HRLOS HLLE  HLLEI HLLEM HLLES /
	SIXBIT/HRLE  HRLEI HRLEM HRLES HRR   HRRI  HRRM  HRRS  HLR   /
	SIXBIT/HLRI  HLRM  HLRS  HRRZ  HRRZI HRRZM HRRZS HLRZ  HLRZI /
	SIXBIT/HLRZM HLRZS HRRO  HRROI HRROM HRROS HLRO  HLROI HLROM /
	SIXBIT/HLROS HRRE  HRREI HRREM HRRES HLRE  HLREI HLREM HLRES /
	SIXBIT/TRN   TLN   TRNE  TLNE  TRNA  TLNA  TRNN  TLNN  TDN   /
	SIXBIT/TSN   TDNE  TSNE  TDNA  TSNA  TDNN  TSNN  TRZ   TLZ   /
	SIXBIT/TRZE  TLZE  TRZA  TLZA  TRZN  TLZN  TDZ   TSZ   TDZE  /
	SIXBIT/TSZE  TDZA  TSZA  TDZN  TSZN  TRC   TLC   TRCE  TLCE  /
	SIXBIT/TRCA  TLCA  TRCN  TLCN  TDC   TSC   TDCE  TSCE  TDCA  /
	SIXBIT/TSCA  TDCN  TSCN  TRO   TLO   TROE  TLOE  TROA  TLOA  /
	SIXBIT/TRON  TLON  TDO   TSO   TDOE  TSOE  TDOA  TSOA  TDON  /
	SIXBIT/TSON  /

	-1
	SIXBIT/LIGHTS/
SYMUUO:	SIXBIT/RESET DDTIN SETDDTDDTOUTDEVCHRDDTGT GETCHRDDTRL WAIT  /
	SIXBIT/CORE  EXIT  UTPCLRDATE  LOGIN APRENBLOGOUTSWITCHREASSI/
	SIXBIT/TIMER MSTIMEGETPPNTRPSETTRPJENRUNTIMPJOB  SLEEP SETPOV/
	SIXBIT/PEEK  GETLINRUN   SETUWPREMAP GETSEGGETTABSPY   SETNAM/
	SIXBIT/TMPCORDSKCHRSYSSTRJOBSTRSTRUUOSYSPHYFRECHNDEVTYPDEVSTS/
	SIXBIT/DEVPPNSEEK  RTTRP LOCK  JOBSTSLOCATEWHERE DEVNAMCTLJOB/
	SIXBIT/GOBSTRACTIV DEACT HPQ   HIBER WAKE  CHGPPNSETUUODEVGEN/
	SIXBIT/OTHUSRCHKACCDEVSIZDAEMONJOBPEKATTACHDAEFINFRCUUODEVLNM/
	SIXBIT/PATH. METER.MTCHR.JBSET.POKE. TRMNO.TRMOP.RESDV.UNLOK./
	SIXBIT/DISK. DVRST.DVURS.XTTSK.CAL11.MTAID.IONDX.CNECT.MVHDR./
	SIXBIT/ERLST.SENSE.CLRST.PIINI.PISYS.DEBRK.PISAV.PIRST.IPCFR./
	SIXBIT/IPCFS.IPCFQ.PAGE. SUSET.COMPT.SCHED.ENQ.  DEQ.  ENQC. /
	SIXBIT/TAPOP.FILOP.CAL78.NODE. ERRPT.ALLOC.PERF. DIAG. DVPHY./
	SIXBIT/GTNTN.GTXTN.ACCT. DTE.  DEVOP.SPPRM.MERGE.UTRP. PIJBI./
	SIXBIT/SNOOP.TSK.  KDP.  QUEUE.RECON./
	-1

UIOTAB:	SIXBIT/BLKI  DATAI BLKO  DATAO CONO  CONI  CONSZ CONSO /

	-1

EX1:	SIXBIT/JRST  PORTALJRSTF /
	0
	SIXBIT/HALT  XJRSTFXJEN  XPCW  /
	SIXBIT/JRST10/
	0
	SIXBIT/JEN   /

	0

	SIXBIT/SFM   /

	BLOCK	3

	-1

EX2:	SIXBIT/JFCL  JFOV  JCRY1 /
	0
	SIXBIT/JCRY0 /
	0
	SIXBIT/JCRY  /
	0
	SIXBIT/JOV   /

	BLOCK	7

	-1

TTSYMS:	SIXBIT/INCHRWOUTCHRINCHRSOUTSTRINCHWLINCHSLGETLCHSETLCH/
	SIXBIT/RESCANCLRBFICLRBFOSKPINCSKPINLIONEOU/

	-1

MTAP:	SIXBIT/MTWAT.MTREW./
	0
	SIXBIT/MTEOF./

	BLOCK	2

	SIXBIT/MTSKR.MTBSR.MTEOT.MTUNL./
	0
	SIXBIT/MTBLK./

	BLOCK	2

	SIXBIT/MTSKF.MTBSF./

	BLOCK	60

	SIXBIT/MTDEC.MTIND./

	BLOCK	76

	SIXBIT/MTLTH./

	-1

APRTAB:	SIXBIT/APRID RSW   WRFIL /
	BLOCK	5
	-1

PITAB:	SIXBIT/RDERA /
	0
	SIXBIT/SBDIAG/
	BLOCK	5
	-1

PAGTAB:	BLOCK	2
	SIXBIT/CLRPT /
	BLOCK	5
	-1

CCATAB:	
	0
	SIXBIT/SWPIA SWPVA SWPUA /
	0
	SIXBIT/SWPIO SWPVO SWPUO /
	-1

TIMTAB:	SIXBIT/RDPERFRDTIMEWRPAE /
	BLOCK	5
	-1

MTRTAB:	SIXBIT/RDMACTRDEACT/
	BLOCK	6
	-1

NEGONE:	-1
IODVTB:	SIXBIT/APR   PI    PAG   CCA   TIM   MTR   ADC2  /

	BLOCK	5

	SIXBIT/DLB   DLC   CLK   CLK2  PTP   PTR   CDP   CDR   TTY   /
	SIXBIT/LPT   DIS   DIS2  PLT   PLT2  CR    CR2   DLB2  DLC2  /
	SIXBIT/DSK   DSK2  DC    DC2   UTC   UTS   MTC   MTS   MTM   /
	SIXBIT/LPT2  DLS   DLS2  DPC   DPC2  DPC3  DPC4  RMC   RMC2  /
	SIXBIT/DCSA  DCSB  /

	BLOCK	2

	SIXBIT/DTC   DTS   DTC2  DTS2  TMC   TMS   TMC2  TMS2  /

	BLOCK	20

	SIXBIT/DSS   DSI   DSS2  DSI2  /

NEGTWO:	-1

LSTTAB:	SYMTAB
	SYMUUO
	UIOTAB
	EX1
	EX2
	TTSYMS
	MTAP
	APRTAB
	PITAB
	PAGTAB
	CCATAB
	TIMTAB
	MTRTAB

INSADD:	0
	047
	7
	254
	255
	051
	072
	1600
	1601
	1602
	1603
	1604
	1605


;	CALL SYMWRD(IWRD,IASSYM,IAC,LIND,IDAC,IDEST)

	ENTRY	SYMWRD
SYMWRD:	SAVE	T10		;SAVE AC'S EXCEPT ARG,STACK
	SAVE	T11
	SAVE	T12
	SAVE	T13
	SAVE	T14
	SAVE	T15
	SETZM	ERRFLG		;INITIALIZE ERRORS
	MOVE	T15,@1(ARG)	;GET SIXBIT INSTRUCTION SYMBOL
	MOVEI	T14,SYMTAB	;INIT WORD POINTER TO FIRST TABLE
	SETZ	T12,		;INIT TABLE COUNTER(NUMBER)
	SETO	T13,		;USES THIS TO CHECK FOR -1.
FNDTAB:	CAMN	T13,(T14)	;IS THE WORD A -1(ENDS SYMBOL BLOCK)?
	GOTO	ENDTAB		;NOT IN THIS TABLE, TRY NEXT 
	CAMN	T15,(T14)	;IS IT THE SAME THING?
	GOTO	FOUND		;THIS IS IT
	AOS	T14		;INCREMENT WORD POINTER.
	GOTO	FNDTAB		;AND TRY AGAIN
ENDTAB:	AOS	T14		;JUST ADD 1,AND WE'RE AT THE NEXT TABLE
	CAMN	T13,(T14)	;IS THE WORD A -1?
	GOTO	SWERR		;OOPS, THAT WAS LAST TABLE, BAD SYMBOL.
	AOS	T12		;INCREMENT NUMBER OF TABLES LOOKED AT
	GOTO	FNDTAB		;AND TRY NEXT TABLE
FOUND:	MOVE	T11,T12		;GET TABLE # INTO FIRST AC
	ADDI	T11,LSTTAB	;GET OFFSET TO TABLE LIST.
	MOVE	T13,T12		;SAVE TABLE # IN SECOND AC FOR PACKING
	ADDI	T13,INSADD	;OFFSET TO PACKING TABLE.
	MOVE	T11,(T11)	;GOT THE TABLE THE SYMBOL IS IN.
	MOVE	T15,(T13)	;CONTAINS THE PACKING VALUE
	SUB	T14,T11		;SUB TABLE FROM POINTR TO GET INS #
	MOVE	T13,T14		;SAVE THE INS # WE NOW HAVE.
	MOVE	T14,T15		;SHIFT ACS
	MOVE	T15,T13		
	JUMPE	T12,SYMPUT	;IS IT A REGULAR INSTRUCTION?
	CAIN	T12,1		;IS IT A UUO?
	GOTO	UUOPUT		;DO IT
	CAIN	T12,2		;IS IT A USER IO INS?
	GOTO	UIOPUT		;TAKE CARE OF THAT
	CAIG	T12,5		;IS IT MTAP,CACHE,OF EXTEND INS?
	CAIGE	T12,3		;IF NOT, IS IT JRST,JFCL, OR TTCALL
	SKIPA
	GOTO	TTPUT		;YUP... GO DO EM(SAME FORMAT FOR ALL)
	CAIN	T12,6		;IS IT A MAGTAP  FUNCTION?
	GOTO	UUOPUT		;YUP...SAME FORMAT AS UUO
	CAIL 	T12,7		;IS IT APR,PI,PAG,ETC.,  SYMBOL?
	GOTO	UIOPUT		;YUP, SUBSET OF USER IO INS SET.
	GOTO	SWERR		;HOW THE HELL DID WE GET HERE? EEEK!
SYMPUT:	MOVE	T14,T15		;GET INS #
	MOVE	T15,@2(ARG)	;GET AC FROM SECOND ARG
	LSH	T15,^D32	;SET IT UP FOR LSHC WITH INS #
	LSHC	T14,4		;LSHC AC OVER WITH INS # ON 14
	GOTO	PTDEST		;GOTO DESTINATION PART OF ROUTINE
UUOPUT:	MOVE	T13,T15		;PUT PACK VAL, NOT INS # IN 13
	MOVE	T15,@2(ARG)	;GET AC FROM SECOND ARG
	LSH	T15,^D32	;PUSH IT OVER
	LSHC	T14,4		;GOT IT LIKE 047<AC>(UUO FORMAT)
	LSH	T14,^D23	;DROP DEST AC AND INDIRECT PART
	HRR	T14,T13		;AND PUT UUO # IN DEST PART, LIKE NORM.
	GOTO	SWRTRN		;RETURN FROM SYMWRD
TTPUT:	LSH	T15,^D32	;IS TTCALL.  INS NUMBER IS AC
	LSHC	T14,4		;SO USE INS NUMBER WITH PACKING VAL(51)
	GOTO	PTDEST		;AND GET DEST PART
UIOPUT:	CAIL	T12,7		;IS IT A CACHE, OR NORMAL USER IO?
	GOTO	PTCACH		;IT'S A CACHE SYMBOL
	MOVE	T13,@2(ARG)	;GET AC VALUE
	CAILE	T13,NUMDEV	;IS IT A LEGAL DEVICE #?
	GOTO	PTDVSM		;NO, BUT MIGHT BE A DEV SYM, NOT #
	JUMPL	T13,PTDVSM	;EXTRA CHECK ON DEVICE #
	LSH	T14,7		;SET UP PACKING VALUE..(7<2=700..)
	ADD	T14,T13		;AND ADD DEV # TO 700 TO MAKE UIO INS
	LSH	T15,^D33	;SHIFT OVER UIO INS TYPE
	LSHC	T14,3		;AND CONCATENATE ONTO 7<DEV#> FOR UIO
	GOTO	PTDEST		;GET DEST PART OF WORD
PTCACH:	LSH	T15,^D33	;CACHE SYMBOL IS ACTUALLY UIO INS TYPE.
	LSHC	T14,3		;CACHE DEV IS 0. JUST MAKE IT 7<0>TYP.
	GOTO	PTDEST		;AND GET DEST
PTDVSM:	SETZ	T12,		;WE HAVE A DEV SYMBOL, NOT #.  GET #
PT2:	LSHC	T12,6		;RIGHT JUSTIFY THE SYMBOL
	JUMPE	T12,PT2
	LSHC	T12,-6		;FIX IT UP, NOW CHECK WITH TABLE
	MOVE	T12,T13		;GET READY FOR COMPARE
	MOVEI	T13,IODVTB	;GET LOC OF DEVICE SYM TABLE
	SETO	T11,		;INIT POINTER
LOOPA:	CAIN	T13,NEGTWO	;IS POINTER = END OF TABLE?
	GOTO	SWERR		;ILLEGAL SYMBOL... DIE,DIE,DIE!!
	CAMN	T12,(T13)	;IS THE SYMBOL WE HAVE THE SAME??
	GOTO	GOTIT		;YUP, GO GET DEVICE # NOW
	AOS	T13		;INCREMENT POINTER.
	GOTO	LOOPA		;GO BACK , LOOK AT NEXT SYM IN TABLE
GOTIT:	SUBI	T13,IODVTB	;SUBTRACT PNTR FROM TABLE TO GET DEV #
	LSH	T14,7		;NOW LSH OVER PACKING VAL(7<=700)
	ADD	T14,T13		;ADD PACKING VAL TO DEV #(7<DEV#>)
	LSH	T15,^D33	;LSH OVER TYPE OF UIO INS
	LSHC	T14,3		;AND CONCATENATE.(7<DEV#>TYP)
	GOTO	PTDEST		;NOW GET DEST 
EXTPUT:	MOVE	T14,T15		;PUT EXTEND FUNCTION IN WORD
	LSH	T14,4		;AC IS ZERO WITH EXTEND FUNCTION
PTDEST:	MOVE	T15,@3(ARG)	;GET INDIRECT BIT.
	LSHC	T14,1		;IF ARG3 T(-1),THEN 1,0 IF FALSE(0)
	MOVE	T15,@4(ARG)	;GET DEST AC 
	LSH	T15,^D32	;PUT IT IN HIGH 4 BITS OF T15,
	LSHC	T14,4		;AND CONCATENATE.
	HRLZ	T15,@5(ARG)	;GET Y FROM ARG LIST
	LSHC	T14,^D18	;AND CONCATENATE
SWRTRN:	MOVEM	T14,@0(ARG)	;PUT THE CREATED WORD IN ARG.
	SKIPA			;DON'T SET THE ERROR FLAG.
SWERR:	SETOM	ERRFLG		;IF CALLED, SET ERROR BIT
	RESTORE	T15		;POP ALL AC'S PUSHED IN THE SAVE
	RESTORE	T14
	RESTORE	T13
	RESTORE	T12
	RESTORE	T11
	RESTORE	T10
	RETURN			;AND RETURN.


;	CALL WRDSYM(IWRD,IASSYM,IAC,LIND,IDAC,IDEST[,ISIMPL])
;	IF ISIMPL = .TRUE. THEN USE SIMPLEST SYMBOL FORMAT POSSIBLE
;	IF ISIMPL = .FALSE. IS NORMAL.  USE ALL SYMBOLS AVA
;	IF ISIMPL = -2, SAME AS .TRUE., EXCEPT USE UIO DEVICE SYMBOLS.

	ENTRY	WRDSYM
WRDSYM:	SAVE	T10		;PUSH ALL AC'S EXCEPT ARG,STACK
	SAVE	T11
	SAVE	T12
	SAVE	T13
	SAVE	T14
	SAVE	T15
	SETZ	12,
	HLRO	T14,0(ARG)	;GET # OF ARGUMENTS
	MOVN	T14,T14
	CAIL	T14,6		;EXTRA FLAG THERE??(ISIMPL)
	MOVE	T12,@6(ARG)	;IF SO, GET VALUE OF FLAG
	MOVE	T15,@0(ARG)	;GET WORD TO BE BROKEN DOWN
	SETZ	T14,		;CLEAN UP FOR LSHC
	LSHC	T14,3		;GET HIGH DIGIT
	CAIN	T14,7		;IF IT'S A 7
	GOTO	UIOGET		;IT'S A USER IO INSTRUCTION
	LSHC	T14,6		;IF NOT, GET REST OF INS #
	SKIPGE	T12		;FLAG SET?
	GOTO	NRMINS		;THE PERSON WANTS SIMPLEST SYM TYPE.
	CAIN	T14,047		;IS IT A UUO?
	GOTO	UUOGET		;YUP, GOT DO IT
	CAIN	T14,254		;IS IT A JRST
	GOTO	JRSTGT		;DO IT
	CAIN	T14,255		;A JFCL?
	GOTO	JFCLGT		;DO IT
	CAIN	T14,051		;A TTCALL?
	GOTO	TTGET		;DO IT
	CAIN	T14,072		;A MAGTAP FUNCTION?
	GOTO	MTGET		;DO IT
	CAILE	T14,677		;NOT NEGATIVE?
	GOTO	WSERR		;OOPS,  ONLY A MERE NUMBER
NRMINS:	ADDI	T14,SYMTAB	;A NORMAL INS, ADD TABLE TO INS #
	MOVE	T11,(T14)	;GET THE SIXBIT SYMBOL AT THAT LOC
	MOVEM	T11,@1(ARG)	;AND MOVE IT TO FIRST ARG(INS SYM)
	SETZ	T14,		;CLEAN UP AC FOR LSHC
	LSHC	T14,4		;NOW GET AC(NOT DEST AC)
	MOVEM	T14,@2(ARG)	;ZAP THAT INTO SECOND ARG
GTDEST:	SETZ	T14,		;CLEAN IT UP FOR NEXT LSHC
	LSHC	T14,1		;GET IND BIT
	SETZM	@3(ARG)		;SET 3RD ARG TO ZERO(FALSE)
	CAIN	T14,1		;AND IF IT IS INDIRECT
	SETOM	@3(ARG)		;SET IT TO -1(TRUE)
	SETZ	T14,		;ELSE LEAVE IT.  CLEAN IT UP
	LSHC	T14,4		;GET DESTINATION AC
	MOVEM	T14,@4(ARG)	;MOVE THAT TO 4TH ARG
	HLRZM	T15,@5(ARG)	;AND PUT Y OF DEST IN 5TH ARG
	GOTO	WSRTRN		;WE IS DONE WITH NORM INSTRUCTION
UIOGET:	SETZ	T14,		;HMM, IS A UIO, NOW GET DEV
	LSHC	T14,7		;DEVICE # IS 7 BITS
	SKIPGE	T12		;FLAG SET?
	GOTO	UIOFIX		;USE SIMPLEST UIO SYM TYPE 
	CAIG	T14,5		;IF THE DEV# IS < 5, USE APR,PI,PAG TAB
	GOTO	GTCACH		;DO IT
UIOFIX:	CAML	T12,NEGONE	;SIMPLEST FORMAT+UIO DEV SYMBOLS?
	SKIPL	T12		;SIMPLEST FORMAT
	SKIPA
	GOTO	BACK		;DON'T USE DEVICE SYMBOLS
	CAIG	T14,NUMDEV	;WITHIN LIMITS FOR DEFINED DEVICES?
	GOTO	GTDVSM		;YUP, GO USE IT
BACK:	MOVEM	T14,@2(ARG)	;# TO 2ND ARG, NO DEV SYMBOL
BACK2:	SETZ	T14,		;CLEAR IT FOR A LSHC
	LSHC	T14,3		;GET TYPE OF UIO,(CONI,CONO,ETC.)
	ADDI	T14,UIOTAB	;GET THE INS # TO TABLE SO
	MOVE	T11,(T14)	;WE CAN GET THE SYMBOL FOR THAT INS.
	MOVEM	T11,@1(ARG)	;AND MOVE IT TO INSTRUCTION ARGUMENT
	GOTO	GTDEST		;AND GO DUMP DESTINATION LIKE USUAL
GTCACH:	MOVE	T11,T14		;SAVE DEV NUM, JUST IN CASE
	MOVE	T13,T14		;GET OFFSET VAL FROM LSTTAB
	ADDI	T13,LSTTAB+7
	MOVE	T13,(T13)
	SETZ	T14,		;SET UP FOR NEXT LSHC
	LSHC	T14,3		;GET THE INSTYPE(CONI,CONO,ETC.)
	ADD	T13,T14		;ADD OFFSET SO WE CAN GET SYMBOL
	SKIPN	(T13)		;IS THERE A SYM THERE???
	GOTO	NTCACH		;NULL SYMBOL, SYM NOT DEFINED
	MOVE	T11,(T13)	;SYMBOL TABLE.  GET SPECIAL SYMBOL
	MOVEM	T11,@1(ARG)	;AND PUT THAT IN INS ARG INSTEAD 
	SETZM	@2(ARG)		;SET THE DEVICE ARG TO ZERO(NO DEV #)
	GOTO	GTDEST		;AND GET DEST PART LIKE USUAL
NTCACH:	LSHC	T14,-3		;HMM, JUST PUSH INS TYPE BACK IN
	MOVE	T14,T11		;GET DEV # BACK INTO 14 FOR NORM UIO
	GOTO	UIOFIX		;DUMP IT AS A REGULAR UIO INS
GTDVSM:	CAILE	T14,NUMDEV	;HUMM... CAN WE CAN CONVERT TO SYMBOL?
	GOTO	WSERR		;GUESS NOT
	ADDI	T14,IODVTB	;ADD DEVICE TABLE TO # SO
	MOVE	T11,(T14)	;WE CAN GET DEV SYMBOL. BETTER THAN #!
	JUMPN	T11,SYMOK	;IF THERE IS A SYMBOL THERE... ETC
	SUBI	T14,IODVTB	;SUBTRACT TABLE
	GOTO	BACK		;GUESS WE'VE GOTTA USE THE #, GRR
SYMOK:	MOVEM	T11,@2(ARG)	;PUT IT IN AC ARG
	GOTO	BACK2		;AND GO BACK TO GET TYP OF UIO INS
UUOGET:	SETZ	T14,		;THIS IS FOR UUOS.  CLEAR AC
	LSHC	T14,4		;AND GET AC
	MOVEM	T14,@2(ARG)	;PUT IT IN AC ARG
	SETZM	@3(ARG)		;CALLI'S ARE IMMEDIATE.  NO IND BIT.
	SETZM	@4(ARG)		;ALSO NO DEST ACCUMULATOR
	SETZM	@5(ARG)		;NO DEST LOCATION
	LSHC	T14,5		;SHIFT OVER IND BIT, AND DEST AC
	SETZ	T14,		;AND DUMP EM.  CLEAR AC
	LSHC	T14,^D18	;GET NUMBER OF THE UUO
	CAIN	T14,777777	;MAKE SURE IT'S NOT THE LIGHTS UUO
	GOTO	GETLGT		;ELSE TAKE CARE OF SPECIAL INSTANCE
	CAILE	T14,NUMUUO	;IS IT LE LEGAL # OF UUOS?
	GOTO	WSERR		;NOPE.  NOT A LEGAL UUO
	SKIPA			;SKIP THE NEXT INSTRUCTION
GETLGT:	MOVE	T14,NEGONE	;AND MAKE IT A -1, NOT 0,,777777.
	ADDI	T14,SYMUUO	;ADD UUO SYM TABLE
	MOVE	T11,(T14)	;AND GET SYMBOL AT THAT LOCATION
	MOVEM	T11,@1(ARG)	;PUT IT IN THE INSTRUCTION ARG
	GOTO	WSRTRN		;AAND WE IZ DONE WITH UUO
JRSTGT:	SETZ	T14,		;SPECIAL JRSTS, CLEAR
	LSHC	T14,4		;GET AC #.  DEFINES TYPE OF JRST
	ADDI	T14,EX1		;ADD JRST TABLE
	MOVE	T11,(T14)	;GET SYMBOL THERE
	MOVEM	T11,@1(ARG)	;MOVE IT TO INS ARG
	SETZM	@2(ARG)		;NO AC IN JRST, ZERO IT
	GOTO	GTDEST		;AND GET THE DESTINATION
JFCLGT:	SETZ	T14,		;SPECIAL JFCLS
	LSHC	T14,4		;AC DEFINES TYPE OF JFCL
	ADDI	T14,EX2		;ADD TABLE TO MAKE IT A OFFSET
	MOVE	T11,(T14)	;GET THE SYMBOL AT THE LOCATION
	MOVEM	T11,@1(ARG)	;AND PUT IN THE INS ARGUMENT
	SETZM	@2(ARG)		;NO AC FOR JFCLS EITHER
	GOTO	GTDEST		;GO GET THE DESTINATION
TTGET:	SETZ	T14,		;TTCALLS... DROP INS #
	LSHC	T14,4		;GET AC #
	ADDI	T14,TTSYMS	;WHICH DEFINES WHAT TYPE OF TTCALL
	MOVE	T11,(T14)	;GET THE SYMBOL
	MOVEM	T11,@1(ARG)	;SAVE IT IN THE INSTRUCTION ARG
	SETZM	@2(ARG)		;NO AC'S IN TTCALLS... ZERO THE ARG
	GOTO	GTDEST		;AND GET THE DESTINATION
MTGET:	SETZ	T14,		;SET UP FOR MTCALLS
	LSHC	T14,4		;GET THE AC #
	MOVEM	T14,@2(ARG)	;PUT IT IN ARGUMENT
	LSHC	T14,5		;DROP THE INDBIT,DEST AC
	SETZ	T14,		;CUZ MTCALL R JUST SPECIAL SUBSET OF
	LSHC	T14,^D18	;UUOS.  GET NUMBER OF MTCALL
	CAILE	T14,NUMMTC	;SEE IF IT IS A LEGAL MTCALL
	GOTO	WSERR		;NOPE.  ERROR!
	ADDI	T14,MTAP	;ADD TABLE LOC TO MAKE OFFSET
	MOVE	T11,(T14)	;AND GET SYMBOL AT THAT LOCATION
	MOVEM	T11,@1(ARG)	;SAVE IT AS AN INSTRUCTION.
	SETZM	@3(ARG)		;SET IND BIT TO FALSE(NONE)
	SETZM	@4(ARG)		;NO DEST AC.  ZERO IT.
	SETZM	@5(ARG)		;NO DEST LOCATION.  ZERO IT.
	GOTO	WSRTRN		;DONE WITH MTCALL
WSERR:	SETZM	@1(ARG)		;ERROR.  ZERO ALL RETURNED ARGUMENTS.
	SETZM	@2(ARG)		;ETC.
	SETZM	@3(ARG)		;ETC.
	SETZM	@4(ARG)
	SETZM	@5(ARG)
WSRTRN:	RESTORE	T15		;POP ALL AC'S PUSHED
	RESTORE	T14
	RESTORE	T13
	RESTORE	T12
	RESTORE	T11
	RESTORE	T10
	RETURN			;AND RETURN TO CALLING PROGRAM

	PRGEND
	TITLE	RANDOM				;PAGE 19
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>
;	I = IRAN( IRANGE )	RETURN RANDOM INTEGER BETWEEN
;				1 AND IRANGE

	ENTRY	IRAN
IRAN:	FLTR	TEMP,@0(ARG)	;RANGE NEEDS TO BE REAL FOR ARAN
	MOVEM	TEMP,RANGE	;PUT IN ARG BLOCK
	CALL	RANENT		;GET THE RANDOM NUMBER
	FIX	TEMP,TEMP	;RESULT IS SUPPOSED TO BE INTEGER
	AOS	TEMP		;STARTING AT 1
	RETURN


;	A = ARAN( RANGE )	RETURN REAL NUMBER BETWEEN 0 AND RANGE

	ENTRY	ARAN
ARAN:	MOVE	TEMP,@0(ARG)	;GET RANGE
	MOVEM	TEMP,RANGE	;AND REMEMBER IT
RANENT:	SKIPE	NMTHRU		;IF WE'VE BEEN THROUGH LATELY
	GOTO	NOSET		;NO POINT IN GETTING A NEW SEED
SETRAN:	SETOM	NMTHRU		;FLAG SO NO NEW SEED EACH TIME
	MSTIME	TEMP,		;AND GET A NEW SEED
	HRRZ	TEMP,TEMP	;ONLY GET THE RIGHT SIDE
	TLZ	TEMP,760000	;MAKE SURE NO OVERFLOW
	JUMPE	TEMP,SETRAN	;DON'T WANT ZERO
	MOVEM	TEMP,SEED	;REMEMBER THE SEED
NOSET:	MOVE	TEMP,K		;GET FUDGE FACTOR
	MUL	TEMP,SEED	;FUDGE THE SEED
	ASHC	TEMP,4		;SHIFT IT (WHY NOT?)
	LSH	T1,-4		;AND RESET RESULTNG AC
	ADD	TEMP,T1		;PUT THE TWO TOGETHER
	TLZE	TEMP,760000	;MAKE SURE NO OVERFLOW
	AOS	TEMP		;INSURE NOT EXACTLY ZERO
	MOVEM	TEMP,SEED	;STORE RESULTING SEED
	HLRZ	T1,TEMP		;GET SOME OF THE VALUE FOR THE WORD
	FSC	T1,216		;KEEP IT IN RANGE
	HRRZ	TEMP,TEMP	;FUDGE OTHER SIDE
	FSC	TEMP,174	;KEEP IN IN RANGE
	FAD	TEMP,T1		;CONSTRUCT AC
	FMP	TEMP,RANGE	;MULTIPLY IT BY RANGE
	RETURN

IFE %HISEG,	<RELOC>		;LOW
K:	4544,,503720		;GETS START OF RANDOM SEQUENCE
SEED:	0			;GETS SEED FOR RANDOM SEQUENCE
NMTHRU:	0			;NUMBER TIMES THROUGH ROUTINE
RANGE:	0			;RANGE GOES HERE
IFE %HISEG,	<RELOC>		;HIGH
	PRGEND

;DISABLED	TITLE	UPP				;PAGE 20
;DISABLED	IFN %HAVEPLOT,<
;DISABLED		SEARCH	PACK, UUOSYM, FORPRM, PLT936
;DISABLED	
;DISABLED	;	UNIVERSAL PLOTTING PACKAGE
;DISABLED	;	CURRENTLY DEFINED PLOTTERS:
;DISABLED	;	ARRAY, INTECOLOR (ISC), TEKTRONIX AND CALCOMP
;DISABLED	
;DISABLED	IFE %HISEG,	<TWOSEG	400000>
;DISABLED	
;DISABLED	
;DISABLED		NUMDEF=3		;MAX # DEFINED PLOTTERS
;DISABLED	
;DISABLED		DEFINE	FATAL( MESSAG )	;FATAL ERROR MACRO
;DISABLED	<	GOTO	[
;DISABLED		SKIPE	PLTMOD
;DISABLED		IONEOU	EXIPLT
;DISABLED		OUTSTR	[ASCIZ/?UPP'MESSAGE
;DISABLED	/]
;DISABLED		EXIT				] >
;DISABLED	
;DISABLED	
;DISABLED	
;DISABLED		DEFINE	WAIT( TIMES, ICHAR, %WLOOP )	;LET DEVICE CATCH UP
;DISABLED	<	MOVEI	T15,TIMES
;DISABLED	%WLOOP:	MOVEI	T1,ICHAR
;DISABLED		CALL	FILPCL
;DISABLED		SOJG	T15,%WLOOP		>
;DISABLED	
;DISABLED	
;DISABLED	
;DISABLED	ENT:	0			;CODES GOING IN ENTPLT
;DISABLED		^D2			;INTECOLOR (ISC)
;DISABLED		^D29			;TEKTRONIX
;DISABLED		0			;CALCOMP
;DISABLED	
;DISABLED	EXI:	0			;CODES GOING IN EXIPLT
;DISABLED		^D255			;INTECOLOR (ISC)
;DISABLED		^D13			;TEKTRONIX
;DISABLED		0			;CALCOMP
;DISABLED	
;DISABLED	TEKDIM:	780.0			;WIDTH OF TEKTRONIX
;DISABLED	CALDIM:	6120.0			;WIDTH OF CALCOMP
;DISABLED	SIZGRD:	8.0			;SIZE OF CHAR GRID
;DISABLED	
;DISABLED	STAPUT:	999.0			;MEANS USE LAST COORDINATE TO START
;DISABLED	
;DISABLED	IFE %HISEG,	<RELOC>		;LOW
;DISABLED	
;DISABLED	PLTADR:	0			;HOLDS ADDRESS OF PLOT ARRAY
;DISABLED	MAXFX:	0			;MAX X FOR FILE
;DISABLED	MAXFY:	0			;MAX Y FOR FILE
;DISABLED	FLXDIM:	0			;MAX X FOR BRESHAM'S ALGORITHM
;DISABLED	FLYDIM:	0			;MAX Y FOR BRESHAM'S ALGORITHM
;DISABLED	ARACOL:	ASCII/.    /		;COL TO PUT THERE
;DISABLED	
;DISABLED	CHRTBL:	TBL1			;ADDRESS OF CURRENT
;DISABLED					;CHAR TABLE
;DISABLED	
;DISABLED	ENTPLT:	0			;CODES GO HERE TO
;DISABLED	EXIPLT:	0			;ENTER & EXIT PLOT MODE
;DISABLED	
;DISABLED	CUR.X:	0			;CURRENT PEN X & Y
;DISABLED	CUR.Y:	0
;DISABLED	OLD.X:	0			;OLD X & Y POSITION
;DISABLED	OLD.Y:	0
;DISABLED	
;DISABLED	ORG.X:	0			;X & Y ORIGIN
;DISABLED	ORG.Y:	0
;DISABLED	
;DISABLED	FACTOR:	0			;USER'S SIZE FACTOR
;DISABLED	
;DISABLED	X.OFF:	0			;X & Y OFFSETS
;DISABLED	Y.OFF:	0
;DISABLED	
;DISABLED	X.FACT:	1.0			;X & Y OFFSET FACTORS
;DISABLED	Y.FACT:	1.0
;DISABLED	
;DISABLED	PLTMOD:	0			;TRUE IN PLOTTING MODE
;DISABLED	PLOTYP:	-1			;PLOTTER (0 TO NUMDEF)
;DISABLED	PLTCHN:	0			;WHAT IS OUTPUT DEV?
;DISABLED	
;DISABLED	MAXX:	0			;MAX X COORD REACHED
;DISABLED	
;DISABLED	SAVCOS:	0			;FACTORS FOR PLTSYM
;DISABLED	SAVSIN:	0
;DISABLED	
;DISABLED	MOVFLG:	0			;TRUE IF MOVE IN PLTSYM
;DISABLED	PLTSX:	0			;SAVE COORDS FOR PLTSYM
;DISABLED	PLTSY:	0
;DISABLED	
;DISABLED	CENTER:	0			;IS SYMBOL CENTERED?
;DISABLED	
;DISABLED					;ARGS TO CALL PLTSYM
;DISABLED	STRCHR:	0			;CHAR TO PLOT
;DISABLED	STRX:	0			;X TO PLOT AT
;DISABLED	STRY:	0			;Y TO PLOT AT
;DISABLED	STRHGH:	0			;HEIGHT OF CHAR
;DISABLED	STRANG:	0			;ANGLE OF CHAR
;DISABLED	
;DISABLED	PBPTR:	0			;BYTE PTR TO STRING
;DISABLED	
;DISABLED	NDEC:	0			;NUM DIGS TO RIGHT OF .
;DISABLED	
;DISABLED	CTOUT:	0			;CHAR TO OUTPUT TO WHATEVER DEVICE
;DISABLED	
;DISABLED	;************* DEVICE INFORMATION FOR CALCOMP ***************
;DISABLED	
;DISABLED	PENPTR:	0			;BYTE PTR FOR PEN INSTR
;DISABLED	CALOPN:	0			;OPENNED CALCOMP?
;DISABLED	
;DISABLED	PLTOPN:	0			;PLACES FOR XCT OPS
;DISABLED	PLTENT:	0
;DISABLED	PLTOUT:	0
;DISABLED	PLTCLS:	0
;DISABLED	
;DISABLED	IFE %HISEG,	<RELOC>		;HIGH
;DISABLED	
;DISABLED					;OPEN BLOCK
;DISABLED	PLTDEV:	10			;IMAGE MODE
;DISABLED		SIXBIT/PLT01/
;DISABLED		OUTHDR,,0
;DISABLED	
;DISABLED	PLTFIL:	SIXBIT/PLOT/		;ENTER BLOCK
;DISABLED		SIXBIT/DAT/
;DISABLED		BLOCK	2
;DISABLED	
;DISABLED	IFE %HISEG,	<RELOC>		;LOW
;DISABLED	OUTHDR:	BLOCK	1		;BUFFER BLOCK
;DISABLED	OUTPTR:	BLOCK	1
;DISABLED	OUTCNT:	BLOCK	1
;DISABLED	IFE %HISEG,	<RELOC>		;HIGH
;DISABLED	
;DISABLED	
;DISABLED	;******************** CALCOMP I/O ROUTINES *********************
;DISABLED	
;DISABLED	;INITTING CALCOMP PLOTTER.  FIND A FREE CHANNEL AND OPEN IT UP.
;DISABLED	
;DISABLED	INICAL:	MOVE	TEMP,MAXX	;PLOT ON NEXT SCREEN
;DISABLED		FADR	TEMP,[0.1]	;ADD A TINY MARGIN
;DISABLED		MOVEM	TEMP,ORG.X
;DISABLED		SKIPE	CALOPN		;IF PLOTTER OPENNED
;DISABLED		RETURN			;DON'T DO IT AGAIN
;DISABLED		SETOM	CALOPN		;FLAG THAT WE'VE BEEN
;DISABLED		MOVE	TEMP,PLTCHN	;GET PLOTTING CHN
;DISABLED		LSH	TEMP,27		;FUDGE TO AC FIELD
;DISABLED		MOVE	T1,[OPEN	PLTDEV]	;REMEMBER OPERATIONS
;DISABLED		IOR	T1,TEMP		;ADD IN CHANNEL
;DISABLED		MOVEM	T1,PLTOPN	;AND MAKE THAT THE OPEN INSTRUCTION
;DISABLED		MOVE	T1,[ENTER	PLTFIL]	;SET UP FOR ENTER
;DISABLED		IOR	T1,TEMP		;ADD IN CHANNEL
;DISABLED		MOVEM	T1,PLTENT	;AND MAKE THAT THE INSTRUCTION
;DISABLED		HRLZI	T1,(OUT)	;GET AN OUT INSTRUCTION
;DISABLED		IOR	T1,TEMP		;GIVE IT A CHANNEL
;DISABLED		MOVEM	T1,PLTOUT	;AND REMEMBER IT FOR DUMBUF
;DISABLED		HRLZI	T1,(RELEAS)	;GET A RELEASE INSTRUCTION
;DISABLED		IOR	T1,TEMP		;GIVE IT A CHANNEL
;DISABLED		MOVEM	T1,PLTCLS	;AND REMEMBER IT FOR PCLOSE
;DISABLED		XCT	PLTOPN		;GO OPEN PLOTTER
;DISABLED		FATAL(CNO CAN NOT OPEN PLOTTER)
;DISABLED		LSH	TEMP,-27	;GET IT BACK
;DISABLED		DEVTYP	TEMP,		;CAN WE HANDLE IT?
;DISABLED		GOTO	PLTSPL		;ASSUME NOT SPOOLED
;DISABLED		TLNN	TEMP,400000	;DIRECTORY DEVICE?
;DISABLED		GOTO	NOTDIR		;NOPE
;DISABLED		XCT	PLTENT		;IF SO, OPEN FILE
;DISABLED		FATAL(CNO CAN NOT OPEN PLOT.DAT)	;OOPS
;DISABLED		GOTO	SETPLT		;NOW MAKE SURE AT 0,0
;DISABLED	
;DISABLED	NOTDIR:	TLNN	TEMP,20		;IS DEVICE SPOOLED
;DISABLED	PLTSPL:	FATAL(CNH CAN NOT HANDLE NON SPOOLED PLOTTER)	;NOPE
;DISABLED	
;DISABLED	SETPLT:	SETZB	TEMP,MAXX	;SINCE NEW PLOT
;DISABLED		SETZM	ORG.X		;CLEAR OLD VALUES
;DISABLED		MOVEI	T1,3		;MAKE SURE ITS A MOVE
;DISABLED					;GOTO OUTCAL (PEN 0,0)
;DISABLED	
;DISABLED	;********** OUTCAL: DUMP PEN INSTRUCTION AND X-Y TO CALCOMP **********
;DISABLED	
;DISABLED	OUTCAL:	SOSG	OUTCNT		;ANY SPACE IN BUFFER?
;DISABLED		CALL	DUMBUF		;NOPE.  DUMP IT AND GET A NEW ONE.
;DISABLED		IDPB	T1,PENPTR	;OTHERWISE, STICK PEN CODE IN BUFFER
;DISABLED		IDPB	TEMP,OUTPTR	;AND POSITION IN OTHER PART OF BUFFER
;DISABLED		RETURN
;DISABLED	
;DISABLED	DUMBUF:	XCT	PLTOUT		;DUMP THAT PLOT BUFFER
;DISABLED	
;DISABLED	;THE FOLLOWING CODE SPLITS THE 128 WORK BUFFER INTO TWO DISTINCT
;DISABLED	;SECTIONS FOR SPOOLING.  THE FIRST SECTION IS 10 WORDS OF 3-BIT
;DISABLED	;BYTES OF PEN INFORMATION.  THE SECOND SECTION IS HALFWORD VALUES OF
;DISABLED	;DELTA X, DELTA Y IN THOUSANTHS OF AN INCH INTEGERS.
;DISABLED	
;DISABLED	;ALSO, THE FIRST WORD OF EACH BUFFER IS ZERO TO SPECIFY THIS AS A
;DISABLED	;SPOOLED PLOT BUFFER.
;DISABLED	;THIS ALLOWS FOR 117 PLOT COMMANDS PER BLOCK.
;DISABLED	
;DISABLED		SAVE	TEMP
;DISABLED		SAVE	T1
;DISABLED		HRR	T1,OUTPTR	;GET INDEX INTO BUFFER
;DISABLED		MOVE	TEMP,[VALIDF]	;GET VALIDITY CODE
;DISABLED		MOVEM	TEMP,1(T1)	;MAKE SURE IT HEADS BUFFER
;DISABLED		HRLI	T1,(POINT 3,0,35)	;SET UP FOR NEW BYTE POINTER
;DISABLED		ADDI	T1,1		;FOR OUTCAL
;DISABLED		MOVEM	T1,PENPTR	;TO PUT IN PEN CODES
;DISABLED		HRLI	T1,(POINT 36,0,35)	;AND SET UP NEW BYTE POINTER
;DISABLED		ADDI	T1,^D10		;FOR OUTCAL
;DISABLED		MOVEM	T1,OUTPTR	;TO PUT IN PEN POSITIONS
;DISABLED		MOVEI	T1,^D117	;GET SIZE OF BUFFER
;DISABLED		HRRM	T1,OUTCNT	;AND MAKE SURE MONITOR KNOWS IT
;DISABLED		RESTORE	T1
;DISABLED		RESTORE	TEMP
;DISABLED		RETURN
;DISABLED	
;DISABLED	;*************************************************************
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PLOTON( ITYPE, ICHAN )	SET TYPE AND OUTPUT CHANNEL
;DISABLED	;					FOR OUTPUT.  0:ARRAY,
;DISABLED	;					1:ISC, 2:TEK, 3:CAL.
;DISABLED	
;DISABLED		ENTRY	PLOTON
;DISABLED	PLOTON:	SKIPE	PLTMOD		;ARE WE IN PLOT MODE
;DISABLED		FATAL(CSD CAN NOT SWITCH DEVICES WITHOUT CALLING PEXIT.)
;DISABLED		MOVN	T1,-1(ARG)	;GET NUMBER OF ARGS
;DISABLED		HLRZ	T1,T1		;ON RIGHT HALF
;DISABLED		CAIE	T1,2		;IS IT LEGAL
;DISABLED		FATAL(MH1 MUST HAVE 2 ARGUMENTS FOR ROUTINE PLOTON.)
;DISABLED		SKIPGE	T1,@1(ARG)	;GET OUT CHANNEL
;DISABLED		FATAL(CNE CHANNEL NOT LEGAL.)
;DISABLED		MOVEM	T1,PLTCHN	;REMEMBER IT
;DISABLED		SKIPL	T1,@0(ARG)	;GET PLOTTER TYPE
;DISABLED		CAILE	T1,NUMDEF	;IS IT IN RANGE
;DISABLED		FATAL(PND PLOTTER TYPE NOT DEFINED.)
;DISABLED		MOVEM	T1,PLOTYP	;REMEMBER IT
;DISABLED		SETZM	ORG.X		;SET DEFAULTS
;DISABLED		SETZM	ORG.Y
;DISABLED		SETOM	CUR.X
;DISABLED		SETOM	CUR.Y
;DISABLED		HRLZI	TEMP,(1.0)
;DISABLED		MOVEM	TEMP,FACTOR
;DISABLED		MOVE	TEMP,ENT(T1)	;SET UP PLOTTING CODES
;DISABLED		MOVEM	TEMP,ENTPLT
;DISABLED		MOVE	TEMP,EXI(T1)
;DISABLED		MOVEM	TEMP,EXIPLT
;DISABLED		CAIN	T1,3		;IF CALCOMP
;DISABLED		GOTO	INICAL		;GO INIT IT.
;DISABLED		RETURN			;NO FURTHER INITTING
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PDEFAR( ARRAY, MAXX, MAXY )	DEFINE ARRAY TO PLOT ON
;DISABLED	;						IF PLOTYP IS ARRAY
;DISABLED	
;DISABLED		ENTRY	PDEFAR
;DISABLED	PDEFAR:	SKIPE	PLTMOD		;CAN'T SET TYPE IN PLOT MODE
;DISABLED		FATAL(CCA CANNOT CHANGE ARRAYS WHILE IN PLOT MODE.')
;DISABLED		MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;IN RIGHT HALF
;DISABLED		CAIE	TEMP,3		;MUST HAVE 3 ARGS
;DISABLED		FATAL(MH3 MUST HAVE 3 ARGUMENTS FOR ROUTINE PDEFAR.)
;DISABLED		MOVEI	TEMP,@0(ARG)	;GET ARRAY ADDRESS
;DISABLED		MOVEM	TEMP,PLTADR	;REMEMBER IT
;DISABLED		MOVE	TEMP,@1(ARG)	;GET MAXIMUM X
;DISABLED		MOVEM	TEMP,MAXFX	;REMEMBER IT FOR BRESHAM'S ALGORITHM
;DISABLED		FLTR	TEMP,TEMP	;MAKE IT REAL
;DISABLED		MOVEM	TEMP,FLXDIM	;AND MAKE IT THE DIMENSION
;DISABLED		MOVE	TEMP,@2(ARG)	;GET MAXIMUM Y
;DISABLED		MOVEM	TEMP,MAXFY	;REMEMBER IT FOR BRESHAM'S ALGORITHM
;DISABLED		FLTR	TEMP,TEMP	;MAKE IT REAL
;DISABLED		MOVEM	TEMP,FLYDIM	;AND MAKE IT THE DIMENSION
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PENTER		ENTER PLOTTING MODE
;DISABLED	
;DISABLED		ENTRY	PENTER
;DISABLED	PENTER:	SKIPGE	PLOTYP		;HAVE WE SET OUR TYPE YET?
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PENTER.)
;DISABLED		SKIPE	PLTMOD		;ARE WE IN PLOT MODE?
;DISABLED		FATAL(PAC PENTER ALREADY CALLED.)
;DISABLED		HLRZ	TEMP,-1(ARG)	;GET NUMBER OF ARGS
;DISABLED		SKIPE	TEMP		;IF NOT ZERO, SOMEBODY BLEW IT
;DISABLED		FATAL(PTN PENTER TAKES NO ARGUMENTS.)
;DISABLED		SKIPE	T1,ENTPLT	;OTHERWISE, GET CHAR TO OUTPUT
;DISABLED		CALL	FILPCL		;AND DUMP IT IF NOT ZERO
;DISABLED		SETOM	PLTMOD		;FLAG THAT WE ARE PLOTTING MODE
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PORG( X, Y )	SET ORIGIN
;DISABLED	
;DISABLED		ENTRY	PORG
;DISABLED	PORG:	SKIPN	PLTMOD		;MUST BE IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PORG.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,2
;DISABLED		FATAL(MH2 MUST HAVE 2 ARGUMENTS FOR ROUTINE PORG.)
;DISABLED		MOVE	TEMP,@0(ARG)	;GET VALUES
;DISABLED		FMPR	TEMP,FACTOR	;SCALE THEM
;DISABLED		FADRM	TEMP,ORG.X	;ADD TO THE ORIGIN
;DISABLED		MOVE	TEMP,@1(ARG)
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		FADRM	TEMP,ORG.Y
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PFACTR( FACTOR )	SET SCALE FACTOR
;DISABLED	
;DISABLED		ENTRY	PFACTR
;DISABLED	PFACTR:	SKIPN	PLTMOD		;CHECK IF WE ARE IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PFACTR.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,1
;DISABLED		FATAL(MH1 MUST HAVE 1 ARGUMENTS FOR ROUTINE PFACTR.)
;DISABLED		MOVE	TEMP,@0(ARG)	;GET PLOTTING FACTOR
;DISABLED		FMPRM	TEMP,FACTOR	;AND SCALE BY THAT MUCH
;DISABLED		SKIPE	TEMP		;IF SCALING TO SIZE ZERO
;DISABLED		RETURN
;DISABLED		HRLZI	TEMP,(1.0)	;RESET
;DISABLED		MOVEM	TEMP,FACTOR
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PMOVE( X, Y )	MOVE TO X, Y
;DISABLED	
;DISABLED		ENTRY	PMOVE
;DISABLED	PMOVE:	SKIPN	PLTMOD		;MUST BE IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PMOVE.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,2
;DISABLED		FATAL(MH2 MUST HAVE 2 ARGUMENTS FOR ROUTINE PMOVE.)
;DISABLED		MOVE	T1,PLOTYP	;GET PLOTTER TYPE
;DISABLED		MOVE	TEMP,@0(ARG)	;GET X COORDINATE
;DISABLED		FMPR	TEMP,FACTOR	;AND SCALE IT APPROPRIATELY
;DISABLED		FADR	TEMP,ORG.X
;DISABLED		CAMN	TEMP,CUR.X	;HAS X-COORD CHANGED?
;DISABLED		GOTO	MTBSM		;NOPE, CHECK Y CHANGE
;DISABLED		MOVEM	TEMP,CUR.X	;YES, GOING TO HAVE TO MOVE
;DISABLED		MOVE	TEMP,@1(ARG)	;GET Y-COORDINATE
;DISABLED		FMPR	TEMP,FACTOR	;SCALE IT APPROPRIATELY
;DISABLED		FADR	TEMP,ORG.Y
;DISABLED		MOVEM	TEMP,CUR.Y
;DISABLED		GOTO	@MOVTBL(T1)	;GO OFF TO ROUTINE TO HANDLE PLOTTER
;DISABLED	
;DISABLED	MTBSM:	MOVE	TEMP,@1(ARG)	;MIGHT NOT HAVE TO MOVE
;DISABLED		FMPR	TEMP,FACTOR	;SCALE Y TO SEE IF IT HAS CHANGED
;DISABLED		FADR	TEMP,ORG.Y
;DISABLED		CAMN	TEMP,CUR.Y	;HAS IT CHANGED?
;DISABLED		RETURN			;NO, EXIT
;DISABLED		MOVEM	TEMP,CUR.Y	;YES, GO DO THE MOVE
;DISABLED		GOTO	@MOVTBL(T1)
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PMOVER( XR, YR )	MOVE RELATIVE
;DISABLED	
;DISABLED		ENTRY	PMOVER
;DISABLED	PMOVER:	SKIPN	PLTMOD		;ARE WE IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PMOVER.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,2
;DISABLED		FATAL(MH2 MUST HAVE 2 ARGUMENTS FOR ROUTINE PMOVER.)
;DISABLED		MOVE	T1,PLOTYP
;DISABLED		MOVE	TEMP,@0(ARG)	;GET X-COORDINATE
;DISABLED		FSBR	TEMP,X.OFF	;SCALE ACCORDING TO OFSETS
;DISABLED		FDVR	TEMP,X.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		JUMPE	TEMP,MTBSMR	;IF STILL ZERO, MIGHT NOT HAVE TO MOVE
;DISABLED		FADR	TEMP,CUR.X	;ELSE, MAKE IT ABSOLUTE
;DISABLED		MOVEM	TEMP,CUR.X
;DISABLED		MOVE	TEMP,@1(ARG)	;AND DO SAME FOR Y
;DISABLED		FSBR	TEMP,Y.OFF
;DISABLED		FDVR	TEMP,Y.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		FADRM	TEMP,CUR.Y
;DISABLED		GOTO	@MOVTBL(T1)	;GO TO APPROPRIATE HANDLER
;DISABLED	
;DISABLED	MTBSMR:	MOVE	TEMP,@1(ARG)	;CHECK TO SEE IF Y HAS CHANGED
;DISABLED		FSBR	TEMP,Y.OFF
;DISABLED		FDVR	TEMP,Y.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		SKIPN	TEMP		;IF ZERO, THEN WE HAVEN'T MOVED
;DISABLED		RETURN			;SO DON'T BOTHER MOVING AGAIN
;DISABLED		FADRM	TEMP,CUR.Y
;DISABLED		GOTO	@MOVTBL(T1)	;ELSE GO HANDLE IT
;DISABLED	
;DISABLED	
;DISABLED	MOVTBL:	MARA
;DISABLED		MISC
;DISABLED		MTEK
;DISABLED		MCAL
;DISABLED	
;DISABLED	MARA:	MOVE	TEMP,CUR.X	;ARRAY MOVEMENT
;DISABLED		MOVEM	TEMP,OLD.X	;MAKE THE CURRENT POSITION THE LAST
;DISABLED		MOVE	TEMP,CUR.Y
;DISABLED		MOVEM	TEMP,OLD.Y
;DISABLED		RETURN
;DISABLED	
;DISABLED	MISC:	MOVEI	T1,[^D253]	;MOVE THE ISC BEAM
;DISABLED		CALL	FILPCL		;OUTPUT POINT MODE CHARACTER
;DISABLED		MOVE	T1,CUR.X	;GET THE X-COORDINATE
;DISABLED		FMPR	T1,[127.0]	;SCALE IT TO ISC'S CHARACTERISTICS
;DISABLED		FIXR	T1,T1		;MAKE IT AN INTEGER
;DISABLED		ADDI	T1,1		;MAKE IT START AT 1
;DISABLED		SKIPG	T1		;MAKE SURE IT IS IN MIN RANGE
;DISABLED		MOVEI	T1,1		;NOPE, START AT 1
;DISABLED		CAILE	T1,^D127	;AND IN MAX RANGE
;DISABLED		MOVEI	T1,^D127	;NOPE, START AT 127
;DISABLED		CALL	FILPCL		;DUMP THE X
;DISABLED		MOVE	T1,CUR.Y	;NOW DO THE SAME FOR Y
;DISABLED		FMPR	T1,[191.0]
;DISABLED		FIXR	T1,T1
;DISABLED		ADDI	T1,1
;DISABLED		SKIPG	T1
;DISABLED		MOVEI	T1,1
;DISABLED		CAILE	T1,^D191
;DISABLED		MOVEI	T1,^D191
;DISABLED		CALL	FILPCL
;DISABLED		WAIT( 20, ^D253 )	;WAIT FOR CHARACTER OUTPUT TO BE DONE
;DISABLED		RETURN
;DISABLED	
;DISABLED	MTEK:	MOVEI	T1,^D29		;MOVE THE TEKTRONIX BEAM
;DISABLED		CALL	FILPCL		;SET UP CHARACTERS TO MOVE
;DISABLED		MOVE	TEMP,CUR.Y	;GET Y
;DISABLED		CALL	PFNC		;FIND OUT LOW ORDER INFORMATION
;DISABLED		MOVE	TEMP,CUR.Y	;GET Y AGAIN
;DISABLED		FMPR	TEMP,TEKDIM	;COMPUTE HIGH ORDER INFORMATION
;DISABLED		FIX	TEMP,TEMP	;MAKE IT AN INTEGER
;DISABLED		IDIVI	TEMP,^D32	;AND SET IT UP SO ITS A REASONABLE
;DISABLED		ADDI	T1,^D96		;CHARACTER
;DISABLED		CALL	FILPCL		;DUMP THE CHARACTER
;DISABLED		MOVE	TEMP,CUR.X	;DO THE SAME FOR X
;DISABLED		CALL	PFNC
;DISABLED		MOVE	TEMP,CUR.X
;DISABLED		FMPR	TEMP,TEKDIM
;DISABLED		FIX	TEMP,TEMP
;DISABLED		IDIVI	TEMP,^D32
;DISABLED		ADDI	T1,^D64
;DISABLED		MOVE	11,T1
;DISABLED		CALL	FILPCL
;DISABLED		RETURN
;DISABLED	
;DISABLED	PFNC:	FMPR	TEMP,[24.375]	;ROUTINE DOES SCALING
;DISABLED		FIX	TEMP,TEMP	;TO FIND ORDER INFORMATION FOR
;DISABLED		IDIVI	TEMP,^D32	;PRINTING STUFF ON TEKTRONIX
;DISABLED		ADDI	T1,^D32
;DISABLED		CALL	FILPCL		;DUMP THE RESULTING WORD
;DISABLED		RETURN
;DISABLED	
;DISABLED	MCAL:	MOVE	T1,CUR.X	;MOVE THE CALCOMP PEN
;DISABLED		CAMLE	T1,MAXX		;MAKE SURE WE HAVEN'T GONE
;DISABLED		MOVEM	T1,MAXX		;FURTHER THAN EVER, IF SO MARK
;DISABLED		FMPR	T1,CALDIM	;MULTIPLY IT BY CALCOMP FACTOR
;DISABLED		FIXR	T1,T1		;MAKE IT AN INTEGER TO PLOT
;DISABLED		MOVE	TEMP,CUR.Y	;DO THE SAME FOR Y
;DISABLED		FMPR	TEMP,CALDIM
;DISABLED		FIXR	TEMP,TEMP
;DISABLED		HRL	TEMP,T1		;PUT WORDS TOGETHER
;DISABLED		MOVEI	T1,3		;PEN WILL BE LIFTED WHEN IT MOVES
;DISABLED		GOTO	OUTCAL		;GO PUT IN PLOT BUFFER
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PDRAW( X, Y )	DRAW
;DISABLED	
;DISABLED		ENTRY	PDRAW
;DISABLED	PDRAW:	SKIPN	PLTMOD		;ARE WE IN PLOT MODE?
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PDRAW.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,2
;DISABLED		FATAL(MH2 MUST HAVE 2 ARGUMENTS FOR ROUTINE PDRAW.)
;DISABLED		MOVE	T1,PLOTYP	;GET PLOTTER TYPE
;DISABLED		MOVE	TEMP,@0(ARG)	;GET X
;DISABLED		FMPR	TEMP,FACTOR	;SCALE IT APPROPRIATELY
;DISABLED		FADR	TEMP,ORG.X
;DISABLED		CAMN	TEMP,CUR.X	;HAVE WE MOVED?
;DISABLED		GOTO	DTBSM		;NO, IF NO DIFFERENCE IN Y, DON'T DRAW
;DISABLED		MOVEM	TEMP,CUR.X	;YES, REMEMBER X AND CONVERT Y
;DISABLED		MOVE	TEMP,@1(ARG)
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		FADR	TEMP,ORG.Y
;DISABLED		MOVEM	TEMP,CUR.Y
;DISABLED		GOTO	@DRWTBL(T1)	;GO DRAW THE LINE
;DISABLED	
;DISABLED	DTBSM:	MOVE	TEMP,@1(ARG)	;CONVERT THE Y
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		FADR	TEMP,ORG.Y
;DISABLED		CAMN	TEMP,CUR.Y	;IF ITS THE SAME
;DISABLED		RETURN			;DON'T DRAW
;DISABLED		MOVEM	TEMP,CUR.Y	;ELSE
;DISABLED		GOTO	@DRWTBL(T1)	;GO TO APPROPRIATE ROUTINE
;DISABLED	
;DISABLED		
;DISABLED	;	CALL PDRAWR( XR, YR )	DRAW RELATIVE
;DISABLED	
;DISABLED		ENTRY	PDRAWR
;DISABLED	
;DISABLED	PDRAWR:	SKIPN	PLTMOD		;MUST BE IN PLOTTING MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PDRAWR.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK THE NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP
;DISABLED		CAIE	TEMP,2
;DISABLED		FATAL(MH2 MUST HAVE 2 ARGUMENTS FOR ROUTINE PDRAWR.)
;DISABLED		MOVE	T1,PLOTYP	;GET X AND SCALE IT WITH OFFSETS
;DISABLED		MOVE	TEMP,@0(ARG)
;DISABLED		FSBR	TEMP,X.OFF
;DISABLED		FDVR	TEMP,X.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		JUMPE	TEMP,DTBSMR	;IF IT IS 0, MAYBE DIDN'T MOVE
;DISABLED		FADR	TEMP,CUR.X
;DISABLED		MOVEM	TEMP,CUR.X
;DISABLED		MOVE	TEMP,@1(ARG)	;SCALE THE Y
;DISABLED		FSBR	TEMP,Y.OFF
;DISABLED		FDVR	TEMP,Y.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		FADRM	TEMP,CUR.Y
;DISABLED		GOTO	@DRWTBL(T1)	;AND GO HANDLE IT
;DISABLED	
;DISABLED	DTBSMR:	MOVE	TEMP,@1(ARG)	;IF ITS THE SAME X, CHECK Y
;DISABLED		FSBR	TEMP,Y.OFF
;DISABLED		FDVR	TEMP,Y.FACT
;DISABLED		FMPR	TEMP,FACTOR
;DISABLED		SKIPN	TEMP		;IF DIFFERENCE IN Y'S IS ZERO
;DISABLED		RETURN			;DIDN'T MOVE
;DISABLED		FADRM	TEMP,CUR.Y
;DISABLED		GOTO	@DRWTBL(T1)	;GO HANDLE PLOTTER
;DISABLED	
;DISABLED	
;DISABLED	DRWTBL:	DARA
;DISABLED		DISC
;DISABLED		DTEK
;DISABLED		DCAL
;DISABLED	
;DISABLED	DARA:	MOVE	T1,OLD.X	;DRAW LINE WITH BRESHAM'S ALGORITHM
;DISABLED		FMPR	T1,FLXDIM	;SCALE OLD X APPROPRIATELY
;DISABLED		FIXR	T1,T1
;DISABLED		MOVE	T2,OLD.Y
;DISABLED		FMPR	T2,FLYDIM	;SCALE OLD Y APPROPRIATELY
;DISABLED		FIXR	T2,T2
;DISABLED		MOVE	T3,CUR.X
;DISABLED		MOVEM	T3,OLD.X
;DISABLED		FMPR	T3,FLXDIM	;SCALE NEW X APPROPRIATELY
;DISABLED		FIXR	T3,T3
;DISABLED		MOVE	T4,CUR.Y
;DISABLED		MOVEM	4,OLD.Y
;DISABLED		FMPR	T4,FLYDIM	;SCALE NEW Y APPROPRIATELY
;DISABLED		FIXR	T4,T4
;DISABLED		MOVE	T5,T3
;DISABLED		SUB	T5,T1		;CREATE A DELTA X
;DISABLED		MOVE	T6,T4
;DISABLED		SUB	T6,T2		;AND A DELTA Y
;DISABLED		MOVM	T7,T5		;GET MAGNITUDE OF DELTA X
;DISABLED		MOVM	T10,T6		;AND MAGNITUDE OF DELTA Y
;DISABLED		SETZ	T11,		;AND ZERO ERROR FACTOR FOR ALGORITHM
;DISABLED		CAMGE	T7,T10		;IF MAG DX < MAG DY
;DISABLED		GOTO	ALONGY		;DRAW ALONG Y
;DISABLED		JUMPE	T7,NODRAW	;IF MAG X IS ZERO, NO ONE MOVED!
;DISABLED	
;DISABLED	ALONGX:	CAMN	T1,T3		;BRESHAM'S ALGORITHM ALONG X
;DISABLED		GOTO	NODRAW		;EXIT IF WE ARE AT RIGHT POINT
;DISABLED		CALL	XYADDR		;ELSE, PUT THE COLOR AT THAT PIXEL
;DISABLED		MOVE	TEMP,T6		;GET DELTA Y
;DISABLED		IMULI	TEMP,2		;MULTIPLY IT BY 2
;DISABLED		ADD	T11,TEMP	;AND ADD INTO THE ERROR FACTOR
;DISABLED		MOVM	T12,T11		;GET THE ABSOLUTE VALUE OF ERROR
;DISABLED		CAMGE	T12,T7		;IF IT DOESN'T EXCEED MAG DELTA X
;DISABLED		GOTO	ENDALX		;THEN DON'T BOTHER INCREMENTING Y
;DISABLED		ADDI	T2,1		;INCREMENT Y BY 1
;DISABLED		SKIPGE	T6		;UNLESS DELTA Y IS NEGATIVE
;DISABLED		SUBI	T2,2		;IN WHICH CASE, DECREMENT BY 1
;DISABLED		MOVE	TEMP,T7		;AND RECALCULATE
;DISABLED		IMULI	TEMP,2		;THE ERROR FACTOR SINCE WE JUST
;DISABLED		SKIPG	T11		;CANCELED OUT SOME OF THE ERROR
;DISABLED		MOVN	TEMP,TEMP	;GET ERROR TO BE SAME SIGN AS FACTOR
;DISABLED		SUB	T11,TEMP	;BUT DECREMENTED BY RESULTING
;DISABLED	
;DISABLED	ENDALX:	SUBI	T1,1		;OUT OF LOOP, ASSUME DX WAS NEGATIVE
;DISABLED		SKIPL	T5		;UNLESS DELTA X WAS POSITIVE
;DISABLED		ADDI	T1,2		;THEN MUST BE GOING POSITIVE X
;DISABLED		GOTO	ALONGX		;GO BACK FOR ANOTHER
;DISABLED	
;DISABLED	ALONGY:	CAMN	T2,T4		;BRESHAM'S ALGORITHM ALONG Y
;DISABLED		GOTO	NODRAW
;DISABLED		CALL	XYADDR
;DISABLED		MOVE	TEMP,T5
;DISABLED		IMULI	TEMP,2
;DISABLED		ADD	T11,TEMP
;DISABLED		MOVM	T12,T11
;DISABLED		CAMGE	T12,T10
;DISABLED		GOTO	ENDALY
;DISABLED		ADDI	T1,1
;DISABLED		SKIPGE	T5
;DISABLED		SUBI	T1,2
;DISABLED		MOVE	TEMP,T10
;DISABLED		IMULI	TEMP,2
;DISABLED		SKIPG	T11
;DISABLED		MOVN	TEMP,TEMP
;DISABLED		SUB	T11,TEMP
;DISABLED	
;DISABLED	ENDALY:	SUBI	T2,1
;DISABLED		SKIPL	T6
;DISABLED		ADDI	T2,2
;DISABLED		GOTO	ALONGY
;DISABLED	
;DISABLED	NODRAW:	RETURN			;RETURN TO CALLER
;DISABLED	
;DISABLED	XYADDR:	SKIPLE	T1		;CHECK BOUNDS OF BEAM
;DISABLED		CAMLE	T1,MAXFX	;IF X OUT OF BOUNDS
;DISABLED		RETURN			;IGNORE
;DISABLED		SKIPLE	T2		;CHECK BOUNDS OF X
;DISABLED		CAMLE	T2,MAXFY	;IF Y OUT OF BOUNDS
;DISABLED		RETURN			;IGNORE
;DISABLED		MOVE	T13,T2		;GET Y POSITION
;DISABLED		SUBI	T13,1		;INDICES START AT 0
;DISABLED		IMUL	T13,MAXFX	;MULTIPLY IT BY ITS X DIMENSION
;DISABLED		ADD	T13,T1		;ADD IN X
;DISABLED		SUBI	T13,1		;INDICES START AT 0
;DISABLED		ADD	T13,PLTADR	;ADD IN ADDRESS OF BEGINNING OF ARRAY
;DISABLED		MOVE	TEMP,ARACOL	;GET PEN "COLOR"
;DISABLED		MOVEM	TEMP,(T13)	;AND PUT IT IN ARRAY
;DISABLED		RETURN
;DISABLED	
;DISABLED	DISC:	MOVEI	T1,^D242	;DRAW LINE ON ISC
;DISABLED		CALL	FILPCL		;OUTPUT CODE FOR VECTOR MODE
;DISABLED		MOVE	T1,CUR.X	;THE REST IS ALMOST IDENTICAL TO MOVE
;DISABLED		FMPR	T1,[127.0]
;DISABLED		FIXR	T1,T1
;DISABLED		ADDI	T1,1
;DISABLED		SKIPG	T1
;DISABLED		MOVEI	T1,1
;DISABLED		CAILE	T1,^D158
;DISABLED		MOVEI	T1,^D158
;DISABLED		CALL	FILPCL
;DISABLED		MOVE	T1,CUR.Y
;DISABLED		FMPR	T1,[191.0]
;DISABLED		FIXR	T1,T1
;DISABLED		ADDI	T1,1
;DISABLED		SKIPG	T1
;DISABLED		MOVEI	T1,1
;DISABLED		CAILE	T1,^D191
;DISABLED		MOVEI	T1,^D191
;DISABLED		CALL	FILPCL
;DISABLED		WAIT( 20, ^D242 )
;DISABLED		RETURN
;DISABLED	
;DISABLED	DTEK:	MOVE	TEMP,CUR.Y	;DRAW LINE ON TEKTRONIX
;DISABLED		CALL	PFNC		;IDENTICAL TO MOVE EXCEPT MOVE
;DISABLED		MOVE	TEMP,CUR.Y	;FLAG PRECEDING IT
;DISABLED		FMPR	TEMP,TEKDIM
;DISABLED		FIX	TEMP,TEMP
;DISABLED		IDIVI	TEMP,^D32
;DISABLED		ADDI	T1,^D96
;DISABLED		CALL	FILPCL
;DISABLED		MOVE	TEMP,CUR.X
;DISABLED		CALL	PFNC
;DISABLED		MOVE	TEMP,CUR.X
;DISABLED		FMPR	TEMP,TEKDIM
;DISABLED		FIX	TEMP,TEMP
;DISABLED		IDIVI	TEMP,^D32
;DISABLED		ADDI	T1,^D64
;DISABLED		CALL	FILPCL
;DISABLED		RETURN
;DISABLED	
;DISABLED	DCAL:	MOVE	T1,CUR.X	;DRAW LINE ON CALCOMP
;DISABLED		CAMLE	T1,MAXX		;MAKE SURE WE HAVEN'T GONE
;DISABLED		MOVEM	T1,MAXX		;FURTHER THAN EVER, IF SO MARK
;DISABLED		FMPR	T1,CALDIM	;SCALE IT TO CALCOMP STANDARD
;DISABLED		FIXR	T1,T1		;MAKE IT INTEGER
;DISABLED		MOVE	TEMP,CUR.Y	;DO SAME FOR Y
;DISABLED		FMPR	TEMP,CALDIM
;DISABLED		FIXR	TEMP,TEMP
;DISABLED		HRL	TEMP,T1		;PUT THEM TOGETHER FOR POSITION
;DISABLED		MOVEI	T1,2		;DO IT WHILE PEN DOWN
;DISABLED		GOTO	OUTCAL		;GO TELL PLOTTER
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PEXIT		EXIT PLOTTING MODE
;DISABLED	
;DISABLED		ENTRY	PEXIT
;DISABLED	PEXIT:	SKIPN	PLTMOD		;ARE WE IN PLOT MODE?
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PEXIT.)
;DISABLED		HLRZ	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		SKIPE	TEMP
;DISABLED		FATAL(PTN PEXIT TAKES NO ARGUMENTS.)
;DISABLED		SKIPE	T1,EXIPLT	;GET EXIT CHARACTER
;DISABLED		CALL	FILPCL		;TYPE IT OUT IF NOT ZERO
;DISABLED		SETZM	PLTMOD		;AND FLAG THAT WE ARE NOT PLOTTING
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PCLOSE		RELEASE CALCOMP
;DISABLED	
;DISABLED		ENTRY	PCLOSE
;DISABLED	PCLOSE:	HLRZ	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		SKIPE	TEMP
;DISABLED		FATAL(PTN PCLOSE TAKES NO ARGUMENTS.)
;DISABLED		SKIPE	CALOPN		;SKIP IF NOT OPEN
;DISABLED		XCT	PLTCLS		;CLOSE THE CHANNEL
;DISABLED		SETZM	CALOPN		;PLOTTER CLOSING
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PCLEAR		CLEAR PLOTTING AREA
;DISABLED	
;DISABLED		ENTRY	PCLEAR
;DISABLED	PCLEAR:	HLRZ	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		SKIPE	TEMP
;DISABLED		FATAL(PTN PCLEAR TAKES NO ARGUMENTS.)
;DISABLED		SKIPGE	T1,PLOTYP	;MUST HAVE A PLOTTER TYPE TO CLEAR
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PCLEAR.)
;DISABLED		SETZM	ORG.X		;ZERO OUT ORIGIN
;DISABLED		SETZM	ORG.Y
;DISABLED		GOTO	@CLRTBL(T1)	;AND GO TO APPROPRIATE ROUTINE
;DISABLED	
;DISABLED	CLRTBL:	CARA
;DISABLED		CISC
;DISABLED		CTEK
;DISABLED		CCAL
;DISABLED	
;DISABLED	CARA:	MOVE	TEMP,[ASCII/     /]	;PUT SPACES IN ARRAY
;DISABLED		MOVE	T1,PLTADR	;GET ADDRESS OF ARRAY TO CLEAR
;DISABLED		MOVEM	TEMP,(T1)	;SET FIRST LOCATION TO SPACES
;DISABLED		MOVE	TEMP,MAXFX	;FIND LENGTH OF ARRAY
;DISABLED		IMUL	TEMP,MAXFY	;FOR BOTH DIMENSIONS
;DISABLED		ADD	TEMP,T1		;ADD IN ARRAY POSITION
;DISABLED		SUBI	TEMP,1		;ARRAY STARTS AT 0, NOT AT 1
;DISABLED		HRLI	TEMP,(BLT T1,0)	;SET UP INSTRUCTION
;DISABLED		HRL	T1,T1		;SETTING UP PECULIAR DESTS FOR COPY
;DISABLED		ADDI	T1,1		;SO BLT MAKES EVERYTHING SPACES!
;DISABLED		XCT	TEMP		;CLEAR THAT CORE!
;DISABLED		RETURN
;DISABLED	
;DISABLED	CISC:	MOVE	T1,EXIPLT	;CLEAR ISC SCREEN
;DISABLED		SKIPE	PLTMOD		;IF IN PLOTTING MODE
;DISABLED		CALL	FILPCL		;PRINT CHAR TO EXIT
;DISABLED		MOVEI	T1,^D12		;GET CONTROL-L
;DISABLED		CALL	FILPCL		;AND PRINT IT
;DISABLED		WAIT( ^D40, 0 )		;WAIT FOR SCREEN TO RECOVER
;DISABLED		MOVE	T1,ENTPLT	;NOW SET UP TO GO BACK INTO
;DISABLED		SKIPE	PLTMOD		;PLOT MODE IF NECESSARY
;DISABLED		CALL	FILPCL		;DUMP THE PLOT EXIT CHAR
;DISABLED		RETURN
;DISABLED	
;DISABLED	CTEK:	MOVEI	T1,33		;CLEAR TEKTRONIX SCREEN
;DISABLED		CALL	FILPCL		;OUTPUT ESCAPE
;DISABLED		MOVEI	T1,^D12		;FOLLOWED BY A CONTROL-L
;DISABLED		CALL	FILPCL		;DUMP THAT
;DISABLED		WAIT( ^D100, 0 )	;WAIT FOR SCREEN TO RECOVER
;DISABLED		RETURN
;DISABLED	
;DISABLED	CCAL:	MOVE	TEMP,MAXX	;"NEXT SCREEN" IS
;DISABLED		FADR	TEMP,[0.1]	;THE LAST GREATEST X
;DISABLED		MOVEM	TEMP,ORG.X	;PLUS A MARGIN (0.1)
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL POFFST( XOFF, XFACT, YOFF, YFACT )		ENTER FACTORS
;DISABLED	
;DISABLED		ENTRY	POFFST
;DISABLED	POFFST:	MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,4		;IF NOT 4
;DISABLED		FATAL(MH4 MUST HAVE 4 ARGUMENTS FOR ROUTINE POFFST.)
;DISABLED		MOVE	TEMP,@0(ARG)	;ELSE, GET 
;DISABLED		MOVEM	TEMP,X.OFF	;X OFFSET
;DISABLED		MOVE	TEMP,@1(ARG)	;AND
;DISABLED		SKIPG	TEMP		;X FACTOR IF NOT ZERO
;DISABLED		HRLI	TEMP,(1.0)	;IF ZERO, GET DEFAULT
;DISABLED		MOVEM	TEMP,X.FACT	;AND REMEMBER IT
;DISABLED		MOVE	TEMP,@2(ARG)	;DO SAME FOR Y
;DISABLED		MOVEM	TEMP,Y.OFF
;DISABLED		MOVE	TEMP,@3(ARG)
;DISABLED		SKIPG	TEMP
;DISABLED		HRLI	TEMP,(1.0)
;DISABLED		MOVEM	TEMP,Y.FACT
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PWHERE( X, Y, FACTOR )	RETURN COORDINATES
;DISABLED	
;DISABLED		ENTRY	PWHERE
;DISABLED	PWHERE:	MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,3		;IF NOT THREE
;DISABLED		FATAL(MH3 MUST HAVE 3 ARGUMENTS FOR ROUTINE PWHERE.)
;DISABLED		MOVE	TEMP,CUR.X	;GET CURRENT X
;DISABLED		FSBR	TEMP,ORG.X	;TRANSLATE IT BACK TO REAL WORLD
;DISABLED		MOVEM	TEMP,@0(ARG)	;AND RETURN IT
;DISABLED		MOVE	TEMP,CUR.Y	;SAME FOR Y
;DISABLED		FSBR	TEMP,ORG.Y
;DISABLED		MOVEM	TEMP,@1(ARG)
;DISABLED		MOVE	TEMP,FACTOR	;GET FACTOR
;DISABLED		MOVEM	TEMP,@2(ARG)	;RETURN THAT TOO
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PCOLOR( ICOLOR )	CHANGE COLOR
;DISABLED	
;DISABLED		ENTRY	PCOLOR
;DISABLED	PCOLOR:	SKIPGE	T1,PLOTYP	;IF PLOTTER TYPE NOT DEFINED
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PCOLOR.)
;DISABLED		MOVN	TEMP,-1(ARG)	;ELSE CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,1		;IF NOT 1
;DISABLED		FATAL(MH1 MUST HAVE 1 ARGUMENT FOR ROUTINE PCOLOR.)
;DISABLED		MOVE	TEMP,@0(ARG)	;GET COLOR
;DISABLED		JUMPE	T1,PCOARA	;ANYTHING LEGAL FOR ARRAY
;DISABLED		SKIPLE	TEMP		;ELSE CHECK TO SEE IN RANGE 1..8
;DISABLED		CAILE	TEMP,^D8
;DISABLED		FATAL(COB COLOR OUT OF BOUNDS IN PCOLOR.)
;DISABLED		GOTO	@COLTBL(T1)	;AND JUMP TO ROUTINE TO HANDLE
;DISABLED	
;DISABLED	COLTBL:	PCOARA
;DISABLED		PCOISC
;DISABLED		PCOGRB			;TEKTRONIX HAS ONE COLOR - GREEN!
;DISABLED		PCOCAL
;DISABLED	
;DISABLED	COLARA:	"+"			;COLOR 0 OR 8 FOR ARRAY
;DISABLED		"."			;COLOR 1
;DISABLED		"%"			;COLOR 2
;DISABLED		"*"			;COLOR 3
;DISABLED		"@"			;COLOR 4
;DISABLED		"&"			;COLOR 5
;DISABLED		"#"			;COLOR 6
;DISABLED		"$"			;COLOR 7
;DISABLED	
;DISABLED	PCOARA:	SKIPL	TEMP		;IS COLOR IN ASCII RANGE?
;DISABLED		CAIL	TEMP,177
;DISABLED		LSH	TEMP,^D-29	;NOPE, MAKE IT IN ASCII RANGE!
;DISABLED		CAILE	TEMP," "	;IF COLOR IS A CHARACTER
;DISABLED		GOTO	GUDCOL		;GOOD COLOR
;DISABLED		IDIVI	TEMP,10		;ELSE MAKE IT IN RANGE OF EIGHT
;DISABLED		MOVE	TEMP,COLARA(T1)	;AND GET THE NEW COLOR
;DISABLED	GUDCOL:	MOVE	T1,[ASCII/     /]	;SET UP TO PAD WITH BLANKS
;DISABLED		LSHC	TEMP,^D29	;MAKE IT A NORMAL FORTRAN A1 WORD
;DISABLED		MOVEM	TEMP,ARACOL	;AND STORE IT AS CURRENT "COLOR"
;DISABLED		RETURN
;DISABLED	
;DISABLED	ISCCOL:	^D23			;WHITE
;DISABLED		^D20			;DARK BLUE
;DISABLED		^D17			;RED
;DISABLED		^D22			;LIGHT BLUE
;DISABLED		^D21			;PURPLE
;DISABLED		^D18			;GREEN
;DISABLED		^D19			;YELLOW
;DISABLED		^D16			;BLACK
;DISABLED	
;DISABLED	PCOISC:	MOVE	T1,EXIPLT	;SET UP EXIT PLOT CHARACTER
;DISABLED		SKIPE	PLTMOD		;IF IN PLOT MODE
;DISABLED		CALL	FILPCL		;OUTPUT IT
;DISABLED		MOVEI	T1,^D29		;SET UP CONTROL FOR COLOR CHANGE
;DISABLED		CALL	FILPCL		;AND DUMP IT
;DISABLED	OUTCOL:	MOVE	T1,TEMP		;GET COLOR TO OUTPUT
;DISABLED		MOVE	T1,ISCCOL-1(T1)	;SEE TABLE FOR WHAT IT ACTUALLY IS
;DISABLED		CALL	FILPCL		;AND DUMP IT
;DISABLED		MOVE	T1,ENTPLT	;SET UP TO ENTER PLOT
;DISABLED		SKIPE	PLTMOD		;IF WE WERE IN PLOT MODE
;DISABLED		CALL	FILPCL		;GET BACK INTO PLOT MODE
;DISABLED	
;DISABLED	PCOGRB:	RETURN
;DISABLED	
;DISABLED	PCOCAL:	SUBI	TEMP,1		;PREPARE IDIVI
;DISABLED		IDIVI	TEMP,3		;CALCOMP HAS 3 PENS
;DISABLED		ADDI	T1,1		;RECOVER FROM MOD
;DISABLED		MOVE	TEMP,T1		;GET COLOR INTO "PEN" POSITION
;DISABLED		MOVEI	T1,4		;CODE FOR PEN CHANGE
;DISABLED		GOTO	OUTCAL		;GO TELL PLOTTER
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PBACK( ICOLOR )	;CHANGE BACKGROUND(ISC)
;DISABLED	
;DISABLED		ENTRY	PBACK
;DISABLED	PBACK:	SKIPGE	T1,PLOTYP	;CHECK TO SEE IF PLOTTER TYPE DEFINED
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PBACK.)
;DISABLED		CAIE	T1,1		;IF NOT ISC TERMINAL
;DISABLED		RETURN			;CAN'T SET BACKGROUND
;DISABLED		MOVN	TEMP,-1(ARG)	;ELSE CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,1		;IF NOT 1
;DISABLED		FATAL(MH1 MUST HAVE 1 ARGUMENT FOR ROUTINE PBACK.)
;DISABLED		MOVE	T1,EXIPLT	;PREPARE TO EXIT PLOT MODE
;DISABLED		SKIPE	PLTMOD		;IF IN PLOT MODE
;DISABLED		CALL	FILPCL		;EXIT IT
;DISABLED		MOVE	TEMP,@0(ARG)	;AND GET COLOR
;DISABLED		SKIPL	TEMP		;CHECK ITS LEGALLITY
;DISABLED		CAILE	TEMP,7		;IF NOT IN RANGE
;DISABLED		FATAL(COB COLOR OUT OF BOUNDS IN PBACK.)
;DISABLED		MOVEI	T1,^D30		;SET UP CODE FOR BACK GROUND COLOR
;DISABLED		CALL	FILPCL		;TELL TERMINAL
;DISABLED		GOTO	OUTCOL		;AND GO CHANGE COLORS
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PBLON		;TURN ON BLINK(ISC)
;DISABLED	
;DISABLED		ENTRY	PBLON
;DISABLED	PBLON:	SKIPGE	T1,PLOTYP	;IS PLOTTER TYPE DEFINED?
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PBLON.)
;DISABLED		HLRZ	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		SKIPE	TEMP		;IF NOT ZERO
;DISABLED		FATAL(PTN PBLON TAKES NO ARGUMENT.)
;DISABLED		CAIE	T1,1		;IF NOT ISC TERMINAL
;DISABLED		RETURN			;CAN'T BLINK
;DISABLED		MOVE	T1,EXIPLT	;GET EXIT CHARACTER
;DISABLED		SKIPE	PLTMOD		;AND IF IN PLOT MODE
;DISABLED		CALL	FILPCL		;EXIT IT
;DISABLED		MOVEI	T1,^D31		;SET UP BLINK ON CHARACTER
;DISABLED		CALL	FILPCL		;AND TURN BLINK ON
;DISABLED		MOVE	T1,ENTPLT	;NOW SET UP ENTER CHARACTER
;DISABLED		SKIPE	PLTMOD		;AND IF IT WAS IN PLOT MODE
;DISABLED		CALL	FILPCL		;ENTER PLOT MODE
;DISABLED		RETURN
;DISABLED	
;DISABLED	;	CALL PBLOFF		;TURN OFF BLINK(ISC)
;DISABLED	
;DISABLED		ENTRY	PBLOFF
;DISABLED	PBLOFF:	SKIPGE	T1,PLOTYP	;IS PLOTTER TYPE DEFINED?
;DISABLED		FATAL(MCP MUST CALL PLOTON BEFORE CALLING PBLON.)
;DISABLED		HLRZ	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		SKIPE	TEMP		;IF NOT ZERO
;DISABLED		FATAL(PTN PBLON TAKES NO ARGUMENT.)
;DISABLED		CAIE	T1,1		;IF NOT ISC TERMINAL
;DISABLED		RETURN			;CAN'T BLINK
;DISABLED		MOVE	T1,EXIPLT	;GET EXIT CHARACTER
;DISABLED		SKIPE	PLTMOD		;AND IF IN PLOT MODE
;DISABLED		CALL	FILPCL		;EXIT IT
;DISABLED		MOVEI	T1,^D31		;SET UP BLINK OFF CHARACTER
;DISABLED		CALL	FILPCL		;AND TURN BLINK OFF
;DISABLED		MOVE	T1,ENTPLT	;NOW SET UP ENTER CHARACTER
;DISABLED		SKIPE	PLTMOD		;AND IF IT WAS IN PLOT MODE
;DISABLED		CALL	FILPCL		;ENTER PLOT MODE
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PCURSR( ICHAR, X, Y )
;DISABLED	
;DISABLED		ENTRY	PCURSR
;DISABLED	PCURSR:	SKIPN	PLTMOD		;CHECK IF IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PCURSR.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,3		;IF NOT 3 ARGS
;DISABLED		FATAL(MH3 MUST HAVE 3 ARGUMENTS FOR ROUTINE PCURSR.)
;DISABLED		MOVE	TEMP,PLOTYP	;GET PLOTTER TYPE
;DISABLED		CAIE	TEMP,2		;IF NOT TEKTRONIX, DON'T KNOW HOW
;DISABLED		FATAL(MBT MUST BE TEKTRONIX FOR PCURSR.)
;DISABLED		SAVE	T2		;SAVE BECAUSE IT WILL GET DESTROYED
;DISABLED		MOVEI	T1,^D27		;SET UP TO TURN ON TEK CROSS HAIRS
;DISABLED		CALL	FILPCL		;DUMP CHAR
;DISABLED		MOVEI	T1,^D26		;AND NEXT CROSS HAIR CHAR
;DISABLED		CALL	FILPCL		;DUMP IT
;DISABLED		CALL	FILDMP		;MAKE SURE ITS OUT
;DISABLED		INCHRW	@0(ARG)		;AND WAIT FOR THE CHARACTER
;DISABLED		INCHRW	T1		;GET ONE OF THE X COORDINATES
;DISABLED		IDIVI	T1,^D32		;MAKE IT VALID
;DISABLED		IMULI	T2,^D32		;SET UP IN HIGHER PART OF WORD
;DISABLED		INCHRW	TEMP		;GET OTHER PART
;DISABLED		IDIVI	TEMP,^D32	;MAKE IT VALID
;DISABLED		ADD	T2,T1		;AND THAT BECOMES THE X COORDINATE
;DISABLED		FLTR	T2,T2		;ONLY IT HAS TO BE REAL
;DISABLED		FDVR	T2,TEKDIM	;AND NORMALIZED
;DISABLED		FSBR	T2,ORG.X	;AND IN RELATION TO ORIGIN
;DISABLED		FDVR	T2,FACTOR	;AND SCALED
;DISABLED		FMPR	T2,X.FACT	;AND FACTORED
;DISABLED		FADR	T2,X.OFF	;AND OFSET!
;DISABLED		MOVEM	T2,@1(ARG)	;RETURN IT
;DISABLED		INCHRW	T1		;AND DO THE SAME THING FOR Y
;DISABLED		IDIVI	T1,^D32
;DISABLED		IMULI	T2,^D32
;DISABLED		INCHRW	TEMP
;DISABLED		IDIVI	TEMP,^D32
;DISABLED		ADD	T2,T1
;DISABLED		FLTR	T2,T2
;DISABLED		FDVR	T2,TEKDIM
;DISABLED		FSBR	T2,ORG.Y
;DISABLED		FDVR	T2,FACTOR
;DISABLED		FMPR	T2,Y.FACT
;DISABLED		FADR	T2,Y.OFF
;DISABLED		MOVEM	T2,@2(ARG)
;DISABLED		INCHRW	TEMP		;GET RID OF <CRLF>
;DISABLED		INCHRW	TEMP
;DISABLED		MOVE	T1,EXIPLT	;SET UP TO EXIT PLOT MODE
;DISABLED		CALL	FILPCL		;TO LET TERMINAL COME BACK
;DISABLED		MOVE	T1,ENTPLT	;SET UP TO ENTER PLOT MODE AGAIN
;DISABLED		CALL	FILPCL		;DUMP CHARACTER
;DISABLED		RESTORE	T2
;DISABLED		RETURN
;DISABLED						;PAGE 21
;DISABLED	;	CALL PTABLE( ADDR )	TELL PLTSYM WHERE CHAR TABLE IS
;DISABLED	
;DISABLED		ENTRY	PTABLE
;DISABLED	
;DISABLED	PTABLE:	MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,1		;IF NOT 1
;DISABLED		FATAL(MH1 MUST HAVE 1 ARGUMENT FOR ROUTINE PTABLE.)
;DISABLED		MOVE	TEMP,@0(ARG)	;GET TABLE ADDRESS
;DISABLED		SKIPN	TEMP		;IF IT IS ZERO
;DISABLED		MOVEI	TEMP,TBL1	;HE WANTS DEFAULT TABLE
;DISABLED		MOVEM	TEMP,CHRTBL	;REMEMBER ADDRESS
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PLTSYM( ICHAR, X, Y, HEIGHT, ANGLE )	PLOT SYMBOL
;DISABLED	
;DISABLED		ENTRY	PLTSYM
;DISABLED	PLTSYM:	SKIPN	PLTMOD		;IF NOT IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PLTSYM.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,5		;IF NOT 5
;DISABLED		FATAL(MH5 MUST HAVE 5 ARGUMENTS FOR ROUTINE PLTSYM.)
;DISABLED		MOVE	TEMP,@4(ARG)	;GET ANGLE
;DISABLED		FUNCT	COSD,<TEMP>	;GET COSINE OF ANGLE
;DISABLED		FMPR	TEMP,@3(ARG)	;MULTIPLY IT BY HTE HEIGHT
;DISABLED		FDVR	TEMP,SIZGRD	;AND DIVIDE BY SIZE OF GRID
;DISABLED		MOVEM	TEMP,SAVCOS	;THAT IS X FUDGE FIGURE
;DISABLED		MOVE	TEMP,@4(ARG)	;NOW GET Y FUDGE FIGURE
;DISABLED		FUNCT	SIND,<TEMP>
;DISABLED		FMPR	TEMP,@3(ARG)
;DISABLED		FDVR	TEMP,SIZGRD
;DISABLED		MOVEM	TEMP,SAVSIN
;DISABLED		SKIPL	T1,@0(ARG)	;CHECK TO SEE IF CHAR IN RANGE
;DISABLED		CAILE	T1,177
;DISABLED		LSH	T1,^D-29	;IF NOT, PROBABLY A1, MAKE R1
;DISABLED		SETZM	CENTER		;SET DEFAULT IF SYMBOL IS CENTERED
;DISABLED		CAIG	T1,31		;IS IT ABOVE THE DEFINED SPECIAL CHAR?
;DISABLED		SETOM	CENTER		;YES, CENTERED
;DISABLED		ADD	T1,CHRTBL	;FIND OUT ADDRESS OF CHAR'S DESCRIPTION
;DISABLED		MOVE	T1,(T1)		;GET THAT
;DISABLED		MOVE	TEMP,@1(ARG)	;GET X COORDINATE
;DISABLED		CAMN	TEMP,STAPUT	;IF ITS A FUNNY COORDINATE
;DISABLED		MOVE	TEMP,STRX	;GET LAST X COORDINATE
;DISABLED		MOVEM	TEMP,PLTSX	;SET UP REFERENCE COORDINATE WITH IT
;DISABLED		MOVE	TEMP,@2(ARG)	;GET Y COORDINATE
;DISABLED		CAMN	TEMP,STAPUT	;IF ITS A FUNNY COORDINATE
;DISABLED		MOVE	TEMP,STRY	;GET LAST Y COORDINATE
;DISABLED		MOVEM	TEMP,PLTSY	;SET UP REFERENCE COORDINATE WITH IT
;DISABLED		HLRZ	TEMP,T1		;CHECK IF NUMBER OF LINES TO PLOT=0
;DISABLED		SKIPN	TEMP		;IF SO
;DISABLED		GOTO	PLSMEX		;WHY BOTHER?
;DISABLED		HRLI	T1,(POINT 4,0)	;ELSE, SET UP BYTE POINTER
;DISABLED		SAVE	T2
;DISABLED		SAVE	T3
;DISABLED		SAVE	ARG
;DISABLED		MOVEI	ARG,PLTBLK	;POINT TO COORDINATES TO PLOT TO
;DISABLED		SETOM	MOVFLG		;TURN ON MOVING FLAG
;DISABLED	
;DISABLED	PLTLOP:	ILDB	T2,T1		;GET FIRST BYTE, RELATIVE X
;DISABLED		ILDB	T3,T1		;GET NEXT BYTE, RELATIVE Y
;DISABLED		CAIN	T2,11		;IF FIRST IS 11, THEN WE ARE MOVING
;DISABLED		SETOM	MOVFLG
;DISABLED		CAIN	T2,11
;DISABLED		GOTO	EPLOOP		;IF MOVING FLAG, FORGET THIS LOOP
;DISABLED		SAVE	TEMP
;DISABLED		SAVE	T1
;DISABLED		FLTR	T2,T2		;MAKE X COORDINATE REAL
;DISABLED		MOVE	TEMP,T2		;SET UP FOR TRANSLATION
;DISABLED		FLTR	T3,T3		;MAKE Y-COORDINATE REAL
;DISABLED		MOVE	T1,T3		;ROTATE BY SAVSIN & SAVCOS
;DISABLED		FMPR	T2,SAVCOS
;DISABLED		FMPR	T1,SAVSIN
;DISABLED		FSBR	T2,T1
;DISABLED		FMPR	TEMP,SAVSIN
;DISABLED		FMPR	T3,SAVCOS
;DISABLED		FADR	T3,TEMP
;DISABLED		SKIPE	CENTER		;CENTERED?
;DISABLED		GOTO	OUTPLS		;NOPE, GO CENTER IT
;DISABLED		FADR	T2,PLTSX	;ELSE, ADD IN COORDINATE OF SYMBOL
;DISABLED		FADR	T3,PLTSY	;FOR BOTH X AND Y
;DISABLED		SKIPE	MOVFLG		;IF MOVING
;DISABLED		CALL	PMOVE		;GO MOVE THE PEN
;DISABLED		SKIPN	MOVFLG		;ELSE
;DISABLED		CALL	PDRAW		;DRAW
;DISABLED		SETZM	MOVFLG		;NEXT WILL BE DRAW BY DEFAULT
;DISABLED		GOTO	RESLOP		;AND GO LOOP AGAIN
;DISABLED	
;DISABLED	OUTPLS:	MOVN	T2,T2		;CENTERING
;DISABLED		FADRM	T2,PLTSX	;GET CHAR TO CENTER AROUND IN X
;DISABLED		MOVN	T3,T3
;DISABLED		FADRM	T3,PLTSY	;AND Y
;DISABLED		SETZM	CENTER		;NO NEED TO CENTER ANY MORE
;DISABLED	
;DISABLED	RESLOP:	RESTORE	T1
;DISABLED		RESTORE	TEMP
;DISABLED	EPLOOP:	SOJG	TEMP,PLTLOP	;ANY MORE CHAR?  IF SO, GO BACK
;DISABLED	
;DISABLED		RESTORE	ARG
;DISABLED		RESTORE	T3
;DISABLED		RESTORE	T2
;DISABLED	PLSMEX:	MOVE	TEMP,SAVCOS	;GET CURRENT X INCREMENT
;DISABLED		FMPR	TEMP,SIZGRD	;GO OVER BY SIZE OF GRID
;DISABLED		FADRM	TEMP,STRX	;PUT THAT IN X POSITION
;DISABLED		MOVE	TEMP,SAVSIN	;SAME FOR Y
;DISABLED		FMPR	TEMP,SIZGRD
;DISABLED		FADRM	TEMP,STRY
;DISABLED		RETURN
;DISABLED	
;DISABLED		-2,,0			;ARGUMENT BLOCK TO PMOVE/PDRAW
;DISABLED	PLTBLK:	T2
;DISABLED		T3
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PSTR( STRING, X, Y, HEIGHT, ANGLE, NCHAR )	PLOT STRING
;DISABLED	
;DISABLED		ENTRY	PSTR
;DISABLED	PSTR:	SKIPN	PLTMOD		;MUST BE IN PLOT MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PSTR.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGUMENTS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,6		;IF NOT 6
;DISABLED		FATAL(MH6 MUST HAVE 6 ARGUMENTS FOR ROUTINE PSTR.)
;DISABLED		MOVE	TEMP,@1(ARG)	;GET X COORDINATE
;DISABLED		CAME	TEMP,STAPUT	;IF IT ISN'T FLAG TO INDICATE NO MOVE
;DISABLED		MOVEM	TEMP,STRX	;STICK IT IN BLOCK SO WE'LL MOVE
;DISABLED		MOVE	TEMP,@2(ARG)	;SAME FOR Y
;DISABLED		CAME	TEMP,STAPUT
;DISABLED		MOVEM	TEMP,STRY
;DISABLED		MOVE	TEMP,@3(ARG)	;GET CHARACTER HEIGHT
;DISABLED		MOVEM	TEMP,STRHGH	;REMEMBER THAT IN BLOCK
;DISABLED		MOVE	TEMP,@4(ARG)	;AND ANGLE
;DISABLED		MOVEM	TEMP,STRANG	;STORE THAT TOO
;DISABLED		SKIPG	T14,@5(ARG)	;GET NUMBER OF CHARACTERS TO PLOT
;DISABLED		RETURN			;IF CHARS <= 0, DON'T BOTHER
;DISABLED		HRLI	TEMP,(POINT 7,0)	;ELSE, SET UP POINTER TO GET
;DISABLED		HRRI	TEMP,@0(ARG)	;CHAR'S AND ADD IN ADDRESS
;DISABLED		MOVEM	TEMP,PBPTR	;REMEMBER THAT
;DISABLED		SAVE	ARG
;DISABLED		MOVEI	ARG,STRBLK	;SET UP FOR CALL TO PSYM
;DISABLED	
;DISABLED	PSLOOP:	ILDB	TEMP,PBPTR	;GET NEXT CHARACTER
;DISABLED		MOVEM	TEMP,STRCHR	;STICK THAT IN ARG BLOCK FOR PLTSYM
;DISABLED		CALL	PLTSYM		;PLOT THAT SYMBOL
;DISABLED		SOJG	T14,PSLOOP	;IF MORE CHAR, GET THEM
;DISABLED		RESTORE	ARG
;DISABLED		RETURN
;DISABLED	
;DISABLED		-5,,0
;DISABLED	STRBLK:	STRCHR			;ARG BLOCK FOR PLTSYM
;DISABLED		STRX
;DISABLED		STRY
;DISABLED		STRHGH
;DISABLED		STRANG
;DISABLED	
;DISABLED	
;DISABLED	;	CALL PNUM( FLONUM, X, Y, HEIGHT, ANGLE, NDEC )
;DISABLED	
;DISABLED		ENTRY	PNUM
;DISABLED	PNUM:	SKIPN	PLTMOD		;MUST BE IN PLOTTING MODE
;DISABLED		FATAL(MCP MUST CALL PENTER BEFORE CALLING PNUM.)
;DISABLED		MOVN	TEMP,-1(ARG)	;CHECK NUMBER OF ARGS
;DISABLED		HLRZ	TEMP,TEMP	;ON RIGHT HALF
;DISABLED		CAIE	TEMP,6		;IF NOT 6
;DISABLED		FATAL(MH6 MUST HAVE 6 ARGUMENTS FOR ROUTINE PNUM.)
;DISABLED		MOVE	TEMP,@1(ARG)	;GET X COORDINATE
;DISABLED		CAME	TEMP,STAPUT	;IF NOT FUNNY COORDINATE
;DISABLED		MOVEM	TEMP,STRX	;REMEMBER IT
;DISABLED		MOVE	TEMP,@2(ARG)	;GET Y COORDINATE
;DISABLED		CAME	TEMP,STAPUT	;IF NOT FUNNY COORDINATE
;DISABLED		MOVEM	TEMP,STRY	;REMEMBER IT
;DISABLED		MOVE	TEMP,@3(ARG)	;GET HEIGHT
;DISABLED		MOVEM	TEMP,STRHGH	;REMEMBER IT
;DISABLED		MOVE	TEMP,@4(ARG)	;GET ANGLE
;DISABLED		MOVEM	TEMP,STRANG	;REMEMBER IT
;DISABLED		MOVE	TEMP,@5(ARG)	;GET NUMBER OF CHAR TO RIGHT OF .
;DISABLED		MOVEM	TEMP,NDEC	;REMEMBER IT
;DISABLED		MOVE	TEMP,@0(ARG)	;GET NUMBER TO PLOT
;DISABLED		SAVE	T2
;DISABLED		SAVE	T3
;DISABLED		SAVE	ARG
;DISABLED		MOVEI	ARG,STRBLK	;SET UP TO CALL PLTSYM
;DISABLED		SKIPL	TEMP		;IS THIS NEGATIVE
;DISABLED		GOTO	NOTNEG		;NOPE, SKIP THIS
;DISABLED		SAVE	TEMP		;SET UP TO PLOT A HYPHEN
;DISABLED		MOVEI	T1,"-"		;GET A HYPHEN TO PLOT
;DISABLED		MOVEM	T1,STRCHR	;STICK IN THE ARGUMENT BLOCK
;DISABLED		CALL	PLTSYM		;AND PLOT IT
;DISABLED		RESTORE	TEMP
;DISABLED		MOVN	TEMP,TEMP	;GET THE NEGATIVE OF THE NUMBER
;DISABLED	
;DISABLED	NOTNEG:	FIX	T1,TEMP		;GET INTEGER PART OF NUMBER
;DISABLED		SAVE	TEMP
;DISABLED		SAVE	T1
;DISABLED		SETZ	T3,
;DISABLED		CALL	OUTINT		;AND OUTPUT IT
;DISABLED		SKIPGE	NDEC		;ANY POINT TO PRINT?
;DISABLED		GOTO	FASTEX		;NOPE, EXIT NOW
;DISABLED		MOVEI	TEMP,"."	;ELSE PRINT A POINT
;DISABLED		MOVEM	TEMP,STRCHR	;BY STICKING ONE INTO ARG BLOCK
;DISABLED		CALL	PLTSYM		;AND PLOTTING IT
;DISABLED		RESTORE	T1
;DISABLED		RESTORE	TEMP
;DISABLED		SKIPG	NDEC		;ANYTHING TO RIGHT OF .
;DISABLED		GOTO	DONE		;NOPE, EXIT
;DISABLED		FLTR	T1,T1		;TAKE THAT INTEGER PART
;DISABLED		FSBR	TEMP,T1		;SUBTRACT IT FROM THE REAL PART
;DISABLED		MOVE	T1,TEMP
;DISABLED		MOVE	TEMP,NDEC	;GET NUMBER OF TIMES TO LOOP FOR POWER
;DISABLED	PLOOP:	FMPR	T1,[10.0]	;MULTIPLY NUMBER BY 10
;DISABLED		SOJG	TEMP,PLOOP	;UNTIL IT IS CORRECT NUMBER PLACES
;DISABLED		FIXR	T1,T1		;MAKE IT AN INTEGER
;DISABLED		MOVE	T3,NDEC		;SPECIFY NUMBER OF PLACES
;DISABLED		CALL	OUTINT		;AND OUTPUT THE INTEGER
;DISABLED		GOTO	DONE		;AND LEAVE
;DISABLED	
;DISABLED	FASTEX:	RESTORE	T1		;IF NO DECIMAL POINT, CLEAR OFF STACK
;DISABLED		RESTORE	TEMP
;DISABLED	DONE:	RESTORE	ARG
;DISABLED		RESTORE	T3
;DISABLED		RESTORE	T2
;DISABLED		RETURN
;DISABLED	
;DISABLED	OUTINT:	SETZ	TEMP,		;ZERO NUMBER OF DIGITS
;DISABLED	INTLOP:	IDIVI	T1,^D10		;GET LAST DIGIT
;DISABLED		SAVE	T1+1		;STICK IT ON STACK
;DISABLED		ADDI	TEMP,1		;INCREMENT NUMBER OF DIGITS
;DISABLED		JUMPN	T1,INTLOP	;AND GO BACK FOR ANOTHER
;DISABLED		CAMGE	TEMP,T3		;IF WE'RE HAVE MORE DIGITS
;DISABLED		GOTO	INTLOP		;GET THEM.
;DISABLED	
;DISABLED	OUTLOP:	RESTORE	T1		;NOW, REMOVE DIGITS ONE BY ONE
;DISABLED		ADDI	T1,"0"		;MAKE THEM ASCII
;DISABLED		MOVEM	T1,STRCHR	;STICK THEM IN PLOT BLOCK
;DISABLED		SAVE	TEMP		;SAVE NUMBER OF DIGITS
;DISABLED		CALL	PLTSYM		;PLOT IT
;DISABLED		RESTORE	TEMP
;DISABLED		SOJG	TEMP,OUTLOP	;AND GO BACK FOR ANOTHER DIGIT
;DISABLED		RETURN
;DISABLED	
;DISABLED	OCBLK:	PLTCHN
;DISABLED		CTOUT
;DISABLED	
;DISABLED		EXTERN	FILPUT
;DISABLED	FILPCL:	SKIPN	PLTCHN		;DO BUFFERED IO IF CHAN <> 0
;DISABLED		GOTO	NONBFR		;IF NOT BUFFERED, GO DO IONEOU'S
;DISABLED		SAVE	ARG		;DESTROYED TO CALL TO FILPUT
;DISABLED		MOVEI	ARG,OCBLK	;GET ARG BLOCK FOR IT
;DISABLED		MOVEM	T1,CTOUT	;AND SAVE THE CHARACTER
;DISABLED		CALL	FILPUT		;DUMP THE CHAR
;DISABLED		RESTORE	ARG
;DISABLED		RETURN
;DISABLED	
;DISABLED	NONBFR:	IONEOU	T1		;OUTPUT THE CHARACTER
;DISABLED		RETURN			;AND LEAVE
;DISABLED	
;DISABLED		EXTERN	OUTBUF
;DISABLED	FILDMP:	SAVE	ARG		;DESTROYED TO CALL TO OUTBUF
;DISABLED		MOVEI	ARG,[PLTCHN]	;GET A BLOCK POINTING TO THE CHANNEL
;DISABLED		SKIPE	PLTCHN		;DON'T BOTHER IF NO CHANNEL
;DISABLED		CALL	OUTBUF		;DUMP THE CHANNEL
;DISABLED		RESTORE	ARG
;DISABLED		RETURN
;DISABLED	
;DISABLED	
;DISABLED	;************** CHARACTER GENERATION TABLES ***************
;DISABLED	;
;DISABLED	;	LEFT HALF:  NUMBER OF LINE SEGMENTS IN CHARACTER.
;DISABLED	;			NOTE: A PEN UP COMMAND OF 11,0 IS
;DISABLED	;				CONSIDERED A LINE SEGMENT.
;DISABLED	;
;DISABLED	;	RIGHT HALF:  ADDRESS OF BYTE TABLE DESCRIBING SEGMENTS.
;DISABLED	;
;DISABLED	;FORMAT OF BYTE TABLES ARE:
;DISABLED	;
;DISABLED	;	BYTES ARE 4 BITS, 2 BYTES PER LINE SEGMENT IN THE ORDER
;DISABLED	;	X,Y  OR 11,0 FOR PEN UP ON NEXT MOVE.
;DISABLED	
;DISABLED	TBL1:	;THIS IS THE CHARACTER TABLE START
;DISABLED	
;DISABLED		RADIX 10		;SET FOLLOWING NUMBERS TO BE DECIMAL
;DISABLED	
;DISABLED		;FIRST....CENTERED TYPE SYMBOLS
;DISABLED	
;DISABLED		9,,SQUARE		;CENTERED SQUARE	0
;DISABLED		13,,CIRCLE		;CENTERED CIRCLE	1
;DISABLED		7,,TRIANG		;CENTERED TRIANGLE	2
;DISABLED		8,,CPLUS		;CENTERED PLUS		3
;DISABLED		8,,CENTX		;CENTERED X		4
;DISABLED		8,,DIAMND		;CENTERED DIAMOND	5
;DISABLED		8,,ARROW.		;CENTERED ARROW		6
;DISABLED		9,,CBARX		;CENTERED BAR X		7
;DISABLED		12,,CENTZ		;CENTERED Z		8
;DISABLED		8,,CENTY		;CENTERED Y		9
;DISABLED		15,,LOSENG		;CENTERED LOSENGE	10
;DISABLED		14,,CENAST		;CENTERED ASTERICK	11
;DISABLED		7,,C2BARX		;CENTERED 2 BAR X	12
;DISABLED		5,,TICMRK		;CENTERED TIC MARK	13
;DISABLED		12,,STAR.		;CENTERED STAR		14
;DISABLED		5,,CXVECT		;X VECTOR		15
;DISABLED		5,,CYVECT		;Y VECTOR		16
;DISABLED		17,,ONLINE		;UNH LOGO		17
;DISABLED		34,,GRID		;GRID			18
;DISABLED	
;DISABLED		NSPCSM=.-TBL1
;DISABLED		BLOCK	<32-NSPCSM>	; UNUSED TABLE SPACE
;DISABLED	
;DISABLED		;NORMAL......ALPHA-NUMERICS
;DISABLED	
;DISABLED		0,,0			;BLANK (SPACE)		32
;DISABLED		5,,EXCLAM		;!			33
;DISABLED		9,,QUOTES		;"			34
;DISABLED		11,,NMBRSN		;#			35
;DISABLED		16,,DOLRSN		;$			36
;DISABLED		14,,PRCTSN		;%			37
;DISABLED		10,,AMPRSN		;&			38
;DISABLED		4,,APOST		;'			39
;DISABLED		6,,LPAREN		;(			40
;DISABLED		6,,RPAREN		;)			41
;DISABLED		8,,ASTERK		;*			42
;DISABLED		5,,PLUS			;+			43
;DISABLED		6,,COMMA		;,			44
;DISABLED		2,,MINUS		;-			45
;DISABLED		5,,PERIOD		;.			46
;DISABLED		2,,SLASH		;/			47
;DISABLED		10,,N0			;0			48
;DISABLED		5,,N1			;1			49
;DISABLED		7,,N2			;2			50
;DISABLED		13,,N3			;3			51
;DISABLED		4,,N4			;4			52
;DISABLED		9,,N5			;5			53
;DISABLED		12,,N6			;6			54
;DISABLED		3,,N7			;7			55
;DISABLED		16,,N8			;8			56
;DISABLED		12,,N9			;9			57
;DISABLED		11,,COLON		;:			58
;DISABLED		12,,SEMCOL		;;			59
;DISABLED		3,,LTHAN		;LESS THAN		60
;DISABLED		5,,EQUAL		;=			61
;DISABLED		3,,GTHAN		;GREATER THAN		62
;DISABLED		10,,QUEST		;?			63
;DISABLED		15,,ATSIGN		;@			64
;DISABLED		7,,AA			;A			65
;DISABLED		11,,AB			;B			66
;DISABLED		8,,AC			;C			67
;DISABLED		7,,AD			;D			68
;DISABLED		7,,AE			;E			69
;DISABLED		6,,AF			;F			70
;DISABLED		10,,AG			;G			71
;DISABLED		6,,AH			;H			72
;DISABLED		6,,AI			;I			73
;DISABLED		5,,AJ			;J			74
;DISABLED		6,,AK			;K			75
;DISABLED		3,,AL			;L			76
;DISABLED		5,,AM			;M			77
;DISABLED		5,,AN			;N			78
;DISABLED		12,,AO			;O			79
;DISABLED		7,,APAP			;P			80
;DISABLED		12,,AQ			;Q			81
;DISABLED		9,,AR			;R			82
;DISABLED		12,,AS			;S			83
;DISABLED		4,,AT			;T			84
;DISABLED		6,,AU			;U			85
;DISABLED		3,,AV			;V			86
;DISABLED		9,,AW			;W			87
;DISABLED		5,,AX			;X			88
;DISABLED		5,,AY			;Y			89
;DISABLED		4,,AZ			;Z			90
;DISABLED		4,,LSQBRK		;[			91
;DISABLED		2,,RVSLSH		;\			92
;DISABLED		4,,RSQBRK		;]			93
;DISABLED		3,,UPARRW		;^			94
;DISABLED		2,,UNDRLN		;_			95
;DISABLED		2,,AGRV			; `			96
;DISABLED		12,,LA			;LOWER CASE A		97
;DISABLED		10,,LB			;LOWER CASE B		98
;DISABLED		8,,LC			;LOWER CASE C		99
;DISABLED		10,,LD			;LOWER CASE D		100
;DISABLED		10,,LE			;LOWER CASE E		101
;DISABLED		8,,LF			;LOWER CASE F		102
;DISABLED		12,,LG			;LOWER CASE G		103
;DISABLED		7,,LH			;LOWER CASE H		104
;DISABLED		8,,LI			;LOWER CASE I		105
;DISABLED		9,,LJ			;LOWER CASE J		106
;DISABLED		6,,LK			;LOWER CASE K		107
;DISABLED		5,,LL			;LOWER CASE L		108
;DISABLED		10,,LM			;LOWER CASE M		109
;DISABLED		7,,LN			;LOWER CASE N		110
;DISABLED		12,,LO			;LOWER CASE O		111
;DISABLED		9,,LP			;LOWER CASE P		112
;DISABLED		10,,LQ			;LOWER CASE Q		113
;DISABLED		6,,LR			;LOWER CASE R		114
;DISABLED		10,,LS			;LOWER CASE S		115
;DISABLED		8,,LT			;LOWER CASE T		116
;DISABLED		7,,LU			;LOWER CASE U		117
;DISABLED		3,,LV			;LOWER CASE V		118
;DISABLED		9,,LW			;LOWER CASE W		119
;DISABLED		5,,LX			;LOWER CASE X		120
;DISABLED		10,,LY			;LOWER CASE Y		121
;DISABLED		4,,LZ			;LOWER CASE Z		122
;DISABLED		9,,LBRAC		; {			123
;DISABLED		2,,VBAR			; |			124
;DISABLED		9,,RBRAC		; }			125
;DISABLED		4,,TILDE		; ~			126
;DISABLED		BLOCK	1		; <DEL>			127
;DISABLED	
;DISABLED	;********** END OF CHARACTER GENERATION TABLES ************
;DISABLED	
;DISABLED	;
;DISABLED	;THE FOLLOWING ARE THE BYTE TABLES FOR THE SYMBOLS AS DEFINED
;DISABLED	; BY TBL1 (THE CHARACTER TABLE).
;DISABLED	;
;DISABLED	;THE BYTE TABLE IS MADE UP OF 4-BIT BYTES, IN ORDERED PAIRS (X,Y).
;DISABLED	;WHERE X IS EITHER THE LINE SEGMENT WANTED OR PENUP COMMAND.
;DISABLED	; AND Y IS EITHER LINE SEGMENT WNTED OR ZERO WHEN X IS PENUP COMMAND.
;DISABLED	
;DISABLED		RADIX 8
;DISABLED	
;DISABLED		;;;CENTERED.....SYMBOLS BYTE TABLES
;DISABLED	
;DISABLED	SQUARE: BYTE (4) 2,2,2,4,0,4,0,0,4,0,4,4,2,4,11,0,2,2
;DISABLED	CIRCLE:	BYTE (4) 2,2,2,4,1,4,0,3,0,1,1,0,3,0,4,1,4,3,3,4,2,4,11,0,2,2
;DISABLED	TRIANG:	BYTE (4) 2,2,2,4,0,1,4,1,2,4,11,0,2,2
;DISABLED	CPLUS:	BYTE (4) 2,2,2,4,2,0,2,2,0,2,4,2,11,0,2,2
;DISABLED	CENTX:	BYTE (4) 2,2,0,4,4,0,2,2,0,0,4,4,11,0,2,2
;DISABLED	DIAMND:	BYTE (4) 2,2,2,4,0,2,2,0,4,2,2,4,11,0,2,2
;DISABLED	ARROW.:	BYTE (4) 2,2,0,2,2,4,2,0,2,4,4,2,11,0,2,2
;DISABLED	CBARX:	BYTE (4) 2,2,0,4,4,4,2,2,0,0,2,2,4,0,11,0,2,2
;DISABLED	CENTZ:	BYTE (4) 2,2,1,2,3,2,2,2,4,4,0,4,4,4,0,0,4,0,0,0,11,0,2,2
;DISABLED	CENTY:	BYTE (4) 2,2,0,4,2,2,4,4,2,2,2,0,11,0,2,2
;DISABLED	LOSENG:	BYTE (4) 2,2,4,4,3,3,1,3,0,4,1,3,1,1,0,0,1,1
;DISABLED		BYTE (4) 3,1,4,0,3,1,3,3,11,0,2,2
;DISABLED	CENAST:	BYTE (4) 2,2,2,4,2,0,2,2,0,2,4,2,2,2,0,4,4,0
;DISABLED		BYTE (4) 2,2,0,0,4,4,11,0,2,2
;DISABLED	C2BARX:	BYTE (4) 2,2,0,4,4,4,0,0,4,0,11,0,2,2
;DISABLED	TICMRK:	BYTE (4) 2,2,2,4,2,0,11,0,2,2
;DISABLED	STAR.:	BYTE (4) 2,2,2,4,0,1,4,1,2,4,11,0,0,3,2,0,4,3,0,3,11,0,2,2
;DISABLED	CXVECT:	BYTE (4) 2,2,2,2,2,6,11,0,2,2
;DISABLED	CYVECT:	BYTE (4) 2,2,2,2,6,2,11,0,2,2
;DISABLED	;DEFINE THE PLOTTER CONTROL CODES FOR THE UNH CC LOGO.
;DISABLED	ONLINE:	BYTE (4) 3,5,1,4,2,5,3,4,2,3,1,4,11,0,3,10,3,3
;DISABLED		BYTE (4) 5,3,11,0,6,2,0,2,3,10,6,2,11,0,3,5
;DISABLED	GRID:	BYTE (4) 3,4,0,0,6,0,6,1,0,1,0,2,6,2,6,3,0,3
;DISABLED		BYTE (4) 0,4,6,4,6,5,0,5,0,6,6,6,6,7,0,7,0,10
;DISABLED		BYTE (4) 6,10,6,0,5,0,5,10,4,10,4,0,3,0,3,10,2,10
;DISABLED		BYTE (4) 2,0,1,0,1,10,0,10,0,0,11,0,3,4
;DISABLED	
;DISABLED		;;;END OF SPECIAL SYMBOLS ;;;
;DISABLED	
;DISABLED		;BYTE TABLE FOR ALPHA-NUMBERICS AND NON-CENTERED SPECIAL
;DISABLED		;CHARACTERS.
;DISABLED	
;DISABLED	EXCLAM:	BYTE (4) 2,2,2,3,11,0,2,4,2,10
;DISABLED	QUOTES:	BYTE (4) 1,10,0,10,1,7,1,10,11,0,3,7,2,10,3,10,3,7
;DISABLED	NMBRSN:	BYTE (4) 0,6,4,6,11,0,3,7,3,3,11,0,1,7,1,3,11,0,0,4,4,4
;DISABLED	DOLRSN:	BYTE (4) 0,4,1,3,2,3,2,2,2,3,3,3,4,4,3,5,1,5,0,6,1,7,2,7,2,10,2
;DISABLED		BYTE (4) 7,3,7,4,6
;DISABLED	PRCTSN:	BYTE (4) 2,7,1,10,0,7,1,6,2,7,11,0,4,10,0,2,11,0
;DISABLED		BYTE (4) 3,2,2,3,3,4,4,3,3,2
;DISABLED	AMPRSN:	BYTE (4) 4,4,1,2,0,3,0,4,2,6,2,7,1,10,0,7,0,6,4,2
;DISABLED	APOST:	BYTE (4) 2,7,1,10,2,10,2,7
;DISABLED	LPAREN:	BYTE (4) 4,10,3,10,2,7,2,3,3,2,4,2
;DISABLED	RPAREN:	BYTE (4) 0,10,1,10,2,7,2,3,1,2,0,2
;DISABLED	ASTERK:	BYTE (4) 4,7,0,3,11,0,2,2,2,10,11,0,0,7,4,3
;DISABLED	PLUS:	BYTE (4) 0,5,4,5,11,0,2,7,2,3
;DISABLED	COMMA:	BYTE (4) 2,1,3,2,3,3,2,3,2,2,3,2
;DISABLED	MINUS:	BYTE (4) 0,5,4,5
;DISABLED	PERIOD:	BYTE (4) 3,2,2,2,2,3,3,3,3,2
;DISABLED	SLASH:	BYTE (4) 0,2,4,10
;DISABLED	N0:	BYTE (4) 2,2,1,2,0,3,0,7,1,10,3,10,4,7,4,3,3,2,2,2
;DISABLED	N1:	BYTE (4) 1,7,2,10,2,2,1,2,3,2
;DISABLED	N2:	BYTE (4) 0,7,1,10,3,10,4,7,4,6,0,2,4,2
;DISABLED	N3:	BYTE (4) 0,7,1,10,3,10,4,7,4,6,3,5,1,5,3,5,4,4,4,3,3,2,1,2,0,3
;DISABLED	N4:	BYTE (4) 4,2,4,10,0,4,5,4
;DISABLED	N5:	BYTE (4) 0,3,1,2,3,2,4,3,4,5,3,6,0,6,0,10,4,10
;DISABLED	N6:	BYTE (4) 0,5,1,6,3,6,4,5,4,3,3,2,1,2,0,3,0,7,1,10,3,10,4,7
;DISABLED	N7:	BYTE (4) 0,10,4,10,1,2
;DISABLED	N8:	BYTE (4) 1,5,0,6,0,7,1,10,3,10,4,7,4,6,3,5,1,5
;DISABLED		BYTE (4) 0,4,0,3,1,2,3,2,4,3,4,4,3,5
;DISABLED	N9:	BYTE (4) 0,3,1,2,3,2,4,3,4,7,3,10,1,10,0,7,0,5,1,4,3,4,4,5
;DISABLED	COLON:	BYTE (4) 2,4,2,3,3,3,3,4,2,4,11,0,3,6,3,7,2,7,2,6,3,6
;DISABLED	SEMCOL:	BYTE (4) 2,1,3,2,3,3,2,3,2,2,3,2,11,0,3,5,3,6,2,6,2,5,3,5
;DISABLED	LTHAN:	BYTE (4) 4,3,0,5,4,7
;DISABLED	EQUAL:	BYTE (4) 4,6,0,6,11,0,0,4,4,4
;DISABLED	GTHAN:	BYTE (4) 0,7,4,5,0,3
;DISABLED	QUEST:	BYTE (4) 0,7,1,10,3,10,4,7,4,6,2,5,2,4,11,0,2,3,2,2
;DISABLED	ATSIGN:	BYTE (4) 4,5,3,4,2,4,1,5,2,6,3,6,4,5,4,7,3,10
;DISABLED		BYTE (4) 1,10,0,7,0,3,1,2,3,2,4,3
;DISABLED	AA:	BYTE (4) 4,2,4,6,2,10,0,6,0,2,0,4,4,4
;DISABLED	AB:	BYTE (4) 0,5,3,5,4,6,4,7,3,10,0,10,0,2,3,2,4,3,4,4,3,5
;DISABLED	AC:	BYTE (4) 4,3,3,2,1,2,0,3,0,7,1,10,3,10,4,7
;DISABLED	AD:	BYTE (4) 0,2,3,2,4,3,4,7,3,10,0,10,0,2
;DISABLED	AE:	BYTE (4) 4,2,0,2,0,5,3,5,0,5,0,10,4,10
;DISABLED	AF:	BYTE (4) 0,2,0,5,3,5,0,5,0,10,4,10
;DISABLED	AG:	BYTE (4) 4,7,3,10,1,10,0,7,0,3,1,2,3,2,4,3,4,5,2,5
;DISABLED	AH:	BYTE (4) 0,2,0,10,0,5,4,5,4,10,4,2
;DISABLED	AI:	BYTE (4) 1,10,3,10,2,10,2,2,1,2,3,2
;DISABLED	AJ:	BYTE (4) 0,3,1,2,3,2,4,3,4,10
;DISABLED	AK:	BYTE (4) 0,2,0,10,0,4,4,10,1,5,4,2
;DISABLED	AL:	BYTE (4) 0,10,0,2,4,2
;DISABLED	AM:	BYTE (4) 0,2,0,10,2,6,4,10,4,2
;DISABLED	AN:	BYTE (4) 0,2,0,10,4,4,4,10,4,2
;DISABLED	AO:	BYTE (4) 0,3,0,7,1,10,3,10,4,7,4,3,3,2,1,2,0,3,11,0,3,7,4,10
;DISABLED	APAP:	BYTE (4) 0,2,0,10,3,10,4,7,4,6,3,5,0,5
;DISABLED	AQ:	BYTE (4) 0,3,0,7,1,10,3,10,4,7,4,3,3,2,1,2,0,3,11,0,2,4,4,2
;DISABLED	AR:	BYTE (4) 0,2,0,10,3,10,4,7,4,6,3,5,0,5,1,5,4,2
;DISABLED	AS:	BYTE (4) 0,3,1,2,3,2,4,3,4,4,3,5,1,5,0,6,0,7,1,10,3,10,4,7
;DISABLED	AT:	BYTE (4) 2,2,2,10,0,10,4,10
;DISABLED	AU:	BYTE (4) 0,10,0,3,1,2,3,2,4,3,4,10
;DISABLED	AV:	BYTE (4) 0,10,2,2,4,10
;DISABLED	AW:	BYTE (4) 0,10,0,3,1,2,2,3,2,5,2,3,3,2,4,3,4,10
;DISABLED	AX:	BYTE (4) 0,2,4,10,11,0,0,10,4,2
;DISABLED	AY:	BYTE (4) 0,10,2,5,2,2,2,5,4,10
;DISABLED	AZ:	BYTE (4) 0,10,4,10,0,2,4,2
;DISABLED	LSQBRK:	BYTE (4) 4,10,2,10,2,2,4,2
;DISABLED	RVSLSH:	BYTE (4) 0,10,4,2
;DISABLED	RSQBRK:	BYTE (4) 0,10,2,10,2,2,0,2
;DISABLED	UPARRW:	BYTE (4) 0,6,2,10,4,6
;DISABLED	UNDRLN:	BYTE (4) 0,1,4,1
;DISABLED	AGRV:	BYTE (4) 0,10,2,6
;DISABLED	LA:	BYTE (4) 0,5,1,6,3,6,4,5,4,3,3,2,1,2,0,3,1,4,3,4,4,3,4,2
;DISABLED	LB:	BYTE (4) 0,10,0,7,0,3,1,2,3,2,4,3,4,5,3,6,1,6,0,5
;DISABLED	LC:	BYTE (4) 4,3,3,2,1,2,0,3,0,5,1,6,3,6,4,5
;DISABLED	LD:	BYTE (4) 4,3,3,2,1,2,0,3,0,5,1,6,3,6,4,5,4,10,4,2
;DISABLED	LE:	BYTE (4) 0,4,4,4,4,5,3,6,1,6,0,5,0,3,1,2,3,2,4,3
;DISABLED	LF:	BYTE (4) 1,2,1,7,2,10,3,10,4,7,11,0,0,5,3,5
;DISABLED	LG:	BYTE (4) 0,1,1,0,3,0,4,1,4,5,3,6,1,6,0,5,0,3,1,2,3,2,4,3
;DISABLED	LH:	BYTE (4) 0,2,0,10,0,5,1,6,3,6,4,5,4,2
;DISABLED	LI:	BYTE (4) 2,10,2,7,11,0,1,6,2,6,2,2,1,2,3,2
;DISABLED	LJ:	BYTE (4) 0,1,1,0,2,0,3,1,3,6,2,6,11,0,3,7,3,10
;DISABLED	LK:	BYTE (4) 1,2,1,10,1,3,4,6,2,4,4,2
;DISABLED	LL:	BYTE (4) 1,10,2,10,2,2,1,2,3,2
;DISABLED	LM:	BYTE (4) 0,2,0,6,0,5,1,6,2,5,2,2,2,5,3,6,4,5,4,2
;DISABLED	LN:	BYTE (4) 0,2,0,6,0,5,1,6,3,6,4,5,4,2
;DISABLED	LO:	BYTE (4) 0,3,0,5,1,6,3,6,4,5,4,3,3,2,1,2,0,3,11,0,3,5,4,6
;DISABLED	LP:	BYTE (4) 0,0,0,5,1,6,3,6,4,5,4,3,3,2,1,2,0,3
;DISABLED	LQ:	BYTE (4) 4,3,3,2,1,2,0,3,0,5,1,6,3,6,4,5,4,0,5,0
;DISABLED	LR:	BYTE (4) 0,2,0,6,0,5,1,6,3,6,4,5
;DISABLED	LS:	BYTE (4) 0,3,1,2,3,2,4,3,3,4,1,4,0,5,1,6,3,6,4,5
;DISABLED	LT:	BYTE (4) 2,10,2,6,1,6,3,6,2,6,2,3,3,2,4,3
;DISABLED	LU:	BYTE (4) 0,6,0,3,1,2,3,2,4,3,4,6,4,2
;DISABLED	LV:	BYTE (4) 0,6,2,2,4,6
;DISABLED	LW:	BYTE (4) 0,6,0,3,1,2,2,3,2,4,2,3,3,2,4,3,4,6
;DISABLED	LX:	BYTE (4) 0,2,4,6,11,0,0,6,4,2
;DISABLED	LY:	BYTE (4) 0,6,0,3,1,2,3,2,4,3,4,6,4,1,3,0,1,0,0,1
;DISABLED	LZ:	BYTE (4) 0,6,4,6,0,2,4,2
;DISABLED	LBRAC:	BYTE (4) 4,10,3,10,2,7,2,6,1,5,2,4,2,3,3,2,4,2
;DISABLED	VBAR:	BYTE (4) 2,10,2,2
;DISABLED	RBRAC:	BYTE (4) 0,10,1,10,2,7,2,6,3,5,2,4,2,3,1,2,0,2
;DISABLED	TILDE:	BYTE (4) 0,7,1,10,3,6,4,7
;DISABLED	
;DISABLED		;;; END OF ALPHA-NUMERIC/SPECIAL BYTE TABLE ;;;
;DISABLED	
;DISABLED		PRGEND		>		; END IFN %HAVEPLOT

TITLE	I.O.				;PAGE 22
	SEARCH	PACK, UUOSYM
	EXTERN	ERRFLG




IFE %HISEG,	<TWOSEG 400000>
;	CALL CLOSE( CHAN )	CLOSE CHANNEL

	ENTRY	CLOSE
CLOSE:	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	LSH	TEMP,^D23	;MAKE IT INTO AC NUMBER
	TLO	TEMP,(RELEAS)	;MAKE IT A RELEASE INSTRUCTION
	XCT	TEMP		;RELEASE THE CHANNEL
	MOVE	TEMP,@0(ARG)	;GET CHANNEL AGAIN.
	CALL	DEALBF		;CHAN IN TEMP.
	RETURN


;	CALL AFILE( ICHAN )	;APPEND TO A FILE ALREADY OPENNED
;		OR
;	CALL AFILE( ICHAN, FILSPC )	;APPEND TO FILSPC

	ENTRY	AFILE
AFILE:	SAVE	T2		;SAVE SOME AC'S
	SAVE	T3
	SETZM	ERRFLG		;NO ERROR YET
	MOVN	T3,-1(ARG)	;GET NUMBER OF ARGS
	HLRZ	T3,T3		;ON RIGHT SIDE
	SOJE	T3,NOTRDW	;ONLY ONE ARG, FILE ALREADY OPENNED
	CALL	GETSPC		;ELSE, GET THE FILSPC
	TLO	T3,(LOOKUP 0,)	;MAKE IT A LOOKUP INSTRUCTION
	XCT	T3		;LOOKUP THAT FILE
	GOTO	APPERR		;OOPS, APPEND ERROR
	CALL	GETSPC		;NOW, GET THE FILSPC AGAIN
	TLO	T3,(ENTER 0,)	;SET UP FOR ENTER
	XCT	T3		;ENTER (NECESSARY FOR APPENDING)
	SKIPA
	GOTO	NOTRDW		;NO ERROR, GO TREAT AS IF FILE OPENNED

APPERR:	SETOM	ERRFLG		;SET THE ERROR FLAG
	HRRZ	TEMP,1(T3)	;GET THE ERROR CONDITION, RETURN IT
	SKIPE	EXTFLG		;IF EXTENDED FILSPC,
	HRRZ	TEMP,4(T3)	;GET IT FROM THAT BLOCK
	GOTO	APPEND		;AND LEAVE

NOTRDW:	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	LSH	TEMP,^D23	;MAKE IT LOOK LIKE AC FOR INSTRUCTION
	IOR	TEMP,[USETI 0,-1]	;MAKE IT USETI TO EOF
	XCT	TEMP		;GET TO END OF FILE
APPEND:	RESTORE	T3		;AND RESTORE THE WORLD
	RESTORE	T2
	RETURN


;	CALL WFILE( CHAN, FILESP )	SELECT FILE FOR WRITING
;					DEVICE MUST BE OPENNED

	ENTRY	WFILE
WFILE:	SAVE	T2		;SAVE SOME AC'S
	SAVE	T3
	SETZM	ERRFLG		;NO ERROR YET
	CALL	GETSPC		;GO GET THE FILSPC
	TLO	T3,(ENTER 0,)	;GET THE ENTER INSTRUCTION
	XCT	T3		;DO IT
	SETOM	ERRFLG		;FLAG ERROR
	MOVE	T1,@0(ARG)	;GET CHANNEL
	HLRZ	T1,HDRBLK(T1)	;GET LOC OF OUTPUT HEADER.
	SETZM	.BFPOS(T1)	;ZERO OUT OUTPUT POSITION
	HRRZ	TEMP,1(T3)	;GET ERROR CODE
	SKIPE	EXTFLG		;IF EXTENDED
	HRRZ	TEMP,4(T3)	;GET IT FROM RIGHT PLACE
	RESTORE	T3
	RESTORE	T2
	RETURN


;	CALL RFILE( CHAN, FILESP )	SELECT FILE FOR READING

	ENTRY	RFILE
RFILE:	SAVE	T2		;SAVE SOME AC'S
	SAVE	T3
	SETZM	ERRFLG		;NO ERROR YET
	CALL	GETSPC		;GET THE FILSPEC
	TLO	T3,(LOOKUP 0,)	;GET THE INSTRUCTION
	XCT	T3		;LOOKUP THE FILE
	SETOM	ERRFLG		;FLAG THE ERROR
	MOVE	TEMP,PROT	;GET THE PROTECTION
	LSH	TEMP,^D-27	;MAKE IT RIGHT JUSTIFIED
	MOVEM	TEMP,5(T1)	;AND MOVE IT BACK TO FILSPC ARRAY
	MOVE	T2,@0(ARG)	;GET CHANNEL
	CALL	HDRLOC		;GET LOC OF HEADER BLOCK.
	MOVE	T1,TEMP		;TRANSFER.
	SETZM	7(T1)		;ZERO OUT INPUT POSITION
	HRRZ	TEMP,1(T3)	;GET ERROR CODE
	SKIPE	EXTFLG		;OR IF IN EXTENDED MODE
	HRRZ	TEMP,4(T3)	;GET IT FROM EXTENDED BLOCK
	RESTORE	T3
	RESTORE	T2
	RETURN


;	CALL RNFILE( CHAN, FILESP )	RENAME CHAN TO FILESP

	ENTRY	RNFILE
RNFILE:	SAVE	T2		;SAVE SOME AC'S
	SAVE	T3
	SETZM	ERRFLG		;NO ERROR YET
	CALL	GETSPC		;GET FILSPC
	TLO	T3,(RENAME 0,)	;GET THE RENAME INSTRUCTION
	XCT	T3		;DO IT
	SETOM	ERRFLG		;FLAG THE ERROR
	HRRZ	TEMP,1(T3)	;GET THE ERROR CODE
	SKIPE	EXTFLG		;IF IN EXTENDED MODE
	HRRZ	TEMP,4(T2)	;GET FROM EXTENDED BLOCK
	RESTORE	T3
	RESTORE	T2
	RETURN

GETSPC:	SETZM	EXTFLG		;SET DEFAULT MODE
	MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGUMENTS
	HLRZ	TEMP,TEMP	;ON RIGHT SIDE
	MOVEI	T1,@1(ARG)	;GET ADDRESS OF ARRAY
	CAIL	TEMP,3		;IF 3 ARGUMENTS (ENTENDED MODE)
	SETOM	EXTFLG		;SET THE FLAG
	SKIPE	EXTFLG		;IF EXTENDED MODE
	MOVEI	T2,@2(ARG)	;GET ADDRESS OF EXTENDED BLOCK
	MOVE	T3,3(T1)	;GET FILE
	SKIPE	EXTFLG		;IF IN EXTENDED MODE
	MOVEM	T3,2(T2)	;PUT IN EXTENDED BLOCK
	MOVEM	T3,FILE		;PUT IN FILE BLOCK
	MOVE	T3,4(T1)	;GET EXTENSION
	SKIPE	EXTFLG
	HLLM	T3,3(T2)
	MOVEM	T3,EXT
	MOVE	T3,5(T1)	;GET PROTECTION
	LSH	T3,^D37		;LEFT JUSTIFY IT
	SKIPE	EXTFLG
	MOVEM	T3,4(T2)
	MOVEM	T3,PROT
	MOVEI	T3,PATBLK	;GET ADDRESS OF PATH BLOCK
	MOVEM	T3,PATHDR	;PUT IT IN FILE BLOCK
	HRL	T3,6(T1)	;GET P (OF PPN)
	HRR	T3,7(T1)	;AND PN (OF PPN)
	MOVEM	T3,PPN		;AND PUT IT IN FILE BLOCK
	MOVE	T3,10(T1)	;GET SFD1 ... SFD5
	MOVEM	T3,SFD		;AND PUT IN BLOCK
	MOVE	T3,11(T1)
	MOVEM	T3,SFD+1
	MOVE	T3,12(T1)
	MOVEM	T3,SFD+2
	MOVE	T3,13(T1)
	MOVEM	T3,SFD+3
	MOVE	T3,14(T1)
	MOVEM	T3,SFD+4
	MOVE	T3,@0(ARG)	;GET CHANNEL
	LSH	T3,^D23		;MAKE IT LOOK LIKE AN AC
	HRRI	T3,FILE		;AND RETURN THE FILE BLOCK
	SKIPN	EXTFLG		;IF NOT EXTENDED
	RETURN			;NO POINT IN CONTINUING
	HRR	T3,T2		;RETURN EXTENDED ADDRESS
	MOVE	TEMP,@3(ARG)	;GET LENGTH OF EXTENDED BLOCK
	MOVEM	TEMP,0(T2)	;STUFF THAT INTO ITS BEGINNING
	MOVEI	TEMP,PATBLK	;PUT THE PATH BLOCK ADDRESS IN IT TOO
	MOVEM	TEMP,1(T2)
	RETURN


;	CALL ORFILE( ICHAN, IDEV, IMODE )	OPEN DEVICE FOR READING
;		OR
;	CALL ORFILE( ICHAN, FILSPC, IMODE )

	ENTRY	ORFILE
ORFILE:	HRLZI	T1,777777	;SET TO READ ONLY MODE
	GOTO	OPFILE		;AND GO OPEN IT


;	CALL OWFILE( ICHAN, IDEV, IMODE )	OPEN DEVICE FOR WRITING
;		OR
;	CALL OWFILE( ICHAN, FILSPC, IMODE )

	ENTRY	OWFILE
OWFILE:	MOVEI	T1,777777	;SETUP TO OPEN IN WRITE ONLY MODE
	GOTO	OPFILE		;AND GO OPEN IT


;	CALL OFILE( ICHAN, IDEV, IMODE )	OPEN DEVICE FOR BOTH
;		OR
;	CALL OFILE( ICHAN, FILSPC, IMODE )

	ENTRY	OFILE
OFILE:	SETZ	T1,		;SETUP FOR BOTH READING AND WRITING

OPFILE:	SETZM	ERRFLG		;SET ERRORS OFF UNTIL WE CHECK CHAN
	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	CALL	ALLHDR		;SET UP HEADERS, AND BUFADR WORD
	MOVEI	T1,@1(ARG)	;GET ADDRESS OF ARRAY (OR IDEV)
	HLRZ	TEMP,0(T1)	;IF THE LEFT IS ZERO, NOT A DEVICE
	SKIPE	TEMP		;IF ITS NOT ZERO
	MOVE	TEMP,0(T1)	;GET IDEV
	SKIPN	TEMP		;ELSE, IF IT IS
	MOVE	TEMP,2(T1)	;GET DEVICE FROM FILSPC
	MOVEM	TEMP,DEV	;MOVE DEVICE INTO OPEN BLOCK
	MOVE	TEMP,@2(ARG)	;GET THE MODE
	MOVEM	TEMP,MODE	;PUT THAT IN THE OPEN BLOCK
	MOVE	TEMP,@0(ARG)	;GET CHANNEL AGAIN
	LSH	TEMP,^D23	;MAKE IT LOOK LIKE AN AC
	IOR	[OPEN 0,MODE]	;PUT IN THE OPEN INSTRUCTION
	XCT	TEMP		;OPEN THAT CHANNEL
	SETOM	ERRFLG		;FLAG ANY ERROR
	RETURN


ALLHDR:	MOVE	T2,TEMP		;SEE IF HEADERS ARE ALREADY DEFINED.
	HRRZ	T4,.JBREL	;GET HIGH LOC OF LOSEG.
	CALL	HDRLOC
	SETZ	T3,		;FLAG, IF -1, THEN ALLOCATED.
	SKIPE	TEMP		;IF ZERO, THEN NOT USED, ELSE DEFINED.
	CAML	TEMP,T4	;IF NOT IN OUR CORE SEG, RESET!
	SKIPA
	GOTO	HDRTHR		;IF THERE ALREADY, FORGET THE ALLOC.
	MOVEI	TEMP,^D8	;4 WORDS APIECE, HEAD,PTR,CNTR,POSITION.
	CALL	$ALLOC##	;ALLOCATE SPACE, PTR RETURNED IN TEMP
	SETO	T3,

HDRTHR:	HRLS	TEMP
	ADDI	TEMP,4		;OUTLOC,,INLOC OF HEADERS
	TDZN	TEMP,T1		;MASK OUT LOCS WE DONT WANT.
	MOVEM	TEMP,BUFADR	;SAVE LOCS OF HEADERS FOR OPEN UUO.
	MOVEM	TEMP,HDRBLK(T2)	;SAVE IN APPROPRIATE NICHE FOR LATER
	CALL	HDRLOC		;LOCATION OF HEADER IN TEMP
	MOVE	T2,TEMP		;TRANSFER.
	SKIPN	T3		;IF NOT INITED WE USE BUFFER, IF THERE
	GOTO	OLDHDR		;DONT INIT, REUSE OLD HEADER AND BUFS
	SETZM	(T2)	;FOR OUTPUT HEADER.
	SETZM	4(T2)	;INPUT HEADER.
OLDHDR:
	SETZM	2(T2)		;INIT OUTPUT COUNTER.
	SETZM	3(T2)		;INIT OUTPUT POSITION.
	SETZM	6(T2)		;INIT INPUT COUNTER.
	SETZM	7(T2)		;INIT INPUT POSITION.
	RETURN

;	CALL NBUFFR( NMINRN, BUFSIZ )
;	WHERE:	NMINRN	IS THE NUMBER OF BUFFERS REQUIRED IN ANY BUFFER
;			RING ON INPUT OR OUTPUT.  THE DEFAULT IS 2.
;		BUFSIZ	IS THE BUFFER SIZE WISHED.  FOR DISK IT SHOULD
;			ALWAYS BE 200(8) OR 128(10) WORDS.
;		NOTE:	IF EITHER ARGUMENT IS 0, THEN DEFAULT IS USED.


	ENTRY	NBUFFR
NBUFFR:	MOVEI	TEMP,%BFNUM	;GET DEFAULT NUM OF BUFS IN A RING.
	SKIPE	@0(ARG)		;IF 0 ARG, THEN USE DEFAULT,
	MOVE	TEMP,@0(ARG)	;ELSE USE ARGUMENT.
	MOVEM	TEMP,NUMBUF	;SAVE IT FOR LATER.
	MOVEI	TEMP,%BFSIZ	;GET DEFAULT BUFFER SIZE.
	SKIPE	@1(ARG)		;IF 0 ARG, THEN USE DEFAULT.
	MOVE	TEMP,@1(ARG)	;ELSE USE ARGUMENT.
	ADDI	TEMP,3		;PLUS 3 WORDS FOR BUF CTL BLOCK.
	MOVEM	TEMP,BUFSIZ
	RETURN			;AND RETURN.



HDRLOC:	HRRZ	TEMP,HDRBLK(T2)	;FIND TOP OF OBUF,IBUF HEADERS BLOCK
	SUBI	TEMP,4
	SKIPGE	TEMP
	HLRZ	TEMP,HDRBLK(T2)
	RETURN


ALLBUF:	SAVE	TEMP
	SAVE	T1
	SAVE	T2
	SAVE	T3
	SAVE	T4
	MOVE	TEMP,BUFSIZ	;DEFAULT BUFSIZ FOR ALL DEVICES.
	AOS	TEMP		;EXTRA WORD BETWEEN BUFFERS.
	IMUL	TEMP,NUMBUF	;MULT BY # OF BUFFERS IN A RING.
	CALL	$ALLOC##	;ALLOCATE SPACE FOR BUFFERS.
	AOS	TEMP		;HEADER HAS TO POINT TO
				;2ND WORD IN BUFFER CONTROL BLOCK, NOT
				;FIRST WORD, SO PUT POINTER AT 2ND WORD.
	TLO	TEMP,1B18	;FIXIT
	MOVEM	TEMP,(T3)	;LOC OF HEADER IN T3.
	HRRM	TEMP,1(T3)	;PUT IT IN BYTE POINTER TOO, CEPT
	AOS	1(T3)		;ITS GOTTA BE ONE, PLUS.
	HRRZ	T3,TEMP		;DONT NEED HEADER POINTER NO MO.

	SAVE	T3		;SAVE LOC OF FIRST BUFFER.
	MOVE	T1,BUFSIZ
	SUBI	T1,2		;VAL PUT IN LH OF 2ND WORD OF CTL BLOCK

	MOVE	T4,NUMBUF	;SET UP LOOP COUNTER.
	MOVE	T2,T3		;MAKE COPY.

BLP:	HRLM	T1,(T3)		;LH IS LEN OF BUF IN CTL BLK+1
	SOJLE	T4,EBF		;IF LAST BUF, POINT IT TO 1ST BUFFER.
	ADD	T2,BUFSIZ	;MAKE LOCATION OF NEXT BUFFER.
	AOS	T2		;PLUS ONE
	HRRM	T2,(T3)		;SET UP BUFFERS TO POINT TO EACH OTHER,
	MOVE	T3,T2		;SET UP NEXT POINTER.
				;SET 200(8) IN LH OF BUFFER CTL BLOCK.
	GOTO	BLP

EBF:	RESTORE	T2
	HRRM	T2,(T3)		;HAVE LAST BUF POINT TO FIRST ONE.


	RESTORE	T4
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RESTORE	TEMP
	RETURN


DEALBF:
	SAVE	TEMP		;CHAN IS IN TEMP
	SAVE	T1
	SAVE	T2
	SAVE	T3
	MOVE	T2,TEMP
	CALL	HDRLOC		;GET LOCATION OF OHEADER,IHEADER BLOCK.
	SKIPN	TEMP		;IF ZERO, NO HEADERS THERE, BARF!
	GOTO	DRTN
	MOVE	T1,TEMP
	HRRZ	T3,(T1)		;OUTPUT BUFFER LOC
	CALL	DBF		;IF THERE, DUMP THE BUFFER.
	HRRZ	T3,4(T1)
	CALL	DBF		;IF INPUT BUFFER THERE, DEALL IT.
	MOVE	TEMP,T1		;NOW TO GET RID OF HEADER BLOCK.
	CALL	$DEALO##	;DEALLOCATE.
	SETZM	HDRBLK(T2)	;AND ERASE WORD TELLING WHERE.
DRTN:
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RESTORE	TEMP
	RETURN



DBF:	SKIPN	T3		;IF NOTHING THERE.
	RETURN			;THEN RETURN.
	HRRZ	TEMP,(T3)	;GET LINK TO NEXT BUF IN RING.

LOWBUF:	CAML	TEMP,T3		;WANT LOWEST LOC. FIRST BUF IN BLOCK.
	MOVE	TEMP,T3
	HRRZ	T3,(T3)
	CAME	TEMP,T3		;WITH ONE LOOP AROUND, AND TEMP IS
	GOTO	LOWBUF		;STILL LOWEST, THEN WE HAVE LOWEST
				;BUF IN RING

	SOS	TEMP		;GO BACK TO FIRST WORD OF CTL BLOCK OF BUF.
	CALL	$DEALO##	;DEALLOCATE BUFFER RING BLOCK.
	RETURN

IFE %HISEG,	<RELOC>		;LOW
MODE:	0			;MODE FOR OPEN
DEV:	0			;DEVICE
BUFADR:	0			;OUTADR,,INADR

EXTFLG:	0			;EXTENDED IO FUNCTIONS.

FILE:	0			;FILE BLOCK FOR FILE OP'S
EXT:	0
PROT:	0
PATHDR:	0
PATBLK:	BLOCK	2		;PART OF PATH JUNK
PPN:	0
SFD:	BLOCK	6




NUMBUF:	%BFNUM			;DEFAULT NUMBER OF BUFFERS.
BUFSIZ:	%BFSIZ+3			;BUFFER SIZE.
HDRBLK:	BLOCK	%MXCHN		;BLOCK OF OUTHDR,,INHDR POINTERS.

IFE %HISEG,	<RELOC>		;HIGH


;	CALL FILGET( CHAN, VAL, EOF )	GET VAL FROM CHANNEL
;					SETS EOF ON END OF FILE

	ENTRY	FILGET
FILGET:	SETZM	@2(ARG)		;NOT END OF FILE YET
	MOVE	T1,@0(ARG)	;GET CHANNEL
	HRRZ	T1,HDRBLK(T1)	;GET POINTER TO INPUT HEADER.
	SKIPN	T1		;IF WE CAN DO INPUT. SKIP,
	GOTO	INER		;SET ERROR, EOF, AND RETURN.
CONT1:	SOSGE	.BFCTR(T1)	;DECREMENT WORDS LEFT IN BUFFER
	GOTO	GETBUF		;OOPS, ITS EMPTY, DUMP IT
	ILDB	TEMP,.BFPTR(T1)	;WORD WORD FROM BUFFER
	MOVEM	TEMP,@1(ARG)	;AND RETURN IT TO THE USER
	AOS	3(T1)		;INCREMENT WORDS READ
RETRN1:	RETURN

GETBUF:	PUSH	STACK,T3	;SAVE T3
	MOVE	T3,T1		;ALLBUF NEEDS HDR PNTR IN T3
	HRRZ	TEMP,(T3)	;IF BUFFER ALREADY ALLOCATED?
	SKIPN	TEMP		;IF NOT ZERO, ALREADY THERE.
	CALL	ALLBUF		;IF NOT, DO IT.  PTR TO HEADER IS IN T3.
	POP	STACK,T3	;RESTORE T3 CONTENTS.
	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	LSH	TEMP,^D23	;MAKE IT LOOK LIKE AN AC
	TLO	TEMP,(IN)	;MAKE IT AN INSTRUCTION
	XCT	TEMP		;GET THAT BUFFER
	GOTO	CHKIBF		;NO ERROR, GO BACK AND GIVE HIM A WORD
	SETOM	@2(ARG)		;OOPS, END OF FILE
	GOTO	RETRN1		;LEAVE GRACEFULLY

CHKIBF:	SKIPLE	.BFCTR(T1)	;IF STILL -. LEAVE HIM AT EOF, AND ER
	GOTO	CONT1		;ELSE GET CHAR.

INER:	SETOM	@2(ARG)		;SET EOF.
	SETOM	ERRFLG		;SET ERROR ON.
	GOTO	RETRN1


;	CALL FILPUT( CHAN, VAL )	OUTPUT VAL TO CHANNEL

	ENTRY	FILPUT
FILPUT:	SETZM	ERRFLG		;NO ERRORS YET
	MOVE	T1,@0(ARG)	;GET CHANNEL
	HLRZ	T1,HDRBLK(T1)	;GET POINTER TO OUTPUT HEADER.
	SKIPN	T1		;IF NOTHING THERE, WE CANT DO OUTPUT.
	GOTO	OUTER
CONT2:	SOSGE	.BFCTR(T1)	;AND DECREMENT SPACE LEFT IN BUFFER
	GOTO	PUTBUF		;NONE LEFT, GO DUMP THE BUFFER
	MOVE	TEMP,@1(ARG)	;ROOM LEFT, GET WORD TO PUT IN BUFFER
	IDPB	TEMP,.BFPTR(T1)	;PUT IT THERE
	AOS	3(T1)		;INCREMENT OUTPUT POSITION
RETRN2:	RETURN			;AND RETURN TO THE USER

PUTBUF:	PUSH	STACK,T3	;SAVE T3.
	MOVE	T3,T1		;ALLBUF NEEDS HDR PNTR IN T3.
	HRRZ	TEMP,(T3)	;IS BUFFER ALREADY ALLOCATED?
	SKIPN	TEMP		;IF NON-ZERO, BUF IS ALREADY THERE.
	CALL 	ALLBUF		;ELSE ALLOCAT BUF. PTR TO HDR IS IN T3.
	POP	STACK,T3	;RESTORE T3
	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	LSH	TEMP,^D23	;MAKE IT LOOK LIKE AN AC
	TLO	TEMP,(OUT)	;MAKE IT AN INSTRUCTION
	XCT	TEMP		;DUMP THE BUFFER
	GOTO	CONT2		;AND ALLOW HIM TO PUT HIS WORD IN

OUTER:	SETOM	ERRFLG		;GOT HERE, OUTPUT ERROR
	GOTO	RETRN2


;	CALL OUTBUF( CHAN )	OUTPUT CHAN'S BUFFER

	ENTRY	OUTBUF
OUTBUF:	SETZM	ERRFLG		;SET ERROR OFF.
	MOVE	T1,@0(ARG)	;GET CHANNEL.
	HLRZ	T3,HDRBLK(T1)	;IS HEADER ALREADY ALLOCATED?
	SKIPN	T3		;IF NON-ZERO, BUF IS ALREADY THERE.
	GOTO	OUTER		;USE OUTER AS COMMON RETURN POINT.
	HRRZ	TEMP,(T3)	;GET LOC OF BUFFER FROM HEADER TOP.
	SKIPN	TEMP		;IF SOMETHING THERE, ALREADY ALLOCATED.
	CALL 	ALLBUF		;ELSE ALLOCAT BUF. PTR TO HDR IS IN T3.
	MOVE	TEMP,@0(ARG)	;GET CHANNEL
	LSH	TEMP,^D23	;MAKE IT LOOK LIKE AN AC
	TLO	TEMP,(OUT)	;MAKE IT AN INSTRUCTION
	XCT	TEMP		;DUMP THAT BUFFER!
	SKIPA			;NO ERRORS, RETURN GRACEFULLY
	SETOM	ERRFLG		;ELSE SET THE ERROR FLAG
	RETURN


CLCINS:	SETZM	ERRFLG		;ASSUME NO ERROR YET
	SAVE	T3
	MOVE	T2,@0(ARG)	;GET COPY OF CHANNEL
	SAVE	NUMBUF		;SAVE DEFAULT NUM OF BUFS
	MOVEI	TEMP,1
	MOVEM	TEMP,NUMBUF	;SET TO ONE BUFFER.
	HLRZ	T3,HDRBLK(T2)	;LOC OF OUTPUT HEADER.
	SKIPN	T3		;IF CANT DO OUTPUT,
	EXIT	1,		;THEN BARF!
	HRRZ	TEMP,(T3)	;SEE IF BUFFER CREATED
	SKIPN	TEMP		;IF SO, SKIP
	CALL	ALLBUF		;ELSE CREATE BUF FOR HEADER IN T3
	HRRZ	T3,HDRBLK(T2)	;GET LOC OF INPUT HEADER.
	SKIPN	T3
	EXIT	1,		;IF CANT DO INPUT, STILL BARF.
	HRRZ	TEMP,(T3)	;SEE IF BUFFER CREATED YET.
	SKIPN	TEMP		;IF SOMETHING THERE, IT HAS,
	CALL	ALLBUF		;ELSE CREATE ONE.
	RESTORE	NUMBUF		;RESET DEFAULT NUMBER OF BUFFERS.
	MOVE	T3,.BFPTR(T3)	;GET BYTE POINTER                
	MOVEI	T2,^D36		;GET BITS PER WORD
	LSH	T3,^D-24	;GET BITS/BYTE ON RIGHT
	ANDI	T3,77		;DON'T WANT WHERE BYTE STARTS
	IDIV	T2,T3		;GET BYTES/WORD
	MOVE	T3,T2		;KEEP IN REGISTER T3
	IMULI	T3,200		;GET BYTES/BLOCK
	MOVE	T2,@0(ARG)	;GET CHANNEL AGAIN
	LSH	T2,^D23		;MAKE IT LOOK LIKE AC
	MOVE	TEMP,@1(ARG)	;GET POSITION
	IDIV	TEMP,T3		;GET BLOCK POSITION
	ADDI	TEMP,1		;MAKE FIRST BLOCK BLOCK 1
	IOR	TEMP,T2		;BUILD INSTRUCTION
	RESTORE	T3
	RETURN


;	CALL ISEEK(ICHAN,IPOS)	START GETTING INPUT AT RECORD IPOS

	ENTRY	ISEEK
ISEEK:	SAVE	T2
	CALL	CLCINS		;GET PART OF INS IN TEMP, OFFSET IN 1
	TLO	TEMP,(USETI)	;MAKE IT USETI INSTRUCTION
	XCT	TEMP		;EXECUTE IT
	TLO	T2,(IN)		;MAKE IT IN INSTRUCTION
	XCT	T2		;EXECUTE THAT
	SKIPA			;NON-EOF RETURN
	GOTO	EXISEK		;LEAVE ON EOF
	MOVE	T2,@0(ARG)	;GET CHANNEL
	HRRZ	T2,HDRBLK(T2)	;GET POS OF HEADER.
	MOVN	TEMP,T1		;GET NEGATIVE OF SIZE
	ADDM	TEMP,.BFCTR(T2)	;DECREMENT AMOUNT LEFT IN BUFFER
	SKIPE	T1		;SKIP OVER IF ZERO BYTES
IBYTLP:	IBP	.BFPTR(T2)	;INCREMENT POINTER IN BUFFER
	SOJG	T1,IBYTLP	;LOOP IF MORE BYTES TO MOVE ACROSS
	MOVEM	T1,.BFPOS(T2)	;SET POSITION
	SKIPA			;SKIP AROUND ERROR LOGIC

EXISEK:	SETOM	ERRFLG		;EOF OR SOMETHING CAUSED ERROR
	RESTORE	T2
	RETURN


;	I = IINPOS( ICHAN )	GET INPUT RECORD POSITION IN FILE

	ENTRY	IINPOS
IINPOS:	MOVE	T1,@0(ARG)	;GET THE CHANNEL
	HRRZ	T1,HDRBLK(T1)	;GET POINTER TO INPUT BUFFER HEADER.
	MOVE	TEMP,.BFPOS(T1)	;GET THE RECORD POSITION OF FILE
	RETURN			;AND RETURN


;	CALL OSEEK(ICHAN,IPOS)	START PUTTING OUTPUT AT RECORD IPOS

	ENTRY	OSEEK
OSEEK:	SAVE	T2
	CALL	CLCINS		;GET PART OF INS IN TEMP, OFFSET IN 1
	TLO	TEMP,(USETI)	;MAKE A USETI INSTRUCTION
	XCT	TEMP		;EXECUTE IT
	TLO	T2,(IN)		;MAKE AN IN INSTRUCTION
	XCT	T2		;GET THE BUFFER TO MODIFY
	SKIPA			;ALWAYS SKIP IF NO PROBLEM
	CALL	FIXBUF		;IF EOF, CLEAR THE BUFFER AREA
	TLZ	T2,(IN)		;UNMAKE IN INSTRUCTION
	TLO	T2,(OUT)	;MAKE IT AN OUT INSTRUCTION
	XCT	T2		;MAKE SURE BUFFER IS DUMPED
	SKIPA			;NORMAL RETURN
	GOTO	EXOSEK		;RECORD THE ERROR
	TLZ	TEMP,(USETI)	;UNMAKE USETI INSTRUCTION
	TLO	TEMP,(USETO)	;MAKE IT A USETO INSTRUCTION
	XCT	TEMP		;EXECUTE IT
	MOVE	T2,@0(ARG)	;GET CHANNEL
	HLRZ	T3,HDRBLK(T2)	;T3 IS OUTPUT HEADER.
	HRRZ	T2,HDRBLK(T2)	;T2 IS INPUT HEADER.
	MOVN	TEMP,T1		;GET AMOUNT SUBTRACT FROM AMT IN BUFFER
	ADDM	TEMP,.BFCTR(T2)	;UPDATE INPUT COUNT
	ADDM	TEMP,.BFCTR(T3)	;AND OUTPUT COUNT
	SAVE	T1		;SAVE AWAY FOR BYTE LOOP
	HRL	TEMP,.BFADR(T2)	;GET BEGINNING ADDRESS FOR INP BUFFER
	HRR	TEMP,.BFADR(T3)	;AND OUTPUT BUFFER
	ADD	TEMP,[XWD 2,2]	;AND INC TO FIRST WORD OF BUF(NOT CTL BLK)
	HRRZ	T1,TEMP		;START SETTING UP BLT INSTRUCTION
	ADDI	T1,177		;ADD IN BLOCK SIZE
	TLO	T1,(BLT 0,)	;MAKE IT A BLT INSTRUCTION
	XCT	T1		;COPY INPUT BUFFER TO OUTPUT BUFFER
	RESTORE	T1		;BRING BACK OFFSET
	JUMPE	T1,SKPOLP	;IF NOTHING TO ALTER, SKIP
OBYTLP:	IBP	.BFPTR(T2)	;INC POINTER INTO INPUT BUFFER
	IBP	.BFPTR(T3)	;INC POINTER INTO OUTPUT BUFFER
	SOJG	T1,OBYTLP	;LOOP IF MORE BYTES IN OFFSET
SKPOLP:	MOVE	TEMP,@1(ARG)	;GET POSITION
	MOVEM	TEMP,.BFPOS(T2)	;SET INPUT POSITION
	MOVEM	TEMP,.BFPOS(T3)	;AND OUTPUT POSITION

EXOSEK:	RESTORE	T2
	RETURN


FIXBUF:
	MOVE	T4,@(ARG)	;GET CHANNEL NUMBER FOR OUTPUT GARB
	HLRZ	T4,HDRBLK(T4)		;OUTPUT HEADER BLOCK
	MOVE	T3,.BFPTR(T4)	;OUTPUT BYTE POINTER
	HRR	T3,(T4)		;POSITION OF BUFFER
	AOS	T3		;PLUS ONE(SKIP CONTROL BLOCK)
	TLZ	T3,770000	;SET BYTE POSITION TO BIT 35
	MOVEM	T3,.BFPTR(T4)	;AND RESET BYTE POINTER
	MOVEI	T3,1200		;SET CHARACTER COUNT
	MOVEM	T3,.BFCTR(T4)
	MOVE	T4,@(ARG)	;GET CHANNEL NUMBER
	HRRZ	T4,HDRBLK(T4)	;LOC OF INPUT HEADER
	MOVEM	T3,.BFCTR(T4)	;SET CHARACTER COUNT HERE TOO
	MOVE	T3,.BFPTR(T4)	;GET BUFFER POINTER
	HRR	T3,(T4)		;GET LOC OF BUFFER
	AOS	T3		;PLUS ONE..(BUFFER-1)
	TLZ	T3,770000	;ZERO OUT P IN BYTE POINTER
	MOVEM	T3,.BFPTR(T4)	;REPLACE WITH ONE WE'VE MADE
	HRRZ	T4,T3		;USE POINTER TO BUF WE HAVE
	AOS	T4		;BUT MAKE IT THE LOC OF BUF, NOT -1
	SETZM	(T4)		;ZERO FIRST WORD
	MOVE	T3,T4		;FOR LAST LOC OF BLT
	HRLS	T4		;GET READY FOR BLT TO ZERO BUFFER
	AOS	T4
	BLT	T4,177(T3)	;ZAP IT.
	RETURN

;	I = IOTPOS( ICHAN )	GET INPUT RECORD POSITION IN FILE

	ENTRY	IOTPOS
IOTPOS:	MOVE	T1,@0(ARG)	;GET THE CHANNEL
	HLRZ	T1,HDRBLK(T1)	;OUTPUT HEADER POSITION.
	MOVE	TEMP,.BFPOS(T1)	;GET THE RECORD POSITION OF FILE
	RETURN			;AND RETURN


;	CALL SCAN(ISTART,ISTOP,STRING,FILESP)
;				GET FILESPEC FROM STRING
;				STARTING WITH ISTART AND
;				STOPPING WITH ISTOP
;				INDEX	MEANING
;				1	SIZE (NOT USED)
;				2	NODE
;				3	DEVICE
;				4	FILE
;				5	EXT
;				6	PROT
;				7	P
;				8	PN
;				9	SFD1
;				10	SFD2
;				11	SFD3
;				12	SFD4
;				13	SFD5

	ENTRY	SCAN
SCAN:	SETZM	ERRFLG		;NO ERRORS YET
	MOVEI	T6,@3(ARG)	;GET ADDRESS OF FILSPC ARRAY
	HRLZI	TEMP,'CTY'	;DEFAULT NODE IS CTY'S NODE
	IONDX.	TEMP,		;GET CTY'S UDX
	HALT			;NO CTY?  EEK!
	GTNTN.	TEMP,		;GET NODE AND LINE FROM UDX
	HALT			;CTY ISN'T ON SYSTEM?  HORRORS!
	HLRZM	TEMP,CTYADR+1	;PUT NODE NUMBER IN NODE BLOCK
	MOVE	TEMP,[.NDRNN,,CTYADR]
	NODE.	TEMP,		;GET NODE NAME
	;HALT			;CTY IS AT NODE WITHOUT NAME.  RIGHT.
	MOVE	TEMP,[SIXBIT/CENTRA/]
	MOVEM	TEMP,1(T6)	;STORE DEFAULT NODE
	HRLZI	TEMP,'DSK'	;GET DEFAULT DEVICE
	MOVEM	TEMP,2(T6)	;STORE DEFAULT DEVICE
	SETZM	3(T6)		;DEFAULT FILE IS NULL
	SETZM	4(T6)		;DEFAULT EXTENSION IS NULL
	MOVEI	T1,5(6)		;PREPARE TO READ PATH
	SETOM	(T1)		;DIRECTLY INTO HIS ARRAY!
	SETZM	1(T1)		;(-1 MEANS THIS JOB)
	HRLI	T1,^D8		;ARG BLOCK IS 8 LONG
	PATH.	T1,		;GET THAT PATH
	HALT			;EVERYBODY HAS A PATH!
	MOVE	TEMP,[XWD -1,.GTDFL]	;GET USER'S DEFAULT PROTECTION
	GETTAB	TEMP,		;ASK MONITOR
	HRLI	TEMP,077000	;GETTAB FAILED.  USEFUL DEFAULT
	LSH	TEMP,^D-27	;MAKE IT RIGHT JUSTIFIED
	MOVEM	TEMP,5(T6)	;AND STUFF IT IN FILSPC
	MOVE	TEMP,7(T6)	;GET PPN OUT IN 2 WORD FORMAT
	HLRZM	TEMP,6(T6)	;PUT IN P IN 1 WORD FORMAT
	HRRZM	TEMP,7(T6)	;AND PN IN 1 WORD FORMAT
	MOVEI	T2,@2(ARG)	;GET ADDRESS OF STRING
	ADD	T2,@1(ARG)	;ADD IN NUMBER OF CHAR TO FIND END
	SOS	T2		;STARTS AT ZERO, NOT AT 1.
	MOVE	T1,(T2)		;GET FIRST CHARACTER
	MOVEI	T3," "		;TO REPLACE TOKENS FOUND
	TLNN	T1,-1		;UNLESS ITS A1 FORMAT
	MOVE	T3,[ASCIZ/     /]	;TO REPLACE TOKENS FOUND
	MOVEM	T2,MAXVAL	;REMEMBER IT SO WE KNOW WHEN TO STOP
	MOVEI	T2,@2(ARG)	;GET ADDRESS TO FIND STARTING ADDRESS
	ADD	T2,@0(ARG)	;ADD IN PLACE TO START
	SKIPE	@0(ARG)		;IF IT ISN'T ZERO ALREADY, DECREMENT IT
	SOS	T2		;BECAUSE ARRAY STARTS AT 0, NOT 1
	MOVEM	T2,MINVAL	;AND REMEMBER WHERE TO START

NODLOP:	MOVE	T1,(T2)		;GET A CHARACTER
	TLNE	T1,-1		;IF A1 FORMAT
	LSH	T1,^D-29	;MAKE IT R1 FORMAT
	CAIN	T1,"_"		;IS IT A NODE DELIMITER
	GOTO	FNOD		;YES, GO GET NODE TOKEN
	AOS	T2		;NO, NEXT CHARACTER
	CAMG	T2,MAXVAL	;HAVE WE GONE PAST END OF ARRAY
	GOTO	NODLOP		;NOPE, BACK FOR ANOTHER
				;YUP, OH WELL, LOOK FOR DEVICE

CDEV:	MOVE	T2,MINVAL	;RESET ARRAY POINTER

DEVLOP:	MOVE	T1,(T2)		;DO THE SAME SORT OF THING FOR DEVICE
	TLNE	T1,-1
	LSH	T1,^D-29
	CAIN	T1,":"
	GOTO	FDEV
	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	DEVLOP

CEXT:	MOVE	T2,MINVAL	;AND EXTENSION

EXTLOP:	MOVE	T1,(T2)
	TLNE	T1,-1
	LSH	T1,^D-29
	CAIN	T1,"."
	GOTO	FEXT
	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	EXTLOP

CPROT:	MOVE	T2,MINVAL	;AND PROTECTION

PRTLOP:	MOVE	T1,(T2)
	TLNE	T1,-1
	LSH	T1,^D-29
	CAIN	T1,"<"
	GOTO	FPROT
	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	PRTLOP

CPPN:	MOVE	2,MINVAL	;AND PATH

PATLOP:	MOVE	T1,(T2)
	TLNE	T1,-1
	LSH	T1,^D-29
	CAIN	T1,"["
	GOTO	FPPN
	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	PATLOP


CFILE:	MOVE	T2,MINVAL	;NOW LOOKING FOR FILE, RESET PTR

FILOOP:	MOVE	T1,(T2)		;ANYTHING NOT A BLANK NOW
	TLNE	T1,-1
	LSH	T1,^D-29	;SHOULD BE START OF FILE
	CAILE	T1," "
	GOTO	FFILE		;FOUND ONE, GO GET IT
	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	FILOOP

CLEAR:	MOVE	T2,MINVAL

CLRLOP:	MOVE	T1,(T2)		;NOW THAT WE HAVE EXTRACTED THE FILE
	TLNE	T1,-1
	LSH	T1,^D-29	;ANYTHING OTHER THAN A SPACE SHOULDN'T
	CAIN	T1," "		;BE HERE - ERROR IF IT IS!
	GOTO	ENLOOP
	SETOM	ERRFLG		;SET ERROR AND LEAVE
	RETURN

ENLOOP:	AOS	T2
	CAMG	T2,MAXVAL
	GOTO	CLRLOP
	RETURN

FNOD:	SOS	T2		;HERE TO GET NODE, DON'T WANT TO LOOK
	CAMGE	T2,MINVAL	;AT DELIMITER, JUST TOKEN
	GOTO	ONOD		;JUST FOUND BEGINNING
	MOVE	T1,(T2)		;ELSE GET CHARACTER
	TLNE	T1,-1
	LSH	T1,^D-29
	CAILE	T1," "		;IF ITS A SPACE, BEGINNING
	CAIN	T1,":"		;OR ONE OF THE OTHER DELIMITERS
	GOTO	ONOD
	CAIN	T1,">"
	CAIE	T1,"]"
	GOTO	FNOD

ONOD:	AOS	T2		;POINT TO THE BEGINNING OF TOKEN
	CALL	GETSIX		;GET THE SIXBIT FORM
	MOVEM	TEMP,1(T6)	;AND STUFF IT INTO ARRAY
	MOVEM	T3,(T2)		;AND BLANK OUT DELIMITER
	GOTO	CDEV		;GO GET THE DEVICE

FDEV:	SOS	T2		;SAME IDEA FOR DEVICE
	CAMGE	T2,MINVAL
	GOTO	ODEV
	MOVE	T1,(T2)
	TLNE	T1,-1
	LSH	T1,^D-29
	CAILE	T1," "
	CAIN	T1,">"
	GOTO	ODEV
	CAIE	T1,"]"
	GOTO	FDEV

ODEV:	AOS	T2
	CALL	GETSIX
	MOVEM	TEMP,2(T6)
	MOVEM	T3,(T2)
	HLRZ	TEMP,TEMP	;CHECK IF DEVICE IS ERSATZ
	CAIN	TEMP,'DSK'	;IF IT BEGINS WITH DSK, NO.
	GOTO	CEXT
	MOVE	TEMP,2(T6)	;LOOKS LIKE DEVICE IS ERSATZ
	MOVEM	TEMP,5(T6)	;SET FOR PATH MONITOR CALL
	HRLI	TEMP,^D8	;ARG BLOCK IS 8 LONG
	HRRI	TEMP,5(T6)	;PLACE DIRECTLY IN HIS ARRAY
	PATH.	TEMP,		;GET THE PATH
	JFCL
	SETZM	5(T6)
	MOVE	TEMP,7(T6)	;MAKE PPN 2 WORD FORMAT
	HLRZM	TEMP,6(T6)
	HRRZM	TEMP,7(T6)
	GOTO	CEXT

FFILE:	CALL	GETSIX		;THE FILE IS MERELY THE REMAINING
	MOVEM	TEMP,3(T6)	;SIX LETTERS
	GOTO	CLEAR

FEXT:	MOVEM	T3,(T2)		;BLANK OUT PERIOD
	AOS	T2		;POINT TO NEXT CHAR
	CALL	GETSIX		;GET NEXT TOKEN
	HRRI	TEMP,777777	;AND DELIMIT THAT WE FOUND ONE
				;(SO EVEN A NULL WITH NOT EQUAL 0)
	MOVEM	TEMP,4(T6)	;AND STUFF IT IN FILSPC
	GOTO	CPROT


FPROT:	CALL	GETOCT		;GO GET AN OCTAL NUMBER
	MOVEM	T3,(T2)		;BLANK DELIMITER
	CAILE	TEMP,777	;CHECK LEGAL RANGE
	GOTO	PERROR
	MOVEM	TEMP,5(T6)	;PUT IT IN FILSPC
	GOTO	CPPN

FPPN:	GETPPN	T4,		;GET OUT CURRENT PPN
	JFCL			;ON THE *OFF* CHANCE WE'RE PRIVD
	CALL	GETOCT		;GET THE OCTAL NUMBER
	MOVEM	T3,(T2)		;REPLACE DELIMITER WITH SPACE
	CAILE	TEMP,377777	;CHECK ITS LEGALITY
	GOTO	PERROR
	SKIPN	TEMP		;WAS IT ZERO
	HLRZ	TEMP,T4		;YES, REPLACE IT WITH OUT P
	MOVEM	TEMP,6(T6)	;AND PUT IT IN FILSPC
	CALL	GETOCT		;NOW GET THE PN
	CAILE	TEMP,777777
	GOTO	PERROR
	SKIPN	TEMP
	HRRZ	TEMP,T4
	MOVEM	TEMP,7(T6)	;AND PUT IT IN FILSPC
	MOVEI	T7,5		;MAX OF 5 PATHS
	MOVEI	T10,10(T6)	;GET ADDRESS OF WHERE TO PUT THEM
SFDLOP:	MOVE	TEMP,(T2)	;GET THE DELIMITER
	MOVEM	T3,(T2)		;REPLACE IT WITH A BLANK
	TLNE	TEMP,-1
	LSH	TEMP,^D-29
	CAIN	TEMP,"]"	;WAS IT END OF PATH
	GOTO	CLRBLK		;YES, ZERO THE REST OF IT
	CAIN	TEMP,","	;NOPE, HOPE IT WAS A COMMA
	SOSGE	T7		;AND THAT THERE IS ROOM FOR ANOTHER SFD
	GOTO	PERROR		;NOPE
	AOS	T2		;YUP, GET TO NEXT CHAR
	CALL	GETSIX		;GET THE SFD
	MOVEM	TEMP,(T10)	;AND PUT IT IN GETSPC
	AOJA	T10,SFDLOP	;AND GO BACK FOR ANOTHER

CLRBLK:	CAILE	T10,14(T6)	;IF AT MAX SFD
	GOTO	CFILE		;CAN GO GET FILE
	SETZM	(T10)		;ELSE, ZERO OUT SFD
	AOJA	T10,CLRBLK	;AND GO BACK FOR THE REST

GETSIX:	SETZ	TEMP,		;INITIAL WORD CONTAINS NOTHING
	MOVEI	T5,6		;MAX OF 6 CHAR'S PER SIXBIT WORD
	MOVE	T1,(T2)		;GET NEXT CHAR
	TLNE	T1,-1
	LSH	T1,^D-29	;MAKE IT RIGHT JUSTIFIED
	CAIE	T1,"#"		;IT MIGHT BE OCTAL FORM
	GOTO	GTXLOP		;IF NOT, GO READ IT AS SIXBIT
	MOVEM	T3,(T2)		;ELSE, BLANK THE #
	AOS	T2		;INCREMENT THE CHAR POSITION
	GOTO	GETOCT		;AND TREAT IT AS AN OCTAL NUMBER

GTXLOP:	MOVE	T1,(T2)		;IT IS SIXBIT, GET THE CHAR (AGAIN?)
	TLNE	T1,-1
	LSH	T1,^D-29	;CONVERT IT
	CAILE	T1," "		;<= SPACE, IT ENDS THE TOKEN
	CAIN	T1,"_"		;OR ONE OF THE DELIMITERS
	GOTO	ESUB
	CAIE	T1,":"
	CAIN	T1,"<"
	GOTO	ESUB
	CAIE	T1,"["
	CAIN	T1,","
	GOTO	ESUB
	CAIN	T1,"]"
	GOTO	ESUB
	SUBI	T1," "		;NOT END OF TOKEN, CONVERT IT
	CAILE	T1,77		;STILL NOT IN RANGE, THEN ITS AN ERROR
	GOTO	SERROR
	LSH	T1,^D30		;SHIFT IT OVER TO LEFT SO WE CAN
	LSHC	TEMP,6		;SHIFT ONE CHAR INTO TEMP
	MOVEM	T3,(T2)		;BLANK IT OUT
	SOJL	T5,SERROR	;IF TOO MANY CHAR'S ERROR
	AOS	T2		;ELSE INCREMENT CHAR POINTER
	CAMG	T2,MAXVAL	;MAKE SURE WE HAVEN'T WANDERED
	GOTO	GTXLOP		;OFF ARRAY, ELSE GO BACK FOR MORE

ESUB:	IMULI	T5,6		;IF LESS THAN 6 CHAR'S GOTTEN
	HRLI	T5,(LSH)	;PREPARE TO SHIFT OVER TO MAKE
	XCT	T5		;LEFT JUSTIFIED
	RETURN

GETOCT:	SETZ	TEMP,		;WORD STARTS AT ZERO
	MOVEM	T3,(T2)		;BLANK OUT WHAT EVER DELIMITED US
	AOS	T2		;AND INCREMENT CHAR POINTER

OCTLOP:	CAMLE	T2,MAXVAL	;HAVE WE GONE OFF END OF ARRAY
	GOTO	EXOCT		;YES, NO POINT IN CONTINUING
	MOVE	T1,(T2)		;GET THE CHARACTER
	TLNE	T1,-1
	LSH	T1,^D-29	;CONVERT IT
	SUBI	T1,"0"		;MAKE IT A DIGIT
	JUMPL	T1,EXOCT	;CAN'T - ITS NOT IN RANGE
	CAILE	T1,7		;CHECK IF ITS LEGAL OCTAL
	GOTO	EXOCT		;NOPE
	MOVEM	T3,(T2)		;ELSE BLANK IT
	IMULI	TEMP,10		;SHIFT OVER BY A POWER OF 8
	ADD	TEMP,T1		;ADD IN THE DIGIT
	AOS	T2		;INCREMENT THE CHARACTER POINTER
	GOTO	OCTLOP		;AND GO BACK FOR ANOTHER

EXOCT:	RETURN

SERROR:	RESTORE	TEMP

PERROR:	SETOM	ERRFLG
	RETURN

IFE %HISEG,	<RELOC>		;LOW
CTYADR:	2			;BLOCK FOR NODE MONITOR CALL IN SCAN
	0
MINVAL:	0			;GETS STARTING INDEX
MAXVAL:	0			;GETS STOPPING INDEX
IFE %HISEG,	<RELOC>		;HIGH

;	CALL XFER( INCHAN, IOCHAN )	TRANSFER DATA FROM
;					1 CHANNEL TO ANOTHER

	ENTRY	XFER
XFER:	MOVE	TEMP,@0(ARG)	;GET INPUT CHANNEL
	MOVEM	TEMP,ICHAN	;AND PUT IN ARG BLOCK
	MOVE	TEMP,@1(ARG)	;GET OUTPUT CHANNEL
	MOVEM	TEMP,OCHAN	;PUT IN ARG BLOCK
	SAVE	ARG		;CHANGED DURING CALL TO FILGET & FILPUT
XLOOP:	MOVEI	ARG,ARG1	;SET UP FOR CALL TO FILGET
	CALL	FILGET		;GET THE WORD
	SKIPE	LEOF		;IF END OF FILE
	GOTO	ENDX		;EXIT THIS LOOP
	MOVEI	ARG,ARG2	;ELSE PREPARE TO WRITE IT OUT
	CALL	FILPUT		;WRITE IT OUT
	GOTO	XLOOP		;AND GO BACK FOR ANOTHER WORD
ENDX:	RESTORE	ARG
	RETURN

IFE %HISEG,	<RELOC>		;LOW
ARG1:	ICHAN
	VAL
	LEOF

ARG2:	OCHAN
	VAL

ICHAN:	0			;INPUT CHANNEL FOR XFER
OCHAN:	0			;OUTPUT CHANNEL FOR XFER
VAL:	0			;VALUE READ TO WRITE
LEOF:	0			;TRUE WE IT HITS END OF FILE
IFE %HISEG,	<RELOC>		;HIGH
	PRGEND
	TITLE	ALLOC				;PAGE 23
	SEARCH	PACK, UUOSYM

IFE %HISEG,	<TWOSEG 400000>


;	IPTR = ALLOC( ISIZE )

	ENTRY	ALLOC,$ALLOC
ALLOC:	MOVE	TEMP,@0(ARG)	;GET FORTRAN ARGUMENT
$ALLOC:	SAVE	TEMP		;SAVE AWAY THE ARGUMENT
	SAVE	T1		;SAVE THE ACCUMULATORS
	SAVE	T2
	SAVE	T3
	SAVE	T4
	SKIPE	TOPMEM		;IS TOPMEM INITTED?
	GOTO	INITED		;YES, SKIP THIS LOGIC
	MOVE	T1,.JBREL	;GET TOP OF MEMORY
	MOVEM	T1,TOPMEM	;AND KEEP INFO FOR LESS THAN PAGE
	MOVEM	T1,ORGTOP	;AND KEEP ORIGINAL TOP
INITED:	MOVE	TEMP,-4(STACK)	;GET WORDS TO ALLOCATE
	ADDI	TEMP,1		;PLUS ONE WORD FOR BOOKEEPING
	MOVE	T1,FRELST	;AND POINTER TO FIRST FREE
	MOVEI	T2,FRELST	;POINT LAST TO FIRST FREE
ALCLOP:	JUMPE	T1,NONFND	;IF LIST IS NIL, GET SOME CORE
	HLRZ	T3,0(T1)	;ELSE GET THE SIZE
	CAMN	TEMP,T3		;IS IT AN EXACT MATCH?
	GOTO	EXTMAT		;YES, GO GET IT
	CAMG	TEMP,T3		;IS IT BIGGER?
	GOTO	ONEFND		;YES, IT WILL FIT
	MOVE	T2,T1		;ELSE LAST = THIS
	HRRZ	T1,0(T1)	;THIS = THIS^.NEXT
	GOTO	ALCLOP		;LOOP TO FIND NEXT ONE

NONFND:	MOVE	T1,TOPMEM	;NONE FOUND IN LIST, REQUEST
	ADDI	T1,1		;IT FROM MEMORY
	ADDM	TEMP,TOPMEM	;ADJUST TOP OF MEMORY
	HRRZ	TEMP,TOPMEM	;GET NEW VALUE
	CAMG	TEMP,.JBREL	;COMPARE IT WITH ACTUAL CORE SIZE
	GOTO	ENDALL		;IF <=, DON'T BOTHER TO EXPAND
	CORE	TEMP,		;EXPAND CORE
	HALT			;DIE ON ERROR
	HRRZ	TEMP,.JBREL	;GET NEW LOW CORE LIMIT
	HRLM	TEMP,.JBSA	;SET FOR
	HRRM	TEMP,.JBFF
	HRLM	TEMP,.JBCOR	;AND INFORM ".SAV" OF IT.
	GOTO	ENDALL		;AND PREPARE TO EXIT

EXTMAT:	HRRZ	T3,0(T1)	;GET NEXT POINTER
	HRRM	T3,0(T2)	;PUT IT IN LAST POINTER
	GOTO	ENDALL		;AND PREPARE TO EXIT

ONEFND:	HRRZ	T3,T1		;GET CURRENT POINTER
	ADD	T3,TEMP		;ADJUST IT BY SIZE
	HLRZ	T4,0(T1)	;GET ORIGINAL SIZE
	SUB	T4,TEMP		;ADJUST IT BY SIZE
	HRL	T4,0(T1)	;ADD IN LAST POINTER
	HRRM	T3,0(T2)	;AND PLACE IN NEW POSITION
	MOVSM	T4,0(T3)	;PLACE IN CORRECT ORDER

ENDALL:	MOVE	TEMP,-4(STACK)	;GET LENGTH
	ADDI	TEMP,1		;INCREMENT IT FOR BOOK KEEPING
	HRLI	TEMP,'PTR'	;FLAG IT AS A POINTER
	MOVEM	TEMP,0(T1)	;AND SAVE IT IN TOP OF CHUNK
	ADDI	T1,1		;INCREMENT TO POINT TO FIRST FREE
	HRRZM	T1,-4(STACK)	;RETURN POINTER TO USER
	RESTORE	T4		;RESTORE THE ACCUMULATORS
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RESTORE	TEMP		;RETURN POINTER IN AC 0
	RETURN			;AND RETURN


;	CALL DEALOC( IPTR )

	ENTRY	DEALOC,$DEALO
DEALOC:	MOVE	TEMP,@0(ARG)	;GET POINTER TO CHUNK TO DISPOSE
$DEALO:	SAVE	T1		;SAVE AWAY ACCUMULATORS
	SAVE	T2
	SAVE	T3
	SAVE	T4
	SAVE	T5
	SAVE	T6
	SAVE	T7
	SKIPN	T2,TEMP		;IS IT A POINTER TO NOTHING?
	GOTO	ENDDEA		;IF SO, JUST RETURN
	CAMG	T2,TOPMEM	;IS IT OVER TOP OF INITTED MEMORY?
	CAMGE	T2,ORGTOP	;OR UNDER THE ORIGINAL TOP?
	HALT			;IF SO, DIE.
	SUBI	T2,1		;MAKE IT POINT IN FRONT OF LENGTH
	HLRZ	T3,0(T2)	;GET POINTER FLAG
	CAIE	T3,'PTR'	;IS IT ONE OF OUR FLAGS?
	HALT			;NO, DIE
	HRRZ	T3,0(T2)	;GET LENGTH OF CHUNK
	MOVEI	T4,FRELST	;GET THE FIRST HEADER (GUARDIAN)
	MOVE	T1,FRELST	;GET THE ADDRESS OF NEXT HEADER

DELOOP:	SKIPN	T1		;DOES THE NEXT HEADER EXIST?
	GOTO	DEDONE		;NO, JUST ADD TO END OF FREE LIST
	HLRZ	T6,0(T1)	;GET SIZE OF CHUNK IN LIST
	HRRZ	T7,T1		;AND ITS ADDRESS
	ADD	T7,T6		;SUM THEM
	CAMN	T7,T2		;CHECK TO SEE IF SUM POINTS TO DISPOSEE
	GOTO	WASPRV		;YES, GO ADD THE CHUNKS TOGETHER
	HRRZ	T7,T1		;NO, GET ADDRESS OF FRELST CHUNK
	SUB	T7,T3		;SUBTRACT AWAY DISPOSEE
	CAMN	T7,T2		;CHECK TO SEE IF DIF POINTS TO DISPOSEE
	GOTO	WASPST		;YES, GO ADD THE CHUNKS TOGETHER
	MOVE	T4,T1		;REMEMBER THIS CHUNK AS LAST CHUNK
	HRRZ	T1,0(T1)	;GO ONTO NEXT CHUNK
	GOTO	DELOOP		;AND LOOP

DEDONE:	HRL	T6,T3		;GET SIZE OF DISPOSEE
	HRR	T6,FRELST	;AND POINTER TO NEXT CHUNK
	MOVEM	T6,0(T2)	;PUT INFO IN CHUNK HEADER
	MOVEM	T2,FRELST	;MAKE THIS THE FIRST CHUNK IN FRELST
	GOTO	ENDDEA		;RETURN TO CALLER

WASPRV:	MOVS	T6,0(T1)	;GET HEADER WITH SIZE ON RIGHT
	ADD	T6,T3		;ADD IN DISPOSEE SIZE
	MOVSM	T6,0(T1)	;AND PUT IT BACK
	MOVE	T2,T1		;COPY ADDRESS
	MOVE	T5,T1		;GET PTR TO THIS CHUNK FOR FUTURE REF
	HRRZ	T6,T6		;GET THE SIZE OF BIGGER CHUNK
	ADD	T2,T6		;GET POINTER TO WOULD BE NEXT CHUNK

WASPVL:	MOVE	T4,T1		;COPY LAST CHUNK POINTER
	HRRZ	T1,0(T1)	;GET NEXT CHUNK
	SKIPN	T1		;IF IT IS A NIL POINTER
	GOTO	ENDDEA		;THEN DONE
	CAME	T1,T2		;IS CHUNK AT END OF FOUND CHUNK?
	GOTO	WASPVL		;NOPE, LOOP

	HLLZ	T6,0(T1)	;GET SIZE ON RIGHT SIDE
	ADDM	T6,0(T5)	;ADD IT TO THE GROWING CHUNK
	HRRZ	T6,0(T1)	;GET WHO ITS POINTING TO
	HRRM	T6,0(T4)	;UPDATE LAST CHUNK POINTING TO IT
	GOTO	ENDDEA		;AND RETURN

WASPST:	HLRZ	T6,0(T1)	;GET SIZE
	ADD	T6,T3		;ADD IN CHUNK SIZE
	HRL	T6,0(T1)	;GET WHAT IT WAS POINTING TO
	MOVSM	T6,0(T2)	;PUT IT BACK
	HRRM	T2,0(T4)	;MAKE LAST POINTER POINT HERE
	MOVE	T5,T2		;GET COPY OF CHUNK POINTER
	MOVE	T7,T4		;KEEP COPY OF WHO IS POINTING TO ME

WASPSL:	MOVE	T4,T1		;COPY LAST CHUNK POINTER
	HRRZ	T1,0(T1)	;GET NEXT CHUNK
	SKIPN	T1		;WAS POINTER NIL?
	GOTO	ENDDEA		;YES, EXIT
	HLRZ	T6,0(T1)	;GET CHUNK SIZE
	ADD	T6,T1		;ADD IN ITS ADDRESS
	CAME	T6,T5		;WAS IT THE GROWING CHUNK
	GOTO	WASPSL		;NO, LOOP

	HRRZ	T6,0(T5)	;GET ADDRESS THAT OLD CHUNK PNTS TO
	HRRM	T6,0(T7)	;AND PUT IT IN THING POINTING TO IT
	HLLZ	T6,0(T5)	;GET SIZE OF OLD CHUNK
	ADDM	T6,0(T1)	;AND ADD IT INTO NEW CHUNK

ENDDEA:	RESTORE	T7		;RESTORE THE ACCUMULATORS
	RESTORE	T6
	RESTORE	T5
	RESTORE	T4
	RESTORE	T3
	RESTORE	T2
	RESTORE	T1
	RETURN

IFE %HISEG,	<RELOC>		;LOW
FRELST:	Z			;POINTER TO FIRST FREE
TOPMEM:	Z			;LAST LOCATION IN MEMORY
ORGTOP:	Z			;ORIGINAL TOP OF MEMORY
IFE %HISEG,	<RELOC>		;HIGH

	PRGEND
	SEARCH	PACK, UUOSYM
IFN %HISEG,<

	TITLE	ERROR				;PAGE 24

	ENTRY	ERROR
ERROR:	MOVE	TEMP,ERRFLG
	RETURN

	ENTRY	ERRFLG
ERRFLG:	0

	END			>	;END IFN %HISEG
	TITLE	HISEG				;PAGE 25
	SEARCH	PACK, UUOSYM


	TWOSEG	400000

LOKFLG:	0			;LOCK FLAG (MUST BE FIRST IN BLOCK)
NUMJOB:	0			;NUMBER OF JOBS IN HISEG
STFLAG:	0			;INITIALIZATION FLAG
TOPLOC:	0			;LAST LOCATION IN SEGMENT
ADRTBL:	BLOCK	100		;TABLE FOR ARRAY
DIMADR:	0			;LAST ADDRESS FOR DIMENSIONS
DIMTBL:	BLOCK	650		;TABLE FOR DIMENSIONS
BEGADR:	0			;BEGINNING OF SHARED DATA

;	CALL CHECK( INIFLG )	CHECK TO SEE IF HISEGMENT
;				IS BEING INITTED.  IF SO, WAIT
;				UNTIL DONE TO EXIT.  ELSE, SET
;				INIFLG AND EXIT

	EXTERN	EXIT.
	ENTRY	CHECK
CHECK:	SETZM	.JBSA		;MULTI-USER PROGRAMS NOT REENTRANT
	SETZB	TEMP,@0(ARG)	;BY DEFAULT, SOMEBODY IS ALREADY IN
	SETUWP	TEMP,		;TURN OFF WRITE PROTECT BIT
	OUTSTR	[ASCIZ/?USPHSG Cannot turn off write protect bit
/]
	AOS	NUMJOB		;INCREMENT NUMBER OF JOBS IN SEG
	SKIPN	STFLAG		;NEED TO MAKE DATA?
	GOTO	MAKDAT		;YUP
	SKIPLE	STFLAG		;SOMEBODY MAKING IT ALREADY?
	GOTO	RCHECK		;YUP
	GOTO	EXINIT		;ELSE EXIT

MAKDAT:	AOS	STFLAG		;SET FLAG SO NOBODY CONFLICTS
	OUTSTR	[ASCIZ/[Initializing data base]
/]
	HLRZ	TEMP,.JBHRN+.JBHGH	;GET SIZE OF CORE
	TRO	TEMP,400777	;MAKE IT NUMBER OF PAGES
	MOVEM	TEMP,BEGADR	;IT WILL BE COME START OF DATA BASE
	AOS	TEMP		;FIRST LOCATION TO USE WILL BE
	MOVEM	TEMP,TOPLOC	;IN TOPLOC
	SETZM	DIMADR		;NO DIMENSIONS YET
	SETOM	USRPRV		;NOBODY CAN GET IN TILL I'M DONE
	MOVEI	T1,100		;GET NUMBER OF ARRAYS TO CLEAR
CLRLOP:	SETZM	ADRTBL(T1)	;ZERO TABLE OUT
	SOJG	T1,CLRLOP	;AND GO GET ANOTHER
	SETOM	@0(ARG)		;SET FLAG TO INDICATE IN DB ROUTINE
	GOTO	EXINIT

RCHECK:	OUTSTR	[ASCIZ/[Waiting for initialization]
/]
	HRRZI	TEMP,^D5000	;SET TIME TO SLEEP
	HIBER	TEMP,		;SLEEP FOR A WHILE
	OUTSTR	[ASCIZ/?USPHSG Error in hibernating routine
/]
	SKIPLE	STFLAG		;DB INITTED?
	GOTO	RCHECK		;NOPE, GO SLEEP AGAIN
EXINIT:
IFN %HIDBG,<
	MOVEI	TEMP,1		;WRITE PROTECT WHEN DONE
	SETUWP	TEMP,		;(SLOW, BUT FOR DEBUGGING)
	HALT		>	;IFN %HIDBG
	RETURN


;	CALL ADDUSR( INC )	MANUALLY INCREMENT NUMBER OF USERS
;				(VS CHECK DOING IT AUTOMATICALLY)

	ENTRY	ADDUSR
ADDUSR:
IFN %HIDBG,<
	SETZ	T1,
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	MOVE	TEMP,@0(ARG)
	ADDM	TEMP,NUMJOB
IFN %HIDBG,<
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	RETURN


;	I = NUSER(0)		RETURN NUMBER OF USERS IN DATA BASE

	ENTRY	NUSER
NUSER:	MOVE	TEMP,NUMJOB	;GET NUMBER OF USERS
	RETURN


;	I = NHIBLK(0)		;RETURN POINTER TO TABLES

	ENTRY NHIBLK
NHIBLK:	MOVEI	TEMP,LOKFLG	;ALLOWS KLUDGEY WAY TO SAVE HISEG
	RETURN


;	I = ITBADR( ITABL )

	ENTRY	ITBADR
ITBADR:	HRRZ	T1,@0(ARG)	;GET TABLE NUMBER
	MOVE	TEMP,ADRTBL(T1)	;GET ADDRESS
	RETURN			;AND RETURN


;	CALL INIT( ITABL, NBIT, IDIMI, IDIM2, IDIM3, . . . )
;				SET UP ARRAY ITABL

	ENTRY	INIT
INIT:
IFN %HIDBG,<
	SETZ	TEMP,
	SETUWP	TEMP,
	HALT		>	;IFN %HIDBG
	MOVN	TEMP,-1(ARG)	;GET NUMBER OF ARGUMENTS
	HLRZ	TEMP,TEMP	;ON RIGHT HALF
	SUBI	TEMP,2		;ARRAY # AND NUMBER OF BITS DON'T COUNT
	AOS	TOPLOC		;ADDING AT LEAST ONE LOCATION
	MOVE	T1,TOPLOC	;GET TOP ADDRESS
	SKIPLE	T2,@0(ARG)	;GET ARRAY NUMBER
	CAILE	T2,100		;CHECK ITS LEGALLITY
	CALL	BADINI		;ITS BAD
	SKIPE	ADRTBL(T2)	;CHECK IF ITS ALREADY BEEN INITTED
	CALL	BADINI		;YUP, DIE
	MOVEM	T1,ADRTBL(T2)	;PLACE STARTING LOC IN ADDRESS
	MOVE	T3,DIMADR	;GET VALUE THERE
	HRLM	T3,ADRTBL(T2)	;PUT IT IN OTHER SIDE
	MOVE	T2,ARG		;GET POOINTER INTO ARGUMENT BLOCK
	MOVE	T6,@1(ARG)	;GET NUMBER OF BITS PER WORD
	MOVEM	T6,DIMTBL(T3)	;REMEMBER IT AS WELL
	MOVEI	T5,^D36		;PREPARE TO FIND BIT POSITION
	IDIV	T5,T6		;GET NUMBER OF BYTES PER WORD
	HRLM	T5,DIMTBL(T3)	;STORE THAT
	MOVEI	T1,1		;AT LEAST 1 MEMORY LOCATION NEEDED

LOOP:	MOVE	T4,@2(T2)	;GET DIMENSION
	AOS	T2		;INCREMENT ARGUMENT POINTER
	IMUL	T1,T4		;MULTIPLY MEMORY REQUIRED BY DIMENSION
	MOVEM	T4,DIMTBL+1(T3)	;AND STORE DIMENSION IN TABLE
	AOS	T3		;INCREMENT THAT POINTER
	SOJG	TEMP,LOOP	;AND GO BACK FOR ANOTHER DIMENSION

	SETZM	DIMTBL+1(T3)	;FLAG END OF DIMENSIONS
	ADDI	T3,2		;INCREMENT POINTER
	MOVEM	T3,DIMADR	;STUFF AWAY THE POINTER
	IDIV	T1,T5		;FIND OUT HOW MANY WORDS REQUIRED
	AOS	T1		;INCREMENT MEMORY REQUIRED
	ADDM	T1,TOPLOC	;AND TELL THE DATABASE
	MOVE	T1,TOPLOC	;GET TOP OF HISEG
	HRRZ	TEMP,.JBHRL	;GET TOP OF HISEG
	CAML	TEMP,T1		;IS IT HIGHER
	GOTO	STOP1		;NOPE, NO POINT IN EXPANDING CORE
	HRLZ	T1,T1		;SET UP FOR CORE UUO
	CORE	T1,		;EXPAND THE HISEG
	OUTSTR	[ASCIZ/?USPHSG Cannot allocate core
/]

STOP1:
IFN %HIDBG,<
	MOVEI	T1,1
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	RETURN

BADINI:	OUTSTR	[ASCIZ/
%HIPIAF Illegal argument for init( /]
	GOTO	OBADRG

;	CALL LOCK		LOCK HISEGMENT

	ENTRY	LOCK
LOCK:
IFN %HIDBG,<
	SETZ	T1,
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	MOVEI	TEMP,20		;SET UP TO SLEEP IF LOCKED
LKLOOP:	AOSG	LOKFLG		;ARE WE LOCKED
	GOTO	EXLCHK		;NOPE, DON'T SLEEP
	HIBER	TEMP,		;SLEEP FOR SOME TIME
	HALT
	GOTO	LKLOOP		;AND GO CHECK AGAIN
EXLCHK:	SETOM	USRPRV		;SET IT UP SO THIS JOB CAN CHANGE
IFN %HIDBG,<
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	RETURN

;	CALL UNLOCK		UNLOCK HISEGMENT

	ENTRY	UNLOCK
UNLOCK:
IFN %HIDBG,<
	SETZ	T1,
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	SETOM	LOKFLG		;TURN OFF THE LOCK FLAG
	SETOM	STFLAG
	SETZM	USRPRV
IFN %HIDBG,<
	MOVEI	T1,1
	SETUWP	T1,
	HALT		>	;IFN %HIDBG
	RETURN

;	CALL EXPROG		EXIT PROGRAM RESETTING FLAGS
;				IF LAST OUT

	ENTRY	EXPROG
EXPROG:
IFN %HIDBG,<
	SETZ	TEMP,
	SETUWP	TEMP,
	HALT		>	;IFN %HIDBG
	SOSLE	NUMJOB		;IF NUMBER OF JOBS > 1
	GOTO	LOKSEG		;DON'T DESTROY SEGMENT
	SETZM	STFLAG		;OTHERWISE START CLEARING FLAGS
	HRLZ	TEMP,BEGADR	;SET UP TO DESTROY HISEG DB
	CORE	TEMP,		;CAN THAT CORE!
	OUTSTR	[ASCIZ/?USPHSG Cannot clear database
/]
	OUTSTR	[ASCIZ/
[Data base flags reset]
/]
	GOTO	EXIT.		;AND LEAVE

LOKSEG:
IFN %HIDBG,<
	SETUWP	TEMP,
	HALT		>	;IFN %HIDBG
	GOTO	EXIT.


;	CALL GETVAL( ITABL, INDEX1, INDEX2 INDEX3, . . ., IVALUE )
;				GET VALUE FROM ARRAY ITABL

	ENTRY	GETVAL
GETVAL:	CALL	GETADR		;GET LOCATION TO FIND VALUE OF
	LDB	TEMP,T1		;GET THE VALUE
	MOVEM	TEMP,@1(T2)	;AND RETURN IT
	RETURN

;	CALL PUTVAL( ITABL, INDEX1, INDEX2, INDEX3, . . .IVALUE )
;				PUT VALUE INTO ARRAY ITABL

	ENTRY	PUTVAL
PUTVAL:	CALL	GETADR		;GET LOCATION TO REPLACE
	MOVE	TEMP,@1(T2)	;GET VALUE TO PLACE
	DPB	TEMP,T1		;PLACE THE VALUE
	RETURN

;	CALL ADDVAL( ITABL, INDEX1, INDEX2, INDEX3, . . .IVALUE )
;				ADD VALUE TO ARRAY ITABL

	ENTRY	ADDVAL
ADDVAL:	CALL	GETADR		;GET LOCATION TO ALTER
	LDB	TEMP,T1		;GET VALUE
	ADD	TEMP,@1(T2)	;INCREMENT THE VLUE
	DPB	TEMP,T1		;AND PUT IT BACK
	RETURN

;	CALL DEBVAL( ITABL, INDEX1, INDEX2, INDEX3, ... BYTPTR )
	ENTRY	DEBVAL
DEBVAL:	CALL	GETADR		;GET BYTE POINTER
	MOVEM	T1,@1(T2)	;JUST RETURN IT
	RETURN

GETADR:
IFN %HIDBG,<
	SETZ	TEMP,
	SETUWP	TEMP,
	HALT		>	;IFN %HIDBG
	SKIPL	USRPRV
GCHLOP:	SKIPGE	LOKFLG		;ROUTINE CALCULATES ADDRESS INTO
	GOTO	IMLOKR		;ARRAY, CHECKING IF HISEG IS LOCKED
	MOVEI	TEMP,20
	HIBER	TEMP,		;SLEEPS UNTIL IT IS UNLOCKED
	HALT
	GOTO	GCHLOP
IMLOKR:	MOVE	T1,ARRADR
	MOVE	T2,ARG
	SKIPGE	@0(ARG)
	RETURN

	MOVN	T3,-1(ARG)
	HLRZ	T3,T3
	SUBI	T3,2
	SETZ	TEMP,
	SKIPLE	T11,@0(ARG)	;CHECK LEGALITY OF ARRAY NUMBER
	CAILE	T11,100
	GOTO	DIMERR
	SKIPN	ADRTBL(T11)
	GOTO	DIMERR
	HLRZ	T10,ADRTBL(T11)
	HLRZ	T7,DIMTBL(T10)
	HRRZ	T10,DIMTBL(T10)
	HRRZ	T11,ADRTBL(T11)
	MOVE	T4,@0(ARG)
	HLRZ	T4,ADRTBL(T4)

LOOP2:	MOVE	T5,@1(T2)
	AOS	T2
	AOS	T4
	SKIPLE	T5
	CAMLE	T5,DIMTBL(T4)
	GOTO	DIMERR
	SOS	T5
	SAVE	T4

LOOP3:	MOVE	T6,DIMTBL+1(T4)
	AOS	T4
	JUMPE	T6,EXLOOP
	IMUL	T5,T6
	GOTO	LOOP3

EXLOOP:	RESTORE	T4
	ADD	TEMP,T5
	SOJG	T3,LOOP2
	IDIV	TEMP,T7
	IMUL	T1,T10
	LSH	T1,^D30
	ADD	T1,TEMP
	ADD	T1,T11
	DPB	T10,[XWD 300600,1]	;CONSTRUCT POINTER
	MOVEM	T1,ARRADR	;AND PLACE IT
	RETURN

DIMERR:	OUTSTR	[ASCIZ/
%HIPDIM HIPAK Dimensional error in /]	;ROUTINE PRINTS DIMENSION ERROR
	HRRZ	TEMP,(STACK)	;GET WHERE WE CAME FROM
	SUBI	TEMP,1		;WANT ACTUAL ADDRESS
	CAIN	TEMP,GETVAL	;IF IT WAS GETVAL
	OUTSTR	[ASCIZ/GET/]	;SAY GETVAL BLEW UP
	CAIN	TEMP,PUTVAL	;OR OR PUTVAL
	OUTSTR	[ASCIZ/PUT/]
	CAIN	TEMP,ADDVAL	;OR ADDVAL
	OUTSTR	[ASCIZ/ADD/]
	OUTSTR	[ASCIZ/VAL( /]
OBADRG:	MOVN	TEMP,-1(ARG)	;NOW PRINT OUT THE ARGUMENTS
	HLRZ	TEMP,TEMP
	MOVE	T1,ARG
DIMLOP:	SOJL	TEMP,ENDMLP
	MOVE	T2,@0(T1)
	SETZ	T4,
	JUMPGE	T2,NLOOP
	OUTCHR	["-"]
	MOVN	T2,T2
NLOOP:	IDIVI	T2,^D10
	ADDI	T3,"0"
	SAVE	T3
	ADDI	T4,1
	JUMPG	T2,NLOOP
OLOOP:	RESTORE	T3
	OUTCHR	T3
	SOJG	T4,OLOOP
	JUMPLE	TEMP,ENDMLP
	OUTSTR	[ASCIZ/, /]
	AOJA	T1,DIMLOP

ENDMLP:	OUTSTR	[ASCIZ/ ).
/]
	EXIT	1,
	RETURN

	RELOC			;LOW
ARRADR:	0			;GETS OLD ADDRESS
USRPRV:	0			;GETS PRIV FLAG
	RELOC			;HIGH

	PRGEND
	TITLE	.MAIN.				;PAGE 26
	SEARCH	PACK, UUOSYM

	EXTERN	FMAIN
	ENTRY	EXIT.,	FORER.

START:	RESET			;RESET ALL I/O DEVICES
	MOVE	STACK,[IOWD 1000,STKLOC]	;GET A STACK
	CALL	FMAIN		;CALL THE ACTUAL MAINLINE
	GOTO	EXIT.		;AND STOP IF IT SHOULD RETURN

	ENTRY	ERROR
ERROR:	MOVE	TEMP,ERRFLG	;RETURN THE ERROR FLAG
	RETURN

	ENTRY	ERRFLG
ERRFLG:	0

FORER.:	OUTSTR	[ASCIZ/?USPFOR Error.
/]

EXIT.:	EXIT	T1,
	GOTO	EXIT.

STKLOC:	BLOCK	1000		;STACK

	END	START
