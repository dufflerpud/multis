Cindx#	star.for - My first multi-user game, Star Trek
C@HDR@	$Id$
C@HDR@
C@HDR@	Copyright (c) 1979-2026 Christopher Caldwell (Christopher.M.Caldwell0@gmail.com)
C@HDR@
C@HDR@	Permission is hereby granted, free of charge, to any person
C@HDR@	obtaining a copy of this software and associated documentation
C@HDR@	files (the "Software"), to deal in the Software without
C@HDR@	restriction, including without limitation the rights to use,
C@HDR@	copy, modify, merge, publish, distribute, sublicense, and/or
C@HDR@	sell copies of the Software, and to permit persons to whom
C@HDR@	the Software is furnished to do so, subject to the following
C@HDR@	conditions:
C@HDR@	
C@HDR@	The above copyright notice and this permission notice shall be
C@HDR@	included in all copies or substantial portions of the Software.
C@HDR@	
C@HDR@	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
C@HDR@	KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
C@HDR@	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
C@HDR@	AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
C@HDR@	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
C@HDR@	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
C@HDR@	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
C@HDR@	OTHER DEALINGS IN THE SOFTWARE.
C
Chist#	2026-02-17 - Christopher.M.Caldwell0@gmail.com - Created
C------------------------------------------------------------------------
Cdoc#	star.for - My first multi-user game, Star Trek
Cdoc#	Made with Roger Long's inspiration and Robert Kenney's HIPAK.MAC.
Cdoc#	Based on Michael O'Shaughnessy's "star.bas"
Cdoc#	Novel at the time because it had a continuously updating screen,
Cdoc#	was multi-user and real time.  Drained enough resources from
Cdoc#	the University's DEC10 that it was frequently banned.
C------------------------------------------------------------------------
C
C
C
C	CREATED DECEMBER 29, 1979
C
C		** STAR **
C
C		BY CHRIS CALDWELL
C		  AT THE UNIVERSITY OF NEW HAMPSHIRE
C
C
C
	SUBROUTINE DEFCOL

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLBLA )
	RETURN
	END

	REAL FUNCTION SMCOS( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMCOS = COS( D * 3.141592654/180.0 )
	END

	REAL FUNCTION SMSIN( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMSIN = SIN( D * 3.141592654/180.0 )
	RETURN
	END

	SUBROUTINE UPDSCR
     & ( IQX, IQY, ISX, ISY, ICHAR, DAMAGE, IPLAYR, HYPER )
C
C  --	ROUTINE UPDATE SENSORS
C
	INTEGER QUAD(3,3), SECTOR(11,11), IOLIST(6), DAMAGE(7,2)
	INTEGER XBORD(11,2), YBORD(11,2), IQX, IQY, ISX, ISY, I
	INTEGER IOX, IOY, IOSX, IOSY, IVAL, IXQ, IYQ, IQXINC, IQYINC
	INTEGER ICHAR, IPLAYR, ISX1, ISY1, IX, IY
	REAL RTEMP
	LOGICAL HYPER
	INTEGER IFGCOL(6)

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	DATA IOLIST/0,42,43,32,45,46/
	IFGCOL(1) = ICLBLA
	IFGCOL(2) = ICLYEL
	IFGCOL(3) = ICLLBL
	IFGCOL(4) = ICLBLA
	IFGCOL(5) = ICLWHI
	IFGCOL(6) = ICLRED

C
C  --	UPDATE QUADRANT POSITION
C
	IF( (IQX .EQ. IOX) .AND. (ICHAR .NE. 'N') )GOTO 15
	CALL COLCUR( 48, 16 )
	DO 10 I= -1, 1
	    CALL NUMBER( MOD( IQX + I + 9, 10 ) + 1, 8 )
10	CONTINUE
	CALL COLCUR( 36, 20 )
	CALL NUMBER( IQX, 2 )
C
15	IF( (IQY .EQ. IOY) .AND. (ICHAR .NE. 'N') ) GOTO 30
	DO 20 I= -1, 1
	    CALL COLCUR( 47, 20 + I*2 )
	    CALL NUMBER( MOD( IQY + I + 9, 10 ) + 1, 2 )
20	CONTINUE
	CALL COLCUR( 42, 20 )
	CALL NUMBER( IQY, 2 )
30	IOX = IQX
	IOY = IQY
C
C  --	UPDATE SECTOR POSITION
C
	IF( ISX .EQ. IOSX .AND. ICHAR .NE. 'N' ) GOTO 40
	CALL COLCUR( 34, 21 )
	CALL NUMBER( ISX, 2 )
	IF( 6-IOSX .LT. 1 ) GOTO 35
	CALL CURSOR( (6-IOSX)*2 + 1, 12 )
	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLWHI )
	CALL CHROUT('-')
35	IF( 16-IOSX .GT. 11 ) GOTO 37
	CALL CURSOR( (16-IOSX)*2 + 1, 12 )
	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLWHI )
	CALL CHROUT('-')
37	IF( 6-ISX .LT. 1 ) GOTO 39
	CALL CURSOR( (6-ISX)*2 + 1, 12 )
	CALL PCOLOR( ICLDBL )
	CALL PBACK( ICLWHI )
	CALL CHROUT('|')
39	IF( 16-ISX .GT. 11 ) GOTO 40
	CALL CURSOR( (16-ISX)*2 + 1, 12 )
	CALL PCOLOR( ICLDBL )
	CALL PBACK( ICLWHI )
	CALL CHROUT('|')
40	IOSX = ISX
C
	IF( ISY .EQ. IOSY .AND. ICHAR .NE. 'N' ) GOTO 49
	CALL COLCUR( 39, 21 )
	CALL NUMBER( ISY, 2 )
43	IF( 6-IOSY .LT. 1 ) GOTO 45
	CALL CURSOR( 24, (6-IOSY) + 12 )
	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLWHI )
	CALL CHROUT('|')
45	IF( 16-IOSY .GT. 11 ) GOTO 47
	CALL CURSOR( 24, (16-IOSY) + 12 )
	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLWHI )
	CALL CHROUT('|')
47	IF( 6-ISY .LT. 1 ) GOTO 48
	CALL CURSOR( 24, (6-ISY) + 12 )
	CALL PCOLOR( ICLDBL )
	CALL PBACK( ICLWHI )
	CALL CHROUT('_')
48	IF( 16-ISY .GT. 11 ) GOTO 49
	CALL CURSOR( 24, (16-ISY) + 12 )
	CALL PCOLOR( ICLDBL )
	CALL PBACK( ICLWHI )
	CALL CHROUT('_')
49	IOSY = ISY
C
C  --	UPDATE L.R. SENSOR
C
	DO 50 IQXINC = -1, 1
	    DO 50 IQYINC = -1, 1
		IXQ = MOD( IQX + IQXINC + 9, 10 ) + 1
		IYQ = MOD( IQY + IQYINC + 9, 10 ) + 1
		CALL GETVAL( 2, IXQ, IYQ, IVAL )
		IF( IQXINC.EQ.0 .AND. IQYINC.EQ.0 ) IVAL=IVAL-1000
		IF( DAMAGE(3,1) .NE. 0 ) IVAL = 100000
		IF( QUAD( IQXINC+2, IQYINC+2 ) .EQ. IVAL .AND.
     &		ICHAR .NE. 'N' ) GOTO 50
		QUAD( IQXINC+2, IQYINC+2 ) = IVAL
		CALL COLCUR( IQXINC*8 + 59, IQYINC*2 + 20 )
		IF( IVAL .LE. 9999 ) GOTO 41
		CALL PBACK( ICLWHI )
		CALL PCOLOR( ICLBLA )
		CALL STRING(' -----  ^E')
		GOTO 50

41		IFG = ICLWHI
		IF( IVAL .GT.    0 ) IFG = ICLYEL
		IF( IVAL .GE.   10 ) IFG = ICLLBL
		IF( IVAL .GE.  100 ) IFG = ICLPUR
		IF( IVAL .GE. 1000 ) IFG = ICLRED
		CALL PBACK( ICLBLA )
		CALL PCOLOR( IFG )
		CALL CHROUT(' ')
		CALL NUMBER( IVAL, 5 )
		CALL CHROUT(' ')
50	CONTINUE
C
C  --	UPDATE S.R. SENSOR
C
	DO 60 IX = -5, 5
	    IQXINC = IQX
	    RTEMP = SQWRAP( IQXINC, ISX1, FLOAT(IX+ISX) )
	    DO 60 IY = -5, 5
		IF( IX .EQ. 0 .AND. IY .EQ. 0 ) GOTO 60
		IQYINC = IQY
		RTEMP = SQWRAP( IQYINC, ISY1, FLOAT(IY+ISY) )
		CALL GETVAL( 1, IQXINC, IQYINC, ISX1, ISY1, IVAL )
		IF( DAMAGE( 2,1 ) .NE. 0 .OR. HYPER ) IVAL = 0

		IBACK = ICLWHI
		IFORE = ICLRED
		IF( IVAL .GE. 6 ) GOTO 56

		IF( IVAL .LT. 0 ) IVAL = 5
		IBACK = ICLBLA
		IFORE= IFGCOL( IVAL + 1 )
		IVAL = IOLIST( IVAL + 1 )

56		CONTINUE

		IF(( ICHAR .NE. 'N' .AND.
     &		IVAL .EQ. SECTOR(6+IX,6+IY)) .OR.
     &		( ICHAR .EQ. 'N' .AND. IVAL .EQ. 0 )) GOTO 60

		CALL CURSOR( 13+2*IX, 18+IY )
		CALL PBACK( IBACK )
		CALL PCOLOR( IFORE )
		IF( IVAL .EQ. 0 ) CALL CHROUT( ' ' )
		IF( IVAL .NE. 0 ) CALL CHROUT( IVAL )
		SECTOR( 6+IX, 6+IY ) = IVAL
60	CONTINUE
	RETURN
	END
	REAL FUNCTION RBOUND ( RNUM )
C
C  --	ROUTINE LIMITS RNUM WITHIN 360.0
C
	REAL RNUM
C
	RBOUND = RNUM
C
10	IF( RBOUND .GE. 0.0 ) GOTO 20
	RBOUND = RBOUND + 360.0
	GOTO 10
C
20	IF( RBOUND .LT. 360.0 ) RETURN
	RBOUND = RBOUND - 360.0
	GOTO 20
	END
	SUBROUTINE DAMAGM( DAMAGE, MUCH, ISHELD )
C
C  --	ROUTINE DOES AS MUCH DAMAGE AS IS SUITABLE FOR MUCH
C
	INTEGER DAMAGE( 7, 2 ), MUCH, ISHELD, IPRIO( 7 ), LEFT
	INTEGER I, J, J1
	DATA IPRIO/3,4,5,2,1,6,7/
C
	IF( MUCH .GT. ISHELD ) GOTO 5
	ISHELD = ISHELD - MUCH
	RETURN
C
5	LEFT = MUCH - ISHELD
	ISHELD = 0
	I = IRAN( 7 )
	DO 10 J = 1, I
7	    J1 = IRAN( 7 )
	    IF( IPRIO(J1) .LT. IRAN( 7 ) ) GOTO 7
	    DAMAGE(J1,1) = DAMAGE(J1,1) + 1231*LEFT/IRAN(I)
	    DAMAGE(J1,2) = MAX0( 0, DAMAGE(J1,2) - IRAN(40)*LEFT/I )
10	CONTINUE
	RETURN
	END
	SUBROUTINE PRINT
C
C  --	OUTPUTS SCREEN CHARACTERS THAT ARE NOT UPDATED
C
	INTEGER I

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA
C
	CALL USRSET("2002,"1)
C
C  --	DRAW S.R. SENSOR GRID
C
	CALL CLRSCR
	CALL CURSOR( 1, 24 )
	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLWHI )
	CALL STRING
     &('+----------------------+^M^J^E')
	DO 5 I = 1, 11
	    CALL CHROUT('|')
	    CALL PBACK( ICLBLA )
	    CALL STRING('                      ^E')
	    CALL PBACK( ICLWHI )
	    CALL STRING('|^M^J^E')
5	CONTINUE
	CALL STRING('+----------------------+^E')
C
C  --	PUT USEFUL INFORMATION BESIDE IT
C
	CALL COLCUR( 26, 23 )
	CALL STRING('Stardate:^E')
	CALL COLCUR( 26, 22 )
	CALL STRING('Energy:    %^E')
	CALL COLCUR( 26, 21 )
	CALL STRING('Sector:    -^E')
	CALL COLCUR( 26, 20 )
	CALL STRING('Quadrant:    -^E')
	CALL COLCUR( 26, 19 )
	CALL STRING('Torpedos:^E')
	CALL COLCUR( 26, 18 )
	CALL STRING('Shields:    %^E')
	CALL COLCUR( 26, 17 )
	CALL STRING('Degrees:^E')
	CALL COLCUR( 26, 16 )
	CALL STRING('Bearing:^E')
	CALL COLCUR( 26, 15 )
	CALL STRING('Warp:^E')
	CALL COLCUR( 26, 14 )
	CALL STRING('To warp:^E')
	CALL COLCUR( 26, 13 )
	CALL STRING('Banks:^E')
C
C  --	DRAW L.R. SENSOR GRID
C
	CALL PCOLOR( ICLWHI )
	DO 10 I= 0, 2
	    CALL CURSOR( 50, 17 + I*2 )
	    CALL PBACK( ICLWHI )
	    CALL STRING('+-------+-------+-------+^E')
	    CALL CURSOR( 50, 18 + I*2 )
	    CALL CHROUT('|')
	    DO 9 J = 1, 3
	        CALL PBACK( ICLBLA )
	        CALL STRING('       ^E')
		CALL PBACK( ICLWHI )
		CALL CHROUT('|')
9	    CONTINUE
10	CONTINUE
	CALL CURSOR( 50, 23 )
	CALL STRING('+-------+-------+-------+^E')
C
C  --	MAKE DAMAGE REPORT
C
	CALL COLCUR( 1,11 )
	CALL STRING('Device        Repair state (Time)   Crew
     &^M^J------        -------------------   ----
     &^M^JWarp engines
     &^M^JS.R. sensors
     &^M^JL.R. sensors
     &^M^JTorpedos
     &^M^JPhasers
     &^M^JShields
     &^M^JLife support
     &^M^J^JCommand:^E')
	RETURN
	END
	SUBROUTINE COMAND( ICHAR, COMARA, ARRIND )
C
C  --	ROUTINE GET COMMAND FROM USER IF ONE PRESENT.
C
	INTEGER COMARA(81), INDEX, ARRIND, ICHAR
	DATA INDEX/0/
C
C  --	IF THERE IS A CHARACTER OUT GET IT, ELSE, SLEEP FOR
C  --	0.5 SECONDS OR UNTIL ONE IS.
C
10	CALL NAP( 500, "14 )
	CALL CHRBUF( ICHAR )
	IF( ICHAR .EQ. -1 ) RETURN
	IF( ICHAR .EQ. "10 .OR. ICHAR .EQ. "177 ) GOTO 20
	IF( ICHAR .EQ. "25 ) GOTO 40
	IF( ICHAR .EQ. "33 .AND. INDEX .EQ. 0 ) GOTO 15
	IF( ICHAR .LT. "40 ) GOTO 45
	IF( INDEX .GE. 80 ) GOTO 50
C
C  --	NOT SPECIAL CHARACTER, PUT IN ARRAY
C
	INDEX = INDEX + 1
	CALL COLCUR( 9 + INDEX, 1 )
	CALL CHROUT( ICHAR )
	CALL CURBUF
	COMARA(INDEX) = ICON( ICHAR )
	GOTO 10
C
C  --	ESCAPE:  REPEAT LAST COMMAND
C
15	IF( COMARA(1) .EQ. 'R' ) INDSTR = 0
	INDEX = INDSTR
	CALL COLCUR( 10, 1 )
	IF( INDEX .NE. 0 )CALL STRING( COMARA, 1, INDEX )

	GOTO 45
C
C  --	DELETE CHARACTER
C
20	CALL COLCUR( 9 + INDEX, 1 )
	CALL CHROUT( ' ' )
	CALL CURBUF
	INDEX = INDEX - 1
	IF( INDEX .LT. 0 ) INDEX = 0
	GOTO 10
C
C  --	DELETE LINE
C
40	CALL COLCUR( 10, 1 )
	DO 43 I = 1, INDEX
	    CALL CHROUT(' ')
43	CONTINUE
	CALL CURBUF
	INDEX = 0
	GOTO 10
C
C  --	CARRIAGE RETURN TYPED
C
45	IF( INDEX .NE. 0 ) GOTO 50
	ICHAR = -1
	GOTO 70
50	COMARA(INDEX + 1) = 0
	CALL COLCUR( 10, 1 )
	DO 60 I = 1, INDEX
	CALL CHROUT(' ')
60	CONTINUE
	CALL ALLCAP( COMARA, 2 )	! REST OF CMD IS NUMBERS OR MESSAGE
	ICHAR = COMARA(1)
70	ARRIND = INDEX
	INDSTR = INDEX
	INDEX = 0
	CALL CURBUF
	CALL NAP( 500, 4 )
	RETURN
	END
	SUBROUTINE INITDB
C
C  -	INITIALIZE HISEGMENT
C
	INTEGER INMLST(3), IQX, IQY, ISX, ISY, IVAL, I, I1, J
	DATA INMLST/ 200, 5, 4 /
C
C  --	CREATE NEEDED CORE
C
C	ARRAY #1 CONTAINS EVERYTHING IN THE GALAXY
	CALL INIT(1,36,10,10,10,10)
C	ARRAY #2 CONTAINS L.R. INFORMATION FOR THE ENIRE GALAXY
	CALL INIT(2,36,10,10)
C	ARRAY #3 CONTAINS GENERAL INFORMATION
C	ITEM	CONTAINS
C	1	# OF PLAYERS
C	2	CURRENT DATE
C	3	DESTINATION OF LAST SEND
C	4	VICTIM OF AXIS
C	5	CURRENT ENERGY OF AXIS
	CALL INIT(3,36,10)
C	ARRAY #4 CONTAINS INFORMATION ABOUT EACH PLAYER
C	ITEM	CONTAINS
C	1	JOB (OR IF AXIS, CONTAINS NEGATIVE OF CONTROLLER)
C	2-3	PLAYER'S NAME
C	4	PHOTON TORPEDO AND PHASER FLAGS
C	5	HOW FAST SHIP MOVES
C	6	IF HIT, WHO HIT ME
C	7	IF HIT, HOW FAST HE WAS MOVING
C	8	DEGREE HEADING OF SHIP
C	9,10	QUADRANT LOCATION OF SHIP
C	11,12	SECTOR LOCATION OF SHIP
C	13	DOCKING ENERGY
C	14	DOCKING TORPEDOS
C	15	DOCKING CREW
C	16	#KILLS FOR PLAYER
C	17	WHO SHOT AT ME
	CALL INIT(4,36,26,17)
C	ARRAY #5 CONTAINS INFORMATION FOR COMMUNICATION
C	ITEM	CONTAINS
C	1	LENGTH OF MESSAGE
C	2	SOURCE OF MESSAGE
C	3-71	MESSAGE
	CALL INIT(5,7,71)
C
C  --	CREATE A FEW STORMS
C
	IVAL = IRAN(8)
	DO 10 I=1, IVAL
	    IQX = IRAN(10)
	    IQY = IRAN(10)
	    ISX = IRAN(10)
	    ISY = IRAN(10)
	    CALL NOVA( IQX, IQY, ISX, ISY )
10	CONTINUE
C
C  --	CREATE A RANDOM STARDATE
C
	CALL PUTVAL( 3, 2, IRAN(4999999)+1000000 )
C
C  --	CREATE STARS, STARBASES AND BLACK HOLES
C
	DO 40 I1 = 1, 3
	    I=I1
	    DO 40 J=1, INMLST(I)
20		IQX = IRAN( 10 )
		IQY = IRAN( 10 )
		CALL GETVAL( 2, IQX, IQY, IVAL )
		IF( IVAL .GE. 9 ) GOTO 20
		CALL ADDVAL( -2, 10^(I-1) )
30		ISX = IRAN( 10 )
		ISY = IRAN( 10 )
		CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
		IF( IVAL .NE. 0 ) GOTO 30
		CALL PUTVAL( -1, I )
		IF( I1 .EQ. 3 ) CALL NOVA( IQX, IQY, ISX, ISY )
40	CONTINUE
	CALL UNLOCK
	RETURN
	END
	SUBROUTINE NOVA( IQX, IQY, ISX, ISY )
C
C  --	ROUTINE CREATES NOVAE FOR ANY NUMBER OF REASONS
C
	INTEGER I, IQX, IQY, IQX1, IQY1, ISX, ISY, ISX1, ISY1
	INTEGER IVAL, INOX(21), INOY(21)
	REAL SX, SY
	DATA INOX/-1,0,1,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,
     & -1,0,1/
	DATA INOY/-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,
     & 2,2,2/
C
	DO 10 I = 1, 21
	    IQX1 = IQX
	    IQY1 = IQY
	    SX = SQWRAP( IQX1, ISX1, FLOAT( ISX+INOX(I) ) )
	    SY = SQWRAP( IQY1, ISY1, FLOAT( ISY+INOY(I) ) )
	    CALL GETVAL( 1, IQX1, IQY1, ISX1, ISY1, IVAL )
	    IF( IVAL .NE. 0 ) GOTO 5
	    IF( IRAN(10) .LT. 4 ) GOTO 10
	    CALL PUTVAL( -1, 4 )
	    GOTO 10
5	    IF( IVAL .LT. 7 ) GOTO 8
	    CALL PUTVAL( 4, IVAL-64, 7, -0.6 )
	    GOTO 10
8	    IF( IVAL .NE. 1 ) GOTO 10
	    CALL PUTVAL( -1, 0 )
	    CALL ADDVAL( 2, IQX1, IQY1, -1 )
	    CALL SECNOV( IQX1, IQY1, ISX1, ISY1, INOX, INOY )
10	CONTINUE
	RETURN
	END
C
	SUBROUTINE SECNOV( IQX, IQY, ISX, ISY, INOX, INOY )
C
C  --	ROUTINE PERFORMS A SECONDARY NOVA
C
	INTEGER I, IQX, IQY, IQX1, IQY1, ISX, ISY, ISX1, ISY1
	INTEGER IVAL, INOX(21), INOY(21)
	REAL SX, SY
C
	DO 10 I = 1, 21
	    IQX1 = IQX
	    IQY1 = IQY
	    SX = SQWRAP( IQX1, ISX1, FLOAT( ISX+INOX(I) ) )
	    SY = SQWRAP( IQY1, ISY1, FLOAT( ISY+INOY(I) ) )
	    CALL GETVAL( 1, IQX1, IQY1, ISX1, ISY1, IVAL )
	    IF( IVAL .NE. 0 ) GOTO 5
	    IF( IRAN(10) .LT. 4 ) GOTO 10
	    CALL PUTVAL( -1, 4 )
	    GOTO 10
5	    IF( IVAL .LE. 6 ) GOTO 10
	    CALL PUTVAL( 4, IVAL-64, 7, -0.6 )
10	CONTINUE
	RETURN
	END
	REAL FUNCTION SQWRAP( IQ, IS, S )
C
C  --	CONTROLS WRAP AROUND AND QS LOCATION
C
	INTEGER IQ, IS
	REAL S
C
	SQWRAP = S
C
10	IF( SQWRAP .GE. 0.5 )GOTO 20
	SQWRAP = SQWRAP + 10.0
	IQ = IQ - 1
	GOTO 10
C
20	IF( SQWRAP .LT. 10.5 )GOTO 30
	SQWRAP = SQWRAP - 10.0
	IQ = IQ + 1
	GOTO 20
C
30	IQ = MOD( IQ + 9, 10 ) + 1
	IS = SQWRAP + 0.5
	RETURN
	END
	SUBROUTINE CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
C
C  --	ROUTINE GETS RID OF SHIP ON ^C OR EXIT COMMAND
C
	INTEGER IPLAYR, IQX, IQY, ISX, ISY, IVAL, FAULT
	LOGICAL BEEN
C
	IF( BEEN ) RETURN
	BEEN = .TRUE.
	CALL UNLOCK
	IF( FAULT .NE. 0 ) CALL ADDVAL( 4, FAULT, 16, 1 )
	CALL ADDVAL( 3, 1, -1 )
	CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
	IF( IVAL .EQ. IPLAYR+64 ) CALL PUTVAL( -1, 0 )
	CALL ADDVAL( 2, IQX, IQY, -1000 )
	CALL PUTVAL( 4, IPLAYR, 1, 0 )
	CALL NOVA( IQX, IQY, ISX, ISY )
	CALL USRSET("2007,"0)
	CALL USRSET("2002,"0)
	CALL USRSET("2021,"1)
	CALL COLCUR(1,1)
	CALL CLOSE( 1 )
	CALL EXPROG
	END
	SUBROUTINE UPSHIP( IPLAYR, ICHAR )
C
C  --	ROUTINE UPDATES SHIP ROSTER
C
	INTEGER SHIP(18), S(18), ICNT, IOCNT, I, I1, SCORE
	INTEGER IVAL, IPLAYR, ISHIP, ICHAR, IQX, IQY, ISX, ISY
	LOGICAL RUN, ORUN, LOGDIN

C
	ICNT = 0
	DO 20 I1=1,26
	    I=I1
C	    IMVAL = MOD( I, 7 ) + 1
	    CALL GETVAL( 4, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 20
	    IF( IVAL .LT. 0 ) GOTO 10
	    IF( .NOT. LOGDIN(IVAL) ) GOTO 8
	    IF( JOB(-1) .EQ. 0 ) GOTO 10
	    IF((JSTAT(IVAL).NE.ISXBIT('^C' )).AND.(ITTY(IVAL).NE.-1))
     &	    GOTO 10
8	    CALL PUTVAL( -4, 0 )
	    CALL ADDVAL( 3, 1, -1 )
	    CALL PUTVAL( 3, 3, 0 )
	    CALL GETVAL( 4, I, 9, IQX )
	    CALL GETVAL( 4, I, 10, IQY )
	    CALL ADDVAL( 2, IQX, IQY, -1000 )
	    CALL GETVAL( 4, I, 11, ISX )
	    CALL GETVAL( 4, I, 12, ISY )
	    CALL PUTVAL( 1, IQX, IQY, ISX, ISY, 0 )
	    GOTO 20

10	    ICNT = ICNT + 1
	    ISHIP = I
	    CALL GETVAL( 4, I, 16, SCORE )
	    IF(SHIP(ICNT).EQ.I.AND.ICHAR.NE.'N'.AND.SCORE.EQ.S(ICNT))
     &		GOTO 19
	    IF( ICNT .LE. 9 ) CALL COLCUR( 43, 12-ICNT )
	    IF( ICNT .GT. 9 ) CALL COLCUR( 62, 21-ICNT )
	    CALL CHROUT( I+64 )
	    CALL CHROUT(' ')
	    CALL NUMBER( SCORE )
	    CALL STRING(': ^E')
	    S(ICNT) = SCORE
	    CALL GETVAL( 4, I, 2, IVAL )
	    CALL STRING( IVAL, 6, 6 )
	    CALL GETVAL( 4, I, 3, IVAL )
	    CALL STRING( IVAL, 6, 6 )
19	    SHIP(ICNT) = I
20	CONTINUE
C
	IF( ICNT .GE. IOCNT .OR. ICHAR .EQ. 'N' ) GOTO 31
	DO 30 I= ICNT+1, IOCNT
	    IF( I .LE. 9 ) CALL COLCUR( 43, 12-I )
	    IF( I .GT. 9 ) CALL COLCUR( 62, 21-I )
	    CALL STRING('                  ^E')
	    SHIP(I) = 0
30	CONTINUE
31	CONTINUE
	IOCNT = ICNT
C
	IF( IPLAYR .NE. ISHIP ) RETURN
	CALL GETVAL( 3, 2, ITIM )
	ITIM = ITIM + 1
	CALL ADDVAL( -3, 1 )
C
C**********************************************************
C***                 AXIS CONTROLLER                    ***
C**********************************************************
C
	CALL GETVAL( 3, 3, IVAL )
	IF( IVAL .NE. 1 ) GOTO 45
	CALL GETVAL( 3, 4, IVICTM )
	CALL GETVAL( 5, 2, IVAL )
	CALL GETVAL( 4, IVAL, 1, IVJOB )
	IPN = IRIGHT( IGTAB( IVJOB, 2 ) )
	CALL GETVAL( 5, 3, IJUNK )
	IF( IJUNK .NE. 64 .OR. IPN .NE. "17433 ) GOTO 41
	CALL GETVAL( 5, 4, IJUNK )
	IF( IJUNK .LT. 66 .OR. IJUNK .GT. 91 ) GOTO 41
	IVAL = IJUNK - 64
	CALL AXISND( IVAL, 13, 'You will die.' )
	GOTO 42
	
41	IF( IVICTM .NE. 0 ) GOTO 43
	CALL AXISND( IVAL, 60,
     &'For your impertinence, you will be exterminated by the Axis.')
42	CALL PUTVAL( 3, 4, IVAL )
	GOTO 45

43	IF( IVAL .NE. IVICTM )
     &CALL AXISND( IVAL, 29, 'You will be eliminated later.')
	IF( IVAL .EQ. IVICTM )
     &CALL AXISND( IVAL, 28, 'Be silent before your death.')

45	CALL GETVAL( 4, 1, 1, IVAL )
	IF( IVAL .NE. 0 ) GOTO 100
C
C  --	CREATE THE AXIS
C
	CALL PUTVAL( 4, 1, 2, ISXBIT('Axis') )
	CALL PUTVAL( 4, 1, 3, 0 )
	CALL PUTVAL( 3, 5, 100 )
C
50	IQX = IRAN( 10 )
	IQY = IRAN( 10 )
	ISX = IRAN( 10 )
	ISY = IRAN( 10 )
	CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL1 )
	IF( IVAL1 .NE. 0 ) GOTO 50
	CALL PUTVAL( -1, 65 )
	CALL ADDVAL( 2, IQX, IQY, 1000 )
	GOTO 110

100	IF( IVAL .EQ. -IPLAYR ) GOTO 120
	CALL GETVAL( 4, 1, 9, IQX )
	CALL GETVAL( 4, 1, 10, IQY )
	CALL GETVAL( 4, 1, 11, ISX )
	CALL GETVAL( 4, 1, 12, ISY )
	CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL1 )
110	SX = ISX + .5
	SY = ISY + .5
	CALL PUTVAL( 4, 1, 1, -IPLAYR )

120	CALL GETVAL( 3, 5, INERGY )
	CALL GETVAL( 3, 4, IVICTM )
	IF( IVICTM .EQ. 0 ) GOTO 147
	CALL GETVAL( 4, IVICTM, 1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 147

	CALL GETVAL( 4, IVICTM, 9, IVQX )
	CALL GETVAL( 4, IVICTM, 10, IVQY )
	CALL GETVAL( 4, IVICTM, 11, IVSX )
	CALL GETVAL( 4, IVICTM, 12, IVSY )
	IX = IQX*10 + ISX - 11
	IY = IQY*10 + ISY - 11
	IVX = IVQX*10 + IVSX - 11
	IVY = IVQY*10 + IVSY - 11
	IF( IABS( IVX-IX ) .GT. IABS( IVX+100-IX ) ) IVX = IVX + 100
	IF( IABS( IVY-IY ) .GT. IABS( IVY+100-IY ) ) IVY = IVY + 100
	IF( IABS( IVX-IX ) .GT. IABS( IVX-100-IX ) ) IVX = IVX - 100
	IF( IABS( IVY-IY ) .GT. IABS( IVY-100-IY ) ) IVY = IVY - 100
	ADIST = SQRT((IVX-IX+0.0)^2+(IVY-IY+0.0)^2)
	IF( ADIST .GT. 5 ) GOTO 135
	CALL GETVAL( 1, IVQX, IVQY, IVSX, IVSY, IVAL )
	IF( IVAL .NE. IVICTM+64 ) GOTO 135
	IF( ADIST.GT.1.6 .OR. INERGY.LT.25 .OR. IRAN(3).NE.1 ) GOTO 132
	INERGY = INERGY - 10
	CALL PUTVAL( 4, IVICTM, 4, -20 )
	CALL PUTVAL( 4, IVICTM, 17, 1 )
	GOTO 135
132	IF( INERGY .LT. 20 .OR. IRAN(5) .NE. 1 ) GOTO 135
	INERGY = INERGY / 2
	CALL PUTVAL( 4, IVICTM, 4, IFIX(INERGY/SQRT(ADIST)) )
	CALL PUTVAL( 4, IVICTM, 17, 1 )
135	IF( IX .NE. IVX ) GOTO 140
	IBEAR = 90
	IF( IY .GT. IVY ) IBEAR = 270
	GOTO 145
140	IBEAR = IFIX(ATAN( FLOAT(IX-IVX)/FLOAT(IY-IVY) ) * 180./3.14159)
	IF( IX .GT. IVX ) IBEAR = IBEAR + 180
145	RUN = .FALSE.
	IF( INERGY .LT. 10 ) RUN = .TRUE.
	IF( RUN ) IBEAR = IBEAR - 180
	IF( RUN .AND. .NOT. ORUN ) CALL AXISND( IVICTM, 40,
     &'I shall return to destroy your ship yet.')
	IF( ORUN .AND. .NOT. RUN ) CALL AXISND( IVICTM, 15,
     &'Prepare to die.')
	ORUN = RUN
	GOTO 150
C
147	IF( MOD( ITIM, 20 ) .EQ. 0 ) IBEAR = IRAN( 360 )
	CALL PUTVAL( 3, 4, 0 )
C
150	CALL GETVAL( 4, 1, 8, DEGREE )
	DEGI = 12.34
	IF( MOD( IFIX(IBEAR-DEGREE)+720, 360 ) .GT. 180 ) DEGI = -DEGI
	DEGREE = DEGREE + DEGI
	IF(MOD(IFIX(ABS(IBEAR-DEGREE))+720,360).LT.ABS(DEGI))
     &DEGREE=IBEAR
	DEGREE = RBOUND( DEGREE )
	CALL PUTVAL( 4, 1, 8, RBOUND( DEGREE ) )
	CALL PUTVAL( 1, IQX, IQY, ISX, ISY, 0 )
	CALL ADDVAL( 2, IQX, IQY, -1000 )
160	SX = SQWRAP( IQX, ISX, SX+SMCOS(DEGREE)/2. )
	SY = SQWRAP( IQY, ISY, SY+SMSIN(DEGREE)/2. )
	CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
	IF( IVAL .GT. 0 ) GOTO 160
	IF( IVAL .LT. 0 ) INERGY = INERGY - 20
	CALL PUTVAL( -1, 65 )
	CALL ADDVAL( 2, IQX, IQY, 1000 )
	CALL PUTVAL( 4, 1, 9, IQX )
	CALL PUTVAL( 4, 1, 10, IQY )
	CALL PUTVAL( 4, 1, 11, ISX )
	CALL PUTVAL( 4, 1, 12, ISY )
	CALL GETVAL( 4, 1, 4, IDAM )
	CALL PUTVAL( -4, 0 )
	INERGY = INERGY - IABS( IDAM ) + 2
	IF( INERGY .GT. 100 ) INERGY = 100
	CALL PUTVAL( 3, 5, INERGY )
	IF( INERGY .GT. 0 ) GOTO 200
	CALL PUTVAL( 1, IQX, IQY, ISX, ISY, 0 )
	CALL ADDVAL( 2, IQX, IQY, -1000 )
	CALL NOVA( IQX, IQY, ISX, ISY )
	CALL PUTVAL( 4, 1, 16, 0 )
	CALL GETVAL( 4, 1, 17, IVAL )
	CALL ADDVAL( 4, IVAL, 16, 1 )
	CALL PUTVAL( 4, 1, 1, 0 )
	CALL PUTVAL( 3, 4, 0 )
	RETURN

200	IF( IDAM .EQ. 0 ) RETURN
	CALL GETVAL( 4, 1, 17, IVAL )
	IF( IVAL .EQ. IVICTM ) RETURN
	CALL AXISND( IVAL, 48,
     &'Your attack on the axis will cost you your life.')
	CALL PUTVAL( 3, 4, IVAL )
	RETURN
	END
	SUBROUTINE AXISND( IDEST, LENGTH, MESSAG )
C
C  --	SUBROUTINE SENDS A MESSAGE FROM THE AXIS SHIP
C
	INTEGER IDEST, MESSAG( LENGTH ), LENGTH, SARA( 80 )
C
	CALL PUTVAL( 3, 3, IDEST )
	CALL PUTVAL( 5, 1, LENGTH+2 )
	CALL PUTVAL( 5, 2, 1 )
	CALL CONVRT( MESSAG, LENGTH, 5, SARA, 0 )
	DO 20 I = 1, LENGTH
	    CALL PUTVAL( 5, I+2, SARA(I) )
20	CONTINUE
	RETURN
	END

	SUBROUTINE SYSWHO( IJOB )
	INTEGER UNAME(2)
	IF( JOB(IJOB) .EQ. 0 ) RETURN
	CALL STRING('Job ^E')
	CALL NUMBER( IJOB )
	CALL CHROUT(' ')
	UNAME(1) = IGTAB( IJOB, "31 )
	UNAME(2) = IGTAB( IJOB, "32 )
	CALL STRING( UNAME, 6, 12 )
	CALL STRING(' [^E')
	CALL NUMBER( ILEFT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL CHROUT(',')
	CALL NUMBER( IRIGHT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL STRING('] ^E')
	CALL STRING(' TTY^E')
	CALL NUMBER( ITTY( IJOB ), 0, 8 )
	CALL STRING(' at ^E')
	CALL NODLIN( ITTY(IJOB), IN, IL )
	CALL STRING( NODE( IN ), 6, 6 )
	CALL CHROUT('(')
	CALL NUMBER( IN, 0, 8 )
	CALL STRING(')^E')
	CALL STRING(' line ^E')
	CALL NUMBER( IL, 0, 8 )
	CALL CHROUT(' ')
	CALL STRING( JSTAT( IJOB ), 6, 2 )
	RETURN
	END
	SUBROUTINE FMAIN
C
	INTEGER COMARA( 81 ), SNAME( 2 ), DAMAGE( 7,2 ), FILESP( 13 )
	INTEGER DAM1( 7,2 ), COMMAR( 61 ), OBJVAL( 6 )
	INTEGER ITX( 25 ), ITY( 25 ), ITDIST( 25 ), MAXVAL( 12 )
	INTEGER NTORP, NNERGY, ITORP, INERGY, I, J, I1, I2, IPLAYR
	INTEGER ICHAR, IVAL, IQX, IQY, ISX, ISY, INDEX, FAULT
	INTEGER IX1, IY1, IX2, IY2, IOQX, IOQY, IOSX, IOSY, IX, IY
	INTEGER IDAT, IODAT, IONGRY, IOTORP, ISHELD, ISHOLD, ISHIP
	INTEGER DENRGY, DTORP, DCREW, OCREW, NCREW, ICREW
	INTEGER ODN, ODT, ODC, CRWNUM, ILNUM, ILMAX
	REAL DEGI, DINC, SPDI, SINC, SX, SY, DEGREE, BEARIN
	REAL SPEED, ASPEED, DECIML, UNITX, UNITY, DIST, PDIST
	REAL OSX, OSY, ODEGRE, OBEARN, OSPEED, OPEED, OTHSPD
	REAL TORPX( 25 ), TORPY( 25 ), TORPXS( 25 ), TORPYS( 25 )
	REAL STRTLP
	LOGICAL ERASE1,ERASE2,ERASE3,HYPER,OHYPER,INIFLG,OARMED,ARMED,LPRIVD
	LOGICAL ERROR, NEWANG

	COMMON/NHCOM/NEWANG
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	DATA DEGI/6.17/, SPDI/0.047/,CRWNUM/70/
	DATA NTORP/15/,NNERGY/100/,NCREW/490/,ITORP/15/,INERGY/100/
	DATA ICHAR/'N'/
	DATA OBJVAL/' ','*','+','@','-','.'/
	DATA MAXVAL/18,18,18,18,18,12,7,3,0,0,0,0/
C
C  --	SET UP TTY, GET SHIP'S NAME AND SCAN CHARACTER
C
	ICLWHI = 1
	ICLDBL = 2
	ICLRED = 3
	ICLLBL = 4
	ICLPUR = 5
	ICLGRE = 6
	ICLYEL = 7
	ICLBLA = 8

	NEWANG = .TRUE.

	CALL SETTTY( COMARA, COMMAR, I2, LPRIVD, FILESP )
	IF( I2 .EQ. 0 ) GOTO 7
	DO 6 I=1,I2
	    IF( COMMAR(I) .EQ. ISXBIT('MAP') .AND. LPRIVD ) GOTO 800
	    IF( COMMAR(I) .EQ. ISXBIT('NAME') ) ERASE1 = .TRUE.
	    IF( COMMAR(I) .EQ. ISXBIT('OLDANG') ) NEWANG = .FALSE.
6	CONTINUE
7	CONTINUE
	CALL ENABLE
	I1 = 12
	SNAME(1) = IGTAB( JOB(0), "31 )
	SNAME(2) = IGTAB( JOB(0), "32 )
	CALL CHECK( INIFLG )
	IF( INIFLG ) CALL INITDB
	CALL CTRAP
	    CALL EXPROG

	CALL GRAFON
	CALL DEFCOL
	CALL CLRSCR

	IF( .NOT. ERASE1 ) GOTO 10
	CALL STRING('Input ship''s name (12 characters): ^E')
	CALL CURBUF
	CALL GETSTR( COMARA, 12, I1 )
	IF( I1 .EQ. 0 ) GOTO 10
	CALL CONVRT( COMARA, 12, 1, SNAME, 6 )
	ERASE1 = .FALSE.
10	CALL STRING('Input character to represent the "^E')
	IF( I1 .EQ. 0 ) I1 = 12
	CALL STRING( SNAME, 6, I1 )
	CALL STRING('" in scan: ^E')
	CALL CURBUF
	CALL CHRWAT( IPLAYR )
	IF( IPLAYR .GT. 91 ) IPLAYR = IPLAYR - 32
	IPLAYR = IPLAYR - 64
C
C  --	CHECK IF IT IS LEGAL AND IF THERE IS ONE ALREADY PRESENT
C
	IF( IPLAYR .LT. 2 .OR. IPLAYR .GT. 26 ) GOTO 15
	CALL GETVAL( 4, IPLAYR, 1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 20
	CALL STRING
     &('^M^JSomebody is already using that symbol.^M^J^E')
	GOTO 10
15	CALL STRING('^M^JIllegal scan symbol.  Try again.^M^J^E')
	GOTO 10
C
C  --	UPDATE SHIP ROSTER.
C
20	CONTINUE
	CALL ENABLE
	CALL LOCK
	CALL PUTVAL( 4, IPLAYR, 1, JOB(0) )
	CALL PUTVAL( 4, IPLAYR, 2, SNAME(1) )
	CALL PUTVAL( 4, IPLAYR, 3, SNAME(2) )
	CALL PUTVAL( 4, IPLAYR, 4, 0 )
	CALL PUTVAL( 4, IPLAYR, 7, 0 )
	CALL PUTVAL( 4, IPLAYR, 16, 0 )
	CALL ADDVAL( 3, 1, 1 )
	DO 59 J = 1, 7
	    DAMAGE( J, 2 ) = CRWNUM
59	CONTINUE
	DEGREE = IRAN( 360 )
	BEARIN = DEGREE
C
C  --	MAKE UP COORDINATES FOR SHIP
C
60	CONTINUE
	    ISX = IRAN(10)
	    SX=ISX
	    ISY = IRAN(10)
	    SY=ISY
	    IQX = IRAN(10)
	    IQY = IRAN(10)
	    CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
	IF( IVAL .NE. 0 )GOTO 60
C
C  --	PLACE FINAL RESULTS IN HISEGMENT
C
	CALL PUTVAL( -1, IPLAYR+64 )
	CALL UNLOCK
	CALL ADDVAL( 2, IQX, IQY, 1000 )
	CALL CTRAP
	CALL CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
	IF( ICHAR .NE. 'N' ) GOTO 65
C
C  --	SET ALL THE TERMINAL CHARACTERISTICS NEEDED
C
	CALL USRSET("2006,"1)
	CALL USRSET("2025,"0)
	CALL USRSET("2007,"1)
	CALL USRSET("2010,"1)
	CALL USRSET("2021,"0)
	CALL USRSET("1030,TTYSPD)
	GOTO 75
C
C  --	OOPS, HE HIT A BLACK HOLE !!
C
65	CALL CURSOR( 26, 24 )
	CALL PBACK( ICLBLA )
	CALL COLSTR(ICLRED,'*** --::-- Space-time wrinkle --::-- ***^E')
	ERASE1 = .TRUE.
	ERASE2 = .TRUE.
	CALL CURSOR( 1, 2 )
	CALL STRING('*** --::-- Relocation to quadrant ^E')
	CALL NUMBER(IQX)
	CALL CHROUT('-')
	CALL NUMBER(IQY)
	CALL STRING(', sector ^E')
	CALL NUMBER( ISX )
	CALL CHROUT('-')
	CALL NUMBER( ISY )
	CALL STRING('. --::-- ***^E')
	ERASE3 = .TRUE.
	DEGREE = IRAN( 360 )
	BEARIN = IRAN( 360 )
	SPEED = IRAN( 80 ) / 10.0
	ASPEED = IRAN( 80 ) / 10.0
C
C *******************************************************************
C
C  --	GAME HAS ALREADY BEGUN, ALL PARAMETERS SET UP
C
C  --	CHECK FOR SPEED CHANGES AND GET USER'S COMMAND
C
70	CALL USRSET("2030,TTYSPD)
	CALL USRSET("2031,TTYSPD)
	ILMAX = IGTAB( "50, "11 )
	ILNUM = IGTAB( "54, "11 )
	CALL PPN( IP, IPN )
	IF( ILNUM*100/ILMAX .LE. 86 .OR. IPN .EQ. "17433 ) GOTO 71
	CALL CLRSCR
	CALL CURSOR( 20, 1 )
	CALL COLSTR(ICLRED,'^I^I^I***** EMERGENCY *****^M^J^J^E')
	CALL COLSTR(ICLWHI,'
     &A large dotted white line appears in front of your ship^M^J^J
     &labeled "S T Y X L I N E".  As your ship passes over it^M^J^J
     &you exit to the monitor.^M^J^J^E')
	CALL CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
C
71	IF( DAMAGE(1,1) .GT. 0 ) ASPEED = SPEED
	IF( DAMAGE(1,1) .LE. 0 .AND. INERGY+ISHELD+DENRGY .LT. 100 )
     &		INERGY = INERGY + 1
	CALL CURBUF
	CALL COMAND( ICHAR, COMARA, INDEX )
C
C  --	CLEAN UP ERASE1, ERASE2, AND ERASE3 FLAGS
C
75	IF( ICHAR .EQ. -1 ) GOTO 440

	IF( .NOT. ERASE2 ) GOTO 80
	CALL COLCUR( 26, 12 )
	CALL REPEAT(' ',35)
	ERASE2 = .FALSE.
C
80	IF( .NOT. ERASE1 ) GOTO 90
	CALL COLCUR( 26, 24 )
	CALL REPEAT(' ',54)
	ERASE1 = .FALSE.
C
90	IF( .NOT. ERASE3 ) GOTO 100
	CALL COLCUR( 1, 2 )
	CALL REPEAT(' ',79)
	ERASE3 = .FALSE.
C
C  --	GET NUMBERS OUT OF STRING
C
100	CALL GETNUM( COMARA, INDEX, I1, 10, I2, 10, J, 10 )
	DECIML = I1
	IDOT = ISERCH( COMARA, '.', INDEX )
	IF( IDOT .GE. 0 ) DECIML = I1 + I2/10.0	! Just so we can say warp 0.x
105	IF( I2 .LT. 0 ) I2 = 0
C
C  --	WARP CONTROL
C
	IF( ICHAR .NE. 'W' ) GOTO 120
	IF( DAMAGE(1,1) .NE. 0 ) GOTO 110
	IF( DECIML .LT. 0 ) DECIML = 0.0
	ASPEED = DECIML
	GOTO 440
C
110	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Warp drive inoperative.            ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
C  --	DEGREE CONTROL
C
120	IF( ICHAR .NE. 'D' ) GOTO 140
	IF( INERGY .LT. 8 ) GOTO 440
	BEARIN = RBOUND( DECIML )
	INERGY = INERGY - 4
	GOTO 440
C
C  --	IMPULSE ENGINES CONTROL
C
140	IF( ICHAR .NE. 'I' ) GOTO 145
	IF( INERGY .LT. 1 .OR. INERGY+ISHELD .LT. 2 ) GOTO 143
	INERGY = INERGY - 1
	IF( SPEED .EQ. 0.1 ) GOTO 142
	IF( ABS(SPEED-0.1) .GT. 0.1 )GOTO 143
	SPEED = 0.1
	ASPEED = 0.1
	GOTO 440
C
142	SPEED = 0.0
	ASPEED = 0.0
	GOTO 440
C
143	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Impulse engines not effective.     ^E')
	ERASE2 = .TRUE.
	GOTO 440
	IF( SPEED .EQ. 0.1 ) GOTO 142
C
C  --	HYPERSPACE CONTROL
C
145	IF( ICHAR .NE. 'J' ) GOTO 160
	IF( SPEED .LT. 1.0 ) GOTO 150
	HYPER = (.NOT. HYPER )
	GOTO 440
C
150	CALL CURSOR( 1, 2 )
	CALL STRING(ICLYEL,
     & 'Warp factor less than 1.0.  Cannot make hyperspace jump.^E')
	ERASE3 = .TRUE.
	GOTO 440
C
C  --	PRINT OUT NEW SCREEN
C
160	IF( ICHAR .NE. 'N' ) GOTO 170
	CALL PRINT
	CALL CURSOR( 13, 18 )
	CALL PBACK( ICLDBL )
	CALL PCOLOR( ICLWHI )
	CALL CHROUT( IPLAYR+64 )
	GOTO 440
C
C  --	PRINT OUT "WHO"
C
170	IF( ICHAR .NE. 'F' ) GOTO 175
	I = ICON( COMARA(2) ) - 64
	IF( I .LT. 1 .OR. I .GT. 26 ) GOTO 174
	CALL GETVAL( 4, I, 1, J )
	IF( J .EQ. 0 ) GOTO 174
	CALL COLCUR( 1, 2 )
	IF( I .NE. 1 ) GOTO 171
	CALL STRING('Computer controlled ship Axis^E')
	ERASE3 = .TRUE.
	GOTO 440
171	CALL SYSWHO(J)
	ERASE3 = .TRUE.
	GOTO 440
C
174	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'No such ship.                      ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
C  --	RADIO CONTROL
C
175	IF( ICHAR .NE. 'R' ) GOTO 220
	CALL GETVAL( 3, 3, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 180
	CALL NAP( 1000, 4 )
	CALL UNLOCK
180	J = ICON( COMARA(2) ) - 64
	IF( J .LT. 1 .OR. J .GT. 26 ) GOTO 220
	CALL GETVAL( 4, J, 1, IVAL )
	IF( IVAL .NE. 0 ) GOTO 200
	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'No frequency found for that ship.  ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
200	CALL LOCK
	CALL PUTVAL( 3, 3, J )
	CALL PUTVAL( 5, 1, INDEX )
	DO 210 I1= 2, INDEX
	    I = I1
	    CALL PUTVAL( 5, I, ICON(COMARA(I)) )
210	CONTINUE
	CALL PUTVAL( 5, 2, IPLAYR )
	CALL UNLOCK
	GOTO 440
C
C  --	GAG TERMINAL
C
220	IF( ICHAR .NE. 'G' ) GOTO 225
	CALL USRSET("2013,"0)
	GOTO 440
C
C  --	UNSET GAG
C
225	IF( ICHAR .NE. 'U' ) GOTO 227
	CALL USRSET("2013,"1)
	GOTO 440
C
C  --	SET UP DOCKING BANKS
C
227	IF( ICHAR .NE. 'B' ) GOTO 229
	I1 = IABS( I1 )
	I2 = IABS( I2 )
	J = IABS( J )
	IF(I1.GT.INERGY.OR.I2.GT.ITORP.OR.J.GT.DAMAGE(1,2)) GOTO 228
	DENRGY = DENRGY + I1
	INERGY = INERGY - I1
	DTORP = DTORP + I2
	ITORP = ITORP - I2
	DCREW = DCREW + J
	DAMAGE( 1, 2 ) = DAMAGE( 1, 2 ) - J
	GOTO 440
C
228	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Not enough supplies for docking    ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
C  --	ZERO DOCKING BANKS
C
229	IF( ICHAR .NE. 'Z' ) GOTO 230
	INERGY = INERGY + DENRGY
	IF( INERGY+ISHELD .GT. 100 ) INERGY = 100-ISHELD
	DENRGY = 0
	ITORP = ITORP + DTORP
	DTORP = 0
	DAMAGE( 1, 2 ) = DAMAGE( 1, 2 ) + DCREW
	DCREW = 0
	GOTO 440
C
C  --	EXIT
C
230	IF( COMARA(1) .NE. 'E' .OR. COMARA(2) .NE. 'X' ) GOTO 240
	CALL CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
C
C  --	TORPEDO CONTROL
C
240	IF( ICHAR .NE. 'T' ) GOTO 300
	IF( DAMAGE(4,1) .NE. 0 )GOTO 280
	IF( COMARA(2) .NE. 'A' ) GOTO 245
	IF( ARMED ) GOTO 287
	IF( ITORP .EQ. 0 ) GOTO 290
	IF( INERGY .LE. 10 ) GOTO 282
	INERGY = INERGY - 10
	ITORP = ITORP - 1
	ARMED = .TRUE.
	GOTO 440

245	IF( .NOT. ARMED ) GOTO 285
	ARMED = .FALSE.
	IF( HYPER ) GOTO 270
	DO 250 I= 1, 25
	    IF( TORPX(I) .EQ. 0.0 ) GOTO 260
250	CONTINUE
C
	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'** Too many torpedos are active ** ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
260	TORPX(I) = SX
	TORPY(I) = SY
	ITX(I) = IQX
	ITY(I) = IQY
	TORPXS(I) = UNITX*SPEED + SMCOS( DECIML )/2.
	TORPYS(I) = UNITY*SPEED + SMSIN( DECIML )/2.
	ITDIST(I) = 0
	GOTO 440
C
270	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Cannot use torpedos in hyperspace. ^E') 
	ERASE2 = .TRUE.
	GOTO 440
C
280	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Photon torpedos inoperative.       ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
282	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Not enough energy to arm torpedo.  ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
285	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Torpedo is not armed.              ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
287	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Torpedo is already armed.          ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
290	CALL COLSTR( 26, 12 )
	CALL COLSTR(ICLYEL,'All photon torpedos are expended.  ^E')
C
C	This will never work anyplace other than Tops10.
	CALL EXECUT( "051440000000 )
C
	ERASE2 = .TRUE.
	GOTO 440
C
C  --	PHASER CONTROL
C
300	IF( ICHAR .NE. 'P' ) GOTO 400
	IF( DAMAGE(5,1) .NE. 0 ) GOTO 380
	I1 = IABS( I1 )
	IF( I1 .GT. INERGY ) GOTO 390
	IF( HYPER ) GOTO 360
	I = ICON( COMARA(2) ) - 64
	IF( I .LT. 1 .OR. I .GT. 26 ) GOTO 370
	CALL GETVAL( 4, I, 1, IVAL )
	IF( IVAL .EQ. 0 .OR. I .EQ. IPLAYR ) GOTO 395
	CALL GETVAL( 4, I, 9, IX1 )
	CALL GETVAL( 4, I, 10, IY1 )
	CALL GETVAL( 4, I, 11, IX2 )
	CALL GETVAL( 4, I, 12, IY2 )
	CALL GETVAL( 1, IX1, IY1, IX2, IY2, IVAL )
	IF( IVAL .NE. I+64 ) GOTO 395
	IF( IX1-IQX .GT. 5 ) IX1 = IX1 - 10
	IF( IQX-IX1 .GT. 5 ) IX1 = IX1 + 10
	IF( IY1-IQY .GT. 5 ) IY1 = IY1 - 10
	IF( IQY-IY1 .GT. 5 ) IY1 = IY1 + 10
	DIST = SQRT(FLOAT((IQX*10+ISX-IX1*10-IX2)^2 +
     & (IQY*10+ISY-IY1*10-IY2)^2))
	IF( DIST .GT. 7.0 ) GOTO 395
	INERGY = INERGY - I1
C	IVAL = I1 / (DIST^0.25)
	IVAL = I1 / SQRT(SQRT(DIST))
	CALL COLCUR( 26, 12 )
	CALL NUMBER( IVAL, 3 )
	CALL STRING('% hit on the ^E')
	CALL GETVAL( 4, I, 2, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	CALL GETVAL( 4, I, 3, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	CALL STRING('       ^E')
	CALL PUTVAL( 4, I, 4, IVAL )
	CALL PUTVAL( 4, I, 17, IPLAYR )
	ERASE2 = .TRUE.
	GOTO 440
C
360	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Cannot use phasers in hyperspace.  ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
370	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'No such ship.                      ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
380	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Phasers inoperative.               ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
390	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Not enough energy.                 ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
395	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Cannot lock phasers on target      ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
C  --	MOVE MEN
C
400	IF( ICHAR .NE. 'M' ) GOTO 405
	IF( I2 .LT. 1 .OR. I2 .GT. 7 ) GOTO 403
	IF( J .LT. 1 .OR. J .GT. 7 ) GOTO 403
	I1 = IABS( I1 )
	IF( I1 .GT. DAMAGE( I2, 2 ) ) GOTO 404
	DAMAGE( I2, 2 ) = DAMAGE( I2, 2 ) - I1
	DAMAGE( J, 2 ) = DAMAGE( J, 2 ) + I1
	GOTO 440
403	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Non existant device                ^E')
	ERASE2 = .TRUE.
	GOTO 440
404	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'Not enough men at that device      ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
C***	SHIELD CONTROL
C
405	IF( ICHAR .NE. 'S' ) GOTO 430
	IF( DAMAGE(6,1) .NE. 0 ) GOTO 410
	IF((I1.GT.0.AND.INERGY.LT.I1).OR.(I1.LT.0.AND.ISHELD.LT.-I1))
     & GOTO 420
	INERGY = INERGY - I1
	ISHELD = ISHELD + I1
	GOTO 440
C
410	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Shields inoperative.               ^E')
	ERASE2 = .TRUE.
	GOTO 440
C
420	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLRED,'Insufficient energy.               ^E')
	ERASE2 = .TRUE.
	IF( I1 .LT. 0 ) GOTO 425
	ISHELD = ISHELD + INERGY
	INERGY = 0
	GOTO 440
425	INERGY = INERGY + ISHELD
	ISHELD = 0
	GOTO 440
C
430	CALL CURSOR( 26, 12 )
	CALL COLSTR(ICLYEL,'*** Illegal command: ^E')
	CALL CHROUT( ICHAR )
	CALL STRING(' ***         ^E')
	ERASE2 = .TRUE.
C
C ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C
C	DISCOVER IF WE HIT ANY SPACESHIPS FLOATING BY
C
440	CONTINUE
	IF( INERGY .NE. 0 .OR. ISHELD .NE. 0 ) GOTO 450
	CALL COLCUR( 1, 2 )
	CALL STRING
     &('Out of energy!!  You lost.                      
     &                             ^E')
	CALL CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
C
450	CALL GETVAL( 4, IPLAYR, 7, OTHSPD )
	IF( OTHSPD .EQ. 0 ) GOTO 460
	CALL PUTVAL( -4, 0 )
	CALL COLCUR( 26, 12 )
	ERASE2 = .TRUE.
	IF( OTHSPD .LT. 0 ) GOTO 455
	OTHSPD = OTHSPD + SPEED
	IF( OTHSPD .GT. 0.2 )
     &	    CALL COLSTR(ICLRED,'* Collision with the ^E')
	IF( OTHSPD .LE. 0.2 )
     &	    CALL COLSTR(ICLLBL,'* Docking with the ^E')
	CALL GETVAL( 4, IPLAYR, 6, J )
	CALL GETVAL( 4, J, 2, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	CALL GETVAL( 4, J, 3, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	IF( OTHSPD .GT. 0.2 ) CALL STRING(' *^E')
	IF( OTHSPD .LE. 0.2 ) CALL STRING(' *  ^E')
	SPEED = 0
	IF( OTHSPD .GT. 0.2 ) FAULT = J
	IF( OTHSPD .GT. 0.2 ) GOTO 456
	CALL PUTVAL( 4, J, 13, DENRGY )
	DENRGY = 0
	CALL PUTVAL( 4, J, 14, DTORP )
	DTORP = 0
	CALL PUTVAL( 4, J, 15, DCREW )
	DCREW = 0
	INERGY = INERGY + ISHELD
	ISHELD = 0
	GOTO 460
C
455	CALL COLSTR(ICLRED,'**** Explosive force ion storm ****^E')
	FAULT = 0
456	CALL DAMAGM( DAMAGE, IABS( IFIX( OTHSPD*30.2 ) ), ISHELD )
	DENRGY = 0
	DTORP = 0
	DCREW = 0
C
C  --	UPDATE DOCKING INFORMATION
C
460	CALL GETVAL( 4, IPLAYR, 13, I1 )
	CALL PUTVAL( -4, 0 )
	CALL GETVAL( 4, IPLAYR, 14, I2 )
	CALL PUTVAL( -4, 0 )
	CALL GETVAL( 4, IPLAYR, 15, J )
	CALL PUTVAL( -4, 0 )
	IF( I1 + I2 + J .EQ. 0 ) GOTO 466
	ISHELD = 0
	DENRGY = 0
	DTORP = 0
	DCREW = 0
	CALL CURSOR( 1, 2 )
	CALL COLSTR(ICLLBL,'Taking ^E')
	INERGY = INERGY + I1
	IF( INERGY .GT. NNERGY ) INERGY = NNERGY
	CALL NUMBER( I1 )
	CALL STRING('% energy, ^E')
	ITORP = ITORP + I2
	IF( ITORP .GT. NTORP ) ITORP = NTORP
	CALL NUMBER( I2 )
	CALL STRING(' torpedos and ^E')
	IF( ICREW+J .GT. NCREW ) J = NCREW-ICREW
	DAMAGE( 1, 2 ) = DAMAGE( 1, 2 ) + J
	CALL NUMBER( J )
	CALL STRING(' crew members on board.^E')
	ERASE3 = .TRUE.
C
C  --	UPDATE SHIP SPEED AND INC
C
466	IF( HYPER .AND. INERGY .LT. 4 ) HYPER = .FALSE.
	IF( HYPER ) INERGY = INERGY - 4
	IF( SPEED .LT. ASPEED ) SINC = SPDI
	IF( SPEED .GT. ASPEED ) SINC = -SPDI
	IF( INERGY .LT. 9 ) SINC = 0
	IF( SINC .NE. 0 ) INERGY = INERGY - 2
	IF( ABS(SPEED-ASPEED) .LT. SPDI ) SPEED = ASPEED
	IF( SPEED .EQ. ASPEED ) SINC = 0.0
	SPEED = SPEED + SINC
	IF( SPEED .LT. 1.0 ) HYPER = .FALSE.
C
C  --	UPDATE SHIP DEGREE AND INC
C
	DINC=-DEGI
	IF ( (BEARIN-DEGREE.GT.0 .AND. BEARIN-DEGREE.LT.180) .OR.
     &(BEARIN-DEGREE.GT.-360 .AND. BEARIN-DEGREE.LT.-180) ) DINC = DEGI
	DEGREE = RBOUND( DEGREE + DINC )
	IF( ABS( BEARIN-DEGREE ) .LT. DEGI*1.1 .OR.
     & ABS( BEARIN-DEGREE+360) .LT. DEGI*1.1 ) DEGREE = BEARIN
C
C  --	GET UNITS
C
	UNITX = SMCOS( DEGREE ) / 2.
	UNITY = SMSIN( DEGREE ) / 2.
	IOQX = IQX
	IOQY = IQY
	IOSX = ISX
	IOSY = ISY
	OSX = SX
	OSY = SY
	PDIST = 0.0
	DIST = SPEED
C
C  --	LOOP THROUGH SHIP'S JOURNEY TO SEE IF IT HITS ANYTHING
C
	CALL GETVAL( 4, IPLAYR, 1, IVAL )
	IF( IVAL .EQ. 0 ) CALL EXPROG
	CALL LOCK
C
C	FIXED LOGIC TO RUN ON MODERN COMPILERS
	STRTLP = DIST
	IF( INT(SPEED) .GT. 0 ) STRTLP = 1.0
	DO 480 DIST = STRTLP, SPEED
470	    IQX = IOQX
	    IQY = IOQY
	    SX = SQWRAP( IQX, ISX, OSX + DIST*UNITX )
	    SY = SQWRAP( IQY, ISY, OSY + DIST*UNITY )
	    IF( HYPER ) GOTO 480
	    CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
	    IF( IVAL .EQ. 0 .OR. IVAL .EQ. IPLAYR+64 .OR.
     & IVAL .EQ. -IPLAYR) GOTO 480
	    IF( IVAL .NE. 4 ) GOTO 490
	    FAULT = 0
	    CALL DAMAGM( DAMAGE, 5, ISHELD )
	    IF( ERASE2 ) GOTO 480
	    CALL COLCUR( 26, 12 )
	    CALL COLSTR(ICLRED,':: Undergoing ionic bombardment :: ^E')
	    ERASE2 = .TRUE.
480	PDIST = DIST
	GOTO 560
C
C  --	SHIP JUST HIT SOMETHING
C
490	CALL COLCUR( 26, 12 )
	IF( IVAL .GT. 5 ) GOTO 530
	IF( SPEED .GT. 0.1 .OR. IVAL .NE. 2 ) GOTO 510
	CALL COLSTR(ICLLBL,'* Docking with starbase *          ^E')
	ITORP = NTORP
	DO 491 I = 1, 7
	    DAMAGE(I,2) = CRWNUM
491	CONTINUE
	ARMED = .FALSE.
	DEGREE = RBOUND( DEGREE+180. )
	BEARIN = DEGREE
	INERGY = INERGY + ISHELD
	ISHELD = 0
	DENRGY = 0
	DTORP = 0
	DCREW = 0
	PDIST = -0.9
	DO 500 I=1,7
	    DAMAGE(I,1) = 0
500	CONTINUE
	GOTO 550
C
510	CALL COLSTR(ICLRED,'Collision with ^E')
	INDEX = 0
	IF( IVAL .LT. 0 ) GOTO 520
	IF( IVAL .EQ. 1 ) CALL STRING('a star.             ^E')
	IF( IVAL .EQ. 2 ) CALL STRING('a starbase.         ^E')
	IF( IVAL .EQ. 3 ) CALL STRING('a black hole.       ^E')
	IF( IVAL .EQ. 3 ) SPEED = IRAN( 80 ) / 10.0
	FAULT = 0
	GOTO 540
520	CALL STRING('a photon torpedo.   ^E')
	ERASE2 = .TRUE.
	FAULT = -IVAL
	CALL DAMAGM( DAMAGE, 20, ISHELD )
	GOTO 480
C
530	IVAL1 = IVAL - 64
	CALL GETVAL( 4, IVAL1, 5, OTHSPD )
	OTHSPD = OTHSPD + SPEED
	IF( OTHSPD .GT. 0.2 )
     &	    CALL COLSTR(ICLRED,'* Collision with the ^E')
	IF( OTHSPD .LE. 0.2 )
     &	    CALL COLSTR(ICLLBL,'* Docking with the ^E')
	CALL GETVAL( 4, IVAL1, 2, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	CALL GETVAL( 4, IVAL1, 3, ISHIP )
	CALL STRING( ISHIP, 6, 6 )
	CALL PUTVAL( 4, IVAL1, 6, IPLAYR )
	CALL PUTVAL( 4, IVAL1, 7, SPEED )
	IF( OTHSPD .GT. 0.3 ) GOTO 539
	CALL STRING(' *  ^E')
	CALL PUTVAL( 4, IVAL1, 13, DENRGY )
	CALL PUTVAL( 4, IVAL1, 14, DTORP )
	CALL PUTVAL( 4, IVAL1, 15, DCREW )
	INERGY = INERGY + ISHELD
	ISHELD = 0
	PDIST = -0.9
	DENRGY = 0
	DTORP = 0
	DCREW = 0
	GOTO 550
539	CALL STRING(' *^E')
	FAULT = IVAL1
	SPEED = OTHSPD
540	IF( OHYPER ) IVAL = 3
	DEGREE = IRAN(360)
	CALL DAMAGM( DAMAGE, IFIX(SPEED*30.2), ISHELD )
C
C  --	IF HE HIT A BLACK HOLE, DISORIENT HIM.
C
	IF( IVAL .NE. 3 ) GOTO 550
	CALL GETVAL( 1, IOQX, IOQY, IOSX, IOSY, IVAL )
	IF( IVAL .EQ. IPLAYR+64 ) CALL PUTVAL( -1, 0 )
	CALL ADDVAL( 2, IOQX, IOQY, -1000 )
	GOTO 60
C
C  --	UPDATE CRASH POSITION
C
550	ERASE2 = .TRUE.
	IQX = IOQX
	IQY = IOQY
	SX = SQWRAP( IQX, ISX, OSX + PDIST*UNITX )
	SY = SQWRAP( IQY, ISY, OSY + PDIST*UNITY )
	ASPEED = 0.
	SPEED = 0.
C
C  --	PUT NEW POSITION IN HISEGMENT
C
560	CALL GETVAL( 1, IOQX, IOQY, IOSX, IOSY, IVAL )
	IF( IVAL .EQ. IPLAYR+64 ) CALL PUTVAL( -1, 0 )
	IF( .NOT. HYPER )
     &CALL PUTVAL( 1, IQX, IQY, ISX, ISY, IPLAYR+64 )
C
C  --	UPDATE SHIP'S ROSTER
C
	CALL UPSHIP( IPLAYR, ICHAR )
	CALL UNLOCK
	CALL ADDVAL( 2, IOQX, IOQY, -1000 )
	CALL ADDVAL( 2, IQX, IQY, 1000 )
	CALL PUTVAL( 4, IPLAYR, 9, IQX )
	CALL PUTVAL( 4, IPLAYR, 10, IQY )
	CALL PUTVAL( 4, IPLAYR, 11, ISX )
	CALL PUTVAL( 4, IPLAYR, 12, ISY )
C
C  --	UPDATE HYPERSPACE FLAG
C
	IF( HYPER .EQ. OHYPER .AND. ICHAR .NE. 'N' ) GOTO 570
	CALL CURSOR( 52, 14 )
	IF( HYPER ) CALL COLSTR(ICLLBL,'::: HYPERSPACE :::^E')
	IF( .NOT. HYPER ) CALL COLSTR (ICLLBL,'                   ^E')
	OHYPER = HYPER
C
C  --	UPDATE DATE
C
570	CALL GETVAL( 3, 2, IDAT )
	IF( IDAT .EQ. IODAT )GOTO 580
	IODAT = IDAT
	CALL COLCUR( 37, 23 )
	CALL NUMBER( IDAT/100.0, 8, 10, 2 )
C
C  --	UPDATE ENERGY
C
580	IF( INERGY .EQ. IONGRY .AND. ICHAR .NE. 'N' ) GOTO 590
	IONGRY = INERGY
	CALL COLCUR( 34, 22 )
	CALL NUMBER( INERGY, 3 )
C
C  --	UPDATE LONG AND SHORT RANGE SENSORS AND QS COORDINATES
C
590	CALL UPDSCR
     &( IQX, IQY, ISX, ISY, ICHAR, DAMAGE, IPLAYR, HYPER )
C
C  --	UPDATE TORPEDOS
C
	IF(ITORP.EQ.IOTORP .AND. ARMED.EQ.OARMED .AND. ICHAR.NE.'N')
     & GOTO 600
	IOTORP = ITORP
	OARMED = ARMED
	CALL COLCUR( 37, 19 )
	CALL NUMBER( ITORP, 2 )
	IF( ARMED ) CALL STRING(' + A^E')
	IF( .NOT. ARMED ) CALL STRING('    ^E')
C
C  --	UPDATE SHIELD
C
600	IF( ISHELD .EQ. ISHOLD .AND. ICHAR .NE. 'N' ) GOTO 610
	ISHOLD = ISHELD
	CALL COLCUR( 35, 18 )
	CALL NUMBER( ISHELD, 3 )
C
C  --	UPDATE DEGREE
C
610	CALL PUTVAL( 4, IPLAYR, 8, DEGREE )
	IF( INT( DEGREE*100. ) .EQ. INT( ODEGRE*100. ) .AND.
     & ICHAR .NE. 'N' ) GOTO 620
	ODEGRE = DEGREE
	CALL COLCUR( 36, 17 )
	CALL NUMBER( IFIX(DEGREE), 3 )
C
C  --	UPDATE BEARING
C
620	IF( INT( BEARIN*100. ) .EQ. INT( OBEARN*100. ) .AND.
     & ICHAR .NE. 'N' ) GOTO 630
	OBEARN = BEARIN
	CALL COLCUR( 36, 16 )
	CALL NUMBER( IFIX(BEARIN), 3 )
C
C  --	UPDATE SPEED
C
630	CALL PUTVAL( 4, IPLAYR, 5, SPEED )
	IF( INT( SPEED*100. ) .EQ. INT( OSPEED*100. ) .AND.
     & ICHAR .NE. 'N' ) GOTO 640
	OSPEED = SPEED
	CALL COLCUR( 32, 15 )
	CALL NUMBER( SPEED, 4, 10, 1 )
C
C  --	UPDATE NEW SPEED
C
640	IF( ASPEED .GT. 8.0 ) ASPEED = 8.0
	IF( SPEED .GT. 8.0 ) SPEED = 8.0
	IF( INT( ASPEED*100. ) .EQ. INT( OPEED*100. ) .AND.
     & ICHAR .NE. 'N' ) GOTO 641
	OPEED = ASPEED
	CALL COLCUR( 35, 14 )
	CALL NUMBER( OPEED, 4, 10, 1 )
C
C  --	UPDATE DOCKING BANKS
C
641	IF
     &(ODN.EQ.DENRGY.AND.ODT.EQ.DTORP.AND.ODC.EQ.DCREW.AND.
     &ICHAR.NE.'N') GOTO 650
	CALL COLCUR( 34, 13 )
	CALL NUMBER( DENRGY, 5 )
	ODN = DENRGY
	CALL CHROUT(' ')
	CALL NUMBER( DTORP, 2 )
	ODT = DTORP
	CALL CHROUT(' ')
	CALL NUMBER( DCREW, 3 )
	ODC = DCREW
C
C  --	UPDATE DAMAGE REPORT
C
650	ICREW = 0
	DO 680 I=1,7
	    IF( DAMAGE(7,1) .GT. 0 ) DAMAGE(I,2)=MAX0(0,DAMAGE(I,2)-1)
	    IF( DAMAGE(I,1) .GT. 0 )DAMAGE(I,1)=DAMAGE(I,1)-DAMAGE(I,2)
	    IF( DAMAGE(I,1) .LT. 0 ) DAMAGE(I,1) = 0
	    IF( DAMAGE(I,2) .EQ. 0 ) I1 = -1
	    IF( DAMAGE(I,2) .NE. 0 ) I1 = DAMAGE(I,1)/DAMAGE(I,2)
	    ICREW = ICREW + DAMAGE(I,2)
	    IF( I1 .EQ. DAM1(I,1) .AND. ICHAR .NE. 'N' ) GOTO 670
	    DAM1(I,1) = I1
	    CALL COLCUR( 18, 10-I )
	    IF( I1 .NE. 0 ) GOTO 660
	    IF( I .NE. 7 ) CALL COLSTR(ICLGRE,' Operational^E')
	    IF( I .EQ. 7 ) CALL COLSTR(ICLGRE,'Green:   ^E')
	    GOTO 670
C
660	    IF( I .EQ. 7 ) GOTO 665
	    IF( I1 .LT. 0 ) CALL COLSTR(ICLPUR,' * No crew *^E')
	    IF( DAMAGE(I,1) .EQ. 0 .AND. I1 .LT. 0 ) DAMAGE(I,1)=1
	    IF( I1 .LT. 0 ) GOTO 670
	    CALL PCOLOR(ICLYEL)
	    CALL NUMBER( I1, 4 )
	    CALL STRING(' minutes^E')
	    GOTO 670
C
665	    IF( I1 .LT. 100 .OR. DAMAGE(7,2) .EQ. 0 )
     &		CALL COLSTR(ICLYEL,'Yellow:  ^E')
	    IF(I1.GE.100.AND.I1.LT.200.AND.DAMAGE(7,2).NE.0)
     &		CALL COLSTR(ICLRED,'Red:     ^E')
	    IF( I1 .GE. 200 .AND. DAMAGE(7,2) .NE. 0 )
     &		CALL COLSTR(ICLRED,'Critical:^E')
C
670	    IF(I.NE.7.OR.(ICHAR.NE.'N'.AND.ICREW.EQ.OCREW)) GOTO 675
	    CALL COLCUR( 28, 10-I )
	    CALL NUMBER( ICREW, 3 )
	    OCREW = ICREW
675	    IF( DAMAGE(I,2) .EQ. DAM1(I,2) .AND. ICHAR .NE. 'N' )
     &	    GOTO 680
	    CALL COLCUR( 36, 10-I )
	    CALL NUMBER( DAMAGE(I,2), 5 )
	    DAM1(I,2)=DAMAGE(I,2)
680	CONTINUE
	IF( ICREW .GT. 0 ) GOTO 681
	CALL COLCUR( 1, 2 )
	CALL COLSTR(ICLRED,'The entire crew has been killed.^E')
	CALL CEASE( IPLAYR, IQX, IQY, ISX, ISY, FAULT )
C
C  --	REMOVE A FEW IONS FROM THE GALAXY
C
681	DO 682 I = 1, 10
	    IX = IRAN( 10 )
	    IY = IRAN( 10 )
	    CALL GETVAL( 2, IX, IY, IVAL1 )
	    CALL GETVAL( 1, IX, IY, IRAN(10), IRAN(10), IVAL )
	    IF( IVAL .EQ. 4 .AND. IVAL1 .LE. 99 ) CALL PUTVAL( -1, 0 )
682	CONTINUE
C
C  --	UPDATE ANY TORPEDOS UNDER SHIPS CONTROL
C
	CALL LOCK
	DO 750 I= 1,25
	    IF( TORPX(I) .EQ. 0.0 ) GOTO 750
	    CALL GETVAL
     &( 1, ITX(I), ITY(I), INT(TORPX(I)+0.5),
     &INT(TORPY(I)+0.5), IVAL)
	    IF( IVAL .EQ. -IPLAYR ) CALL PUTVAL( -1, 0 )
	    ITDIST(I) = ITDIST(I) + 1
	    IF( ( IVAL .GT. 0 .AND. IVAL .NE. IPLAYR+64 ) .OR.
     &	    ITDIST(I) .GT. 40 ) GOTO 740
	    TORPX(I) = SQWRAP( ITX(I), IX1, TORPXS(I)+TORPX(I) )
	    TORPY(I) = SQWRAP( ITY(I), IY1, TORPYS(I)+TORPY(I) )
	    CALL GETVAL( 1, ITX(I), ITY(I), IX1, IY1, IVAL )
C
	    IF( IVAL .GT. 0 .AND. IVAL .NE. -IPLAYR .AND. IVAL .NE. 4 )
     & GOTO 690
	    CALL PUTVAL( -1, -IPLAYR )
	    GOTO 750
C
690	IF( IVAL .EQ. -IPLAYR .OR. IVAL .EQ. IPLAYR+64 ) GOTO 750
	    IF( IVAL .EQ. 3 .OR. IVAL .EQ. 4 .OR. IVAL .LT. 0 )
     &	    GOTO 740
C
	    IF( IVAL .NE. 1 .AND. IVAL .NE. 2 ) GOTO 730
	    IF( IRAN(10) .GT.3 ) GOTO 740
	    CALL PUTVAL( -1, 0 )
	    CALL NOVA( ITX(I), ITY(I), IX1, IY1 )
	    IF( IVAL .EQ. 1 ) CALL ADDVAL( 2, ITX(I), ITY(I), -1 )
	    IF( IVAL .EQ. 2 ) CALL ADDVAL( 2, ITX(I), ITY(I), -10 )
	    IF( IVAL .EQ. 1 ) GOTO 740
725	    ISTX = IRAN(10)
	    ISTY = IRAN(10)
	    CALL GETVAL( 2, ISTX, ISTY, IVAL1 )
	    IF( IVAL1 .GT. 9 ) GOTO 725
	    CALL ADDVAL( -2, 10 )
726	    ISTX1 = IRAN(10)
	    ISTY1 = IRAN(10)
	    CALL GETVAL( 1, ISTX, ISTY, ISTX1, ISTY1, IVAL1 )
	    IF( IVAL1 .NE. 0 ) GOTO 726
	    CALL ADDVAL( -1, 2 )
	    GOTO 740
C
730	    CALL PUTVAL( 4, IVAL-64, 4, -20 )
	    CALL PUTVAL( 4, IVAL-64, 17, IPLAYR )
C
740	    TORPX(I) = 0.0
C
750	CONTINUE
	CALL UNLOCK
C
C  --	FIND OUT IF HIT BY ENEMY
C
	CALL GETVAL( 4, IPLAYR, 4, I1 )
	CALL PUTVAL( -4, 0 )
	IF( I1 .EQ. 0 ) GOTO 780
	CALL COLCUR( 26, 12 )
	IF( I1 .LT. 0 ) GOTO 760
	CALL COLSTR(ICLRED,'Ship hit with ^E')
	CALL NUMBER( I1, 3 )
	CALL STRING('% phaser bolt.     ^E')
	GOTO 770
C
760	CALL COLSTR(ICLRED,'Ship hit by photon torpedo.        ^E')
C
770	CALL GETVAL( 4, IPLAYR, 17, IVAL )
	FAULT = IVAL
	CALL DAMAGM( DAMAGE, IABS(I1), ISHELD )
	ERASE2 = .TRUE.
C
C  --	GET ANY MESSAGES
C
780	CALL GETVAL( 3, 3, IVAL )
	IF( IVAL .NE. IPLAYR ) GOTO 70
	CALL COLCUR( 1, 2 )
	CALL REPEAT(' ',78)
        CALL CURSOR( 1, 2 )
	CALL GETVAL( 5, 1, INDEX )
	DO 790 I1= 2, INDEX
	    I = I1
	    CALL GETVAL( 5, I, COMMAR(I-1) )
790	CONTINUE
	CALL PUTVAL( 3, 3, 0 )
	CALL CHROUT( COMMAR(1)+64 )
	CALL CHROUT('(')
	CALL GETVAL( 4, COMMAR(1), 9, IVAL )
	CALL NUMBER( IVAL )
	CALL CHROUT(',')
	CALL GETVAL( 4, COMMAR(1), 10, IVAL )
	CALL NUMBER( IVAL )
	CALL STRING('): - ^E')
	IF( INDEX-2 .GT. 0 )CALL STRING( COMMAR(2), 0, INDEX-2 )
	ERASE3 = .TRUE.
	GOTO 70
C
C  --	GAME ENDED FOR SOME REASON (PROBABLY TOO MANY PEOPLE)
C
792	CALL COLSTR(ICLLBL,'I am sorry, too many people are playing.
     &  Try again later.^M^J^E')
	CALL CURBUF
	CALL EXPROG
C
C  --	PRIVILEDGED:  MAKE MAP AND PRINT OUT STATISTICS
C
C  --	IF THERE IS A NOT A GALAXY, SET ONE UP TO MAP.
C  --	IN ANY CASE, GET OUTPUT FILE SPECIFICATION
C
800	CALL CHECK( INIFLG )
	IF(INIFLG) CALL INITDB
803	CALL STRING('^M^JOutput file specification: ^E')
	CALL CURBUF
	CALL GETSTR( COMARA, 60, I )
C
C  --	ATTEMPT TO OPEN FILE
C
	CALL SCAN( 1, I, COMARA, FILESP )
	CALL OFILE( 2, FILESP, 0 )
	IF( ERROR(0) ) GOTO 805
	CALL WFILE( 2, FILESP )
	IF( .NOT. ERROR(0) ) GOTO 808
C
C  --	HE MADE AN ERROR:  TELL HIM WHAT IT LOOKED LIKE AND GO BACK
C
	CALL STRING('Cannot open file for:^M^J    ^E')
	CALL OUTSPC( FILESP )
	GOTO 803

805	CALL STRING('Cannot open device for:^M^J    ^E')
	CALL OUTSPC( FILESP )
	GOTO 803
C
C  --	SELECT CHANNEL, PRINT OUT HEADER AND START MAIN MAP LOOP
C
808	CALL SELECT( 2 )
	CALL STRING('
     &                                                  Stardate: ^E')
	CALL GETVAL( 3, 2, IDAT )
	CALL NUMBER( IDAT/100.0, 8, 10, 2 )
	CALL STRING('^M^J^J^J^E')
	DO 820 I1 = 10, 1, -1
	    IQY = I1
	    CALL STRING('       ^E')
	    DO 809 I2 = 1, 111
		CALL CHROUT('-')
809	    CONTINUE
	    CALL STRING('^M^J       ^E')
	    DO 810 I2 = 1, 10
		IQX = I2
		CALL STRING(':::^E')
		CALL GETVAL( 2, IQX, IQY, IVAL )
		CALL NUMBER( IVAL, 5 )
		CALL STRING(' ::^E')
810	    CONTINUE
	    CALL STRING(':^M^J       ^E')
	    DO 811 I2 = 1, 111
		CALL CHROUT('-')
811	    CONTINUE
	    CALL CRLF
	    DO 820 I2 = 10, 1, -1
		    ISY = I2
		    IF( ISY .EQ. 5 ) CALL NUMBER( IQY, 5 )
		    IF( ISY .NE. 5 ) CALL STRING('     ^E')
		    CALL STRING('  ^E')
		    DO 815 J = 1, 10
			IQX = J
			CALL CHROUT(':')
			DO 815 I = 1, 10
			    ISX = I
			    CALL GETVAL( 1, IQX, IQY, ISX, ISY, IVAL )
			    IF( IVAL .LT. 0 ) IVAL = 5
			    IF( IVAL .LE. 6 ) IVAL = OBJVAL( IVAL+1 )
			    CALL CHROUT( IVAL )
C
815			CONTINUE
	    CALL STRING(':^M^J^E')
820	CONTINUE
	CALL STRING('       ^E')
	DO 821 I = 1, 111
	    CALL CHROUT('-')
821	CONTINUE
	CALL STRING('^M^J^J    ^E')
	DO 825 I1 = 1, 10
	    IQX = I1
	    CALL NUMBER( IQX, 11 )
825	CONTINUE
	CALL STRING('^M^J^J^J^J^E')
C
C  --	MAP DONE, PRINT OUT SHIP STATISTICS
C
	DO 900 I1 = 1, 26
	    I = I1
	    CALL GETVAL( 4, I, 1, J )
	    IF( J .EQ. 0 ) GOTO 900
	    CALL CHROUT( I+64 )
	    CALL STRING(' - ^E')
	    CALL GETVAL( 4, I, 2, IVAL )
	    CALL STRING( IVAL, 6, 6 )
	    CALL GETVAL( 4, I, 3, IVAL )
	    CALL STRING( IVAL, 6, 6 )
	    IF( I .NE. 1 ) GOTO 899
	    CALL STRING('  Computer controlled ship^M^J^E')
	    GOTO 900
899	    CALL STRING('  J^E')
	    CALL NUMBER( J, 3 )
	    CALL STRING('   ^E')
	    SNAME(1) = IGTAB( J, "31 )
	    SNAME(2) = IGTAB( J, "32 )
	    CALL STRING( SNAME, 6, 12 )
	    CALL STRING('  [^E')
	    CALL NUMBER( ILEFT( IGTAB( J, 2 ) ), 5, 8 )
	    CALL CHROUT(',')
	    CALL NUMBER( IRIGHT( IGTAB( J, 2 ) ), 5, 8 )
	    CALL STRING(']  TTY^E')
	    CALL NUMBER( ITTY( J ), 3, 8 )
	    CALL STRING('  at ^E')
	    CALL NODLIN( ITTY( J ), INODE, ILINE )
	    CALL STRING( NODE( INODE ), 6, 6 )
	    CALL CRLF
900	CONTINUE
C
C  --	FINISHED, NOW CLOSE FILES AND EXIT
C
	CALL CLOSE( 1 )
	CALL CLOSE( 2 )
	CALL EXPROG
	END

	SUBROUTINE COLCUR( IX, IY )
	CALL DEFCOL
	CALL CURSOR( IX, IY )
	RETURN
	END


    	SUBROUTINE COLSTR( ICOL, MSGARA )
	INTEGER MSGARA( 16 )
	CALL PCOLOR( ICOL )
	CALL STRING( MSGARA )
	RETURN
	END
