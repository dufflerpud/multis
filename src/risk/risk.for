C	@HDR@	$Id$
C	@HDR@		Copyright 1982-2025 by
C	@HDR@		Christopher Caldwell/Brightsands
C	@HDR@		P.O. Box 401, Bailey Island, ME 04003
C	@HDR@		All Rights Reserved
C	@HDR@
C	@HDR@	This software comprises unpublished confidential information
C	@HDR@	of Brightsands and may not be used, copied or made available
C	@HDR@	to anyone, except in accordance with the license under which
C	@HDR@	it is furnished.
	SUBROUTINE DEFCOL

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLBLA )
	RETURN
	END

	SUBROUTINE FMAIN

	IMPLICIT INTEGER ( A - Z )

	INTEGER FILSPC( 13 )		! WHERE RUN FROM
	INTEGER COMARA( 80 ), ILEN	! INPUT ARRAY FOR DATA FILE
	INTEGER PARARA( 40 ), PLEN	! PARARASED STUFF FOR INITDB
	INTEGER CHREPS( 7 )
	INTEGER LSTCOM( 22 )
	LOGICAL NEW, PRIVD, INIFLG, ERROR, EOF

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	DATA NEW/.TRUE./, STRTNM/10/, LSTPOS/0/, INTRVL/200/
	DATA USEFUL,SCREEN,COORD,DISTO,OWNER,NUMAT,
     &	CONTAN,CONARM,REGFRM,REGTO,AMTMOV,TIMLFT,WHOS
     &	/1,2,3,4,5,6,7,8,9,10,11,12,13/

	IF( ICLWHI .NE. 0 ) GOTO 3
	ICLWHI = 1
	ICLDBL = 2
	ICLRED = 3
	ICLLBL = 4
	ICLPUR = 5
	ICLGRE = 6
	ICLYEL = 7
	ICLBLA = 8

3	CALL SETTTY( COMARA, PAR, ILEN, PRIVD, FILSPC )
	CALL CHECK( INIFLG )
	IF( INIFLG ) GOTO 10000
	CALL DEFADR( 1, IRIGHT(ITBADR(SCREEN)) )

20	CALL GETVAL( USEFUL, 1, MAXREG )
	CALL GETVAL( USEFUL, 2, MAXUSR )
	CALL GETVAL( USEFUL, 7, MAXCON )
	CALL CTRAP
	    CALL CEASE( USEFUL )
	CALL LOCK
	CALL ADDVAL( USEFUL, 3, 1 )
	CALL GETVAL( -1, NUMUSR )
	IF( NUMUSR .GT. MAXUSR ) CALL PSTOP
	IF( NUMUSR .LT. MAXUSR ) GOTO 30
	FILSPC(5) = ISXBIT('EXE')
	CALL OFILE( 2, FILSPC, 0 )
	IF( ERROR(0) ) GOTO 30
	CALL RFILE( 2, FILSPC )
	IF( ERROR(0) ) GOTO 30
	CALL RNFILE( 2, FILSPC )

30	REGNUM = IRAN( 26 )
	CALL GETVAL( COORD, REGNUM, 1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 30
	CALL GETVAL( NUMAT, REGNUM, IVAL )
	IF( IVAL .NE. 0 ) GOTO 30
	CALL PUTVAL( -1, STRTNM )
	CALL PUTVAL( OWNER, REGNUM, NUMUSR )
	CALL UNLOCK

35	CALL NAP( 1000, "4 )
	CALL GETVAL( USEFUL, 3, IVAL )
	IF( IVAL .LT. MAXUSR ) GOTO 35

	CALL GRAFON
	CALL CTRAP
	    CALL CEASE( USEFUL )

100	CALL LOCK
	CALL ADDVAL( USEFUL, 5, 1 )
	CALL GETVAL( -1, IVAL )
	CALL UNLOCK
	IF( IVAL .EQ. 1 ) GOTO 20000

110	IF( NEW ) CALL NEWSCR( 1 )
	IF( .NOT. NEW ) CALL UPDATE( 1 )
	COMPOS = 0
	NUMARM = 0
	CALL GETVAL( USEFUL, 4, MAXCOM )
	DO 140 I = 1, MAXCOM
	    NUMCOM = I
	    IF( COMPOS .GE. 22 ) GOTO 140
	    CALL GETVAL( WHOS, NUMCOM, IVAL )
	    IF( IVAL .NE. NUMUSR ) GOTO 140
	    CALL GETVAL( TIMLFT, NUMCOM, TIMETO )
	    IF( TIMETO .EQ. 0 ) GOTO 140
	    COMPOS = COMPOS + 1
	    ITEST = TIMETO
	    CALL GETVAL( REGFRM, NUMCOM, R1 )
	    ITEST = 4096*ITEST + R1
	    CALL GETVAL( REGTO, NUMCOM, R2 )
	    ITEST = 128*ITEST + R2
	    CALL GETVAL( AMTMOV, NUMCOM, NUMOVE )
	    ITEST = 128*ITEST + NUMOVE
	    NUMARM = NUMARM + NUMOVE
	    IF( LSTCOM(COMPOS) .EQ. ITEST .AND. .NOT. NEW ) GOTO 140
	    LSTCOM(COMPOS) = ITEST
	    CALL COLCUR( 73, 25-COMPOS )
	    IF( TIMETO .EQ. 0 ) CALL REPEAT( ' ', 8 )
	    IF( TIMETO .EQ. 0 ) GOTO 140
	    CALL NUMBER( NUMOVE, 2 )
	    CALL CHROUT( R1+64 )
	    CALL CHROUT( '>' )
	    CALL CHROUT( R2+64 )
	    CALL CHROUT(':')
	    CALL LNUMBR( MOD( TIMETO, 100 ), 2 )
140	CONTINUE
	IF( LSTPOS .LE. COMPOS ) GOTO 151
	DO 150 I = COMPOS+1, LSTPOS
	    CALL COLCUR( 73, 25-I )
	    CALL REPEAT( ' ', 8 )
150	CONTINUE
151	CONTINUE
	NUMRGS = 0
	DO 160 I = 1, MAXREG
	    NUMREG = I
	    CALL GETVAL( OWNER, NUMREG, IVAL )
	    IF( IVAL .NE. NUMUSR ) GOTO 160
	    CALL GETVAL( NUMAT, NUMREG, IVAL )
	    NUMARM = NUMARM + IVAL
	    IF( IVAL .GT. 0 ) NUMRGS = NUMRGS + 1
160	CONTINUE
	IF( NUMARM .NE. 0 .AND. NUMRGS .NE. MAXREG ) GOTO 170
	CALL SETDIS( 0 )
	CALL CLRSCR
	CALL COLCUR( 20, 12 )
	IF( NUMARM .EQ. 0 ) CALL STRING
     &	('Your entire forces have been destroyed.  You have lost^E')
	IF( NUMRGS .EQ. MAXREG ) CALL STRING
     &	('You have taken over the world.  Congratulations^E')
	CALL STRING('.^G^M^J^E')
	CALL CLOSE( 1 )
	CALL GRAFOF
	CALL EXPROG

170	IF(OLDARM.EQ.NUMARM.AND.OLDRGS.EQ.NUMRGS.AND..NOT.NEW) GOTO 180
	OLDARM = NUMARM
	OLDRGS = NUMRGS
	CALL COLCUR( 73, 2 )
	CALL NUMBER( NUMARM, 3 )
	CALL CHROUT( NUMUSR+64 )
	CALL LNUMBR( -NUMRGS, 3 )
180	LSTPOS = COMPOS
	NEW = .FALSE.
	CALL COMAND( ICHAR, COMARA, ILEN )
	IF( ICHAR .EQ. -1 ) GOTO 100

C***	NEW COMMAND

	IF( ICHAR .NE. 'N' ) GOTO 200
	NEW = .TRUE.
	LSTPOS = 0
	GOTO 100

C***	EXIT COMMAND

200	IF( ICHAR .NE. 'E' .OR. COMARA(2) .NE. 'X' ) GOTO 300
	CALL CEASE( USEFUL )

C***	MOVE COMMAND

300	CALL GETNUM( COMARA, ILEN, NUMMEN, 10 )
	I = 1
400	I = I + 1
	IF( I .EQ. ILEN ) GOTO 800
	R1 = ICON( COMARA(I) ) - 64
	IF( R1 .LT. 1 .OR. R1 .GT. 26 ) GOTO 400
450	I = I + 1
	IF( I .GT. ILEN ) GOTO 800
	R2 = ICON( COMARA(I) ) - 64
	IF( R2 .LT. 1 .OR. R2 .GT. 26 ) GOTO 450
	CALL LOCK
	CALL GETVAL( DISTO, R1, R2, TIMETO )
	IF( TIMETO .EQ. 0 ) GOTO 520
	CALL GETVAL( OWNER, R1, IVAL )
	IF( IVAL .NE. NUMUSR ) GOTO 520
	CALL GETVAL( NUMAT, R1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 520
	NUMMEN = MAX0( 1, MIN0( IVAL, NUMMEN, 127 ) )
	CALL ADDVAL( -1, -NUMMEN )
	CALL GETVAL( USEFUL, 4, MAXCOM )
	IF( MAXCOM .EQ. 0 ) GOTO 501
	DO 500 I = 1, MAXCOM
	    NUMCOM = I
	    CALL GETVAL( TIMLFT, NUMCOM, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 510
500	CONTINUE
501	CONTINUE
	NUMCOM = MAXCOM + 1
	CALL PUTVAL( USEFUL, 4, NUMCOM )
510	CALL PUTVAL( REGFRM, NUMCOM, R1 )
	CALL PUTVAL( REGTO, NUMCOM, R2 )
	CALL PUTVAL( AMTMOV, NUMCOM, NUMMEN )
	CALL PUTVAL( TIMLFT, NUMCOM, IFIX(SQRT(FLOAT(NUMMEN))*TIMETO) )
	CALL PUTVAL( WHOS, NUMCOM, NUMUSR )
520	CALL UNLOCK
	GOTO 100

800	GOTO 100
10000	CALL ENABLE
	FILSPC(5) = ISXBIT('DAT')
	CALL OFILE( 2, FILSPC, 0 )
	IF( ERROR(0) ) CALL BUG('Cannot open device.^E')
	CALL RFILE( 2, FILSPC )
	IF( ERROR(0) ) CALL BUG('Cannot lookup file.^E')

	CALL INIT( USEFUL, 36, 8 )
	CALL INIT( SCREEN, 18, 24, 80 )
	CALL INIT( COORD, 7, 26, 2 )
	CALL INIT( DISTO, 7, 26, 26 )
	CALL INIT( OWNER, 3, 26 )
	CALL INIT( NUMAT, 36, 26 )
	CALL INIT( CONTAN, 1, 26, 26 )
C	CALL INIT( CONARM, 7, 26, 10 )
	CALL INIT( CONARM, 7, 26 )
	CALL INIT( REGFRM, 5, 100 )
	CALL INIT( REGTO, 5, 100 )
	CALL INIT( AMTMOV, 7, 100 )
	CALL INIT( TIMLFT, 12, 100 )
	CALL INIT( WHOS, 7, 100 )

	CALL DEFADR( 1, IRIGHT( ITBADR( SCREEN ) ) )
	CALL SETDIS( 1 )
	CALL CLRSCR
	MAXREG = 0
	DO 10200 IY1 = 24, 1, -1
	    IY = IY1
	    CALL GETSTR( COMARA, 78, ILEN, 2, EOF )
	    IF( EOF ) CALL BUG('Found eof reading screen^E')
	    IF( ILEN .LT. 72 ) CALL STRING('^M^JPROBLEM=^E')
	    IF( ILEN .LT. 72 ) CALL NUMBER( ILEN )
	    IF( ILEN .LT. 72 ) CALL STRING('.^M^J^B')

	    CALL CURSOR( 1, IY )
	    DO 10100 IX = 1, 72
		IC = COMARA(IX)
		REGNUM = ICON( IC ) - 64
		IF( IC .NE. '=' ) GOTO 10010
		CALL PBACK( ICLDBL )
		CALL PCOLOR( ICLWHI )
		GOTO 10090
10010		IF( IC .NE. ' ' ) GOTO 10020
		CALL PCOLOR( ICLWHI )
		CALL PBACK( ICLWHI )
		GOTO 10090
10020		IF( IC .NE. ',' ) GOTO 10030
		CALL PBACK( ICLDBL )
		CALL PCOLOR( ICLDBL )
		GOTO 10090
10030		IF( IC .GE. 'A' .AND. IC .LE. 'Z' ) GOTO 10040
		CALL PBACK( ICLBLA )
		CALL PCOLOR( ICLBLA )
		GOTO 10090
10040		CALL PBACK( ICLWHI )
		CALL PCOLOR( ICLDBL )
10090		CALL CHROUT( IC )
		IF( REGNUM .LT. 1 .OR. REGNUM .GT. 26 ) GOTO 10100
		IF( IX .GT. 68 )CALL BUG('Region mark out of bounds.^E')
		CALL GETVAL( COORD, REGNUM, 1, IVAL )
		IF( IVAL .NE. 0 )CALL BUG('Two regions with same name.^E')
		MAXREG = MAXREG + 1
		CALL PUTVAL( -1, IX+1 )
		CALL PUTVAL( COORD, REGNUM, 2, IY )
10100	    CONTINUE
10200	CONTINUE
	CALL PUTVAL( USEFUL, 1, MAXREG )

	DO 10400 I = 1, MAXREG
	    CALL GETALN( COMARA, ILEN, EOF )
	    IF( EOF ) CALL BUG('Premature eof reading distances.^E')
	    REGNUM = ICON( COMARA(1) ) - 64
	    IF( REGNUM .LT. 1 .OR. REGNUM .GT. 26 )
     &		CALL BUG('Illegal region name in distances.^E')
	    CALL GETVAL( COORD, REGNUM, 1, IVAL )
	    IF( IVAL .EQ. 0 ) CALL BUG('Unknown region name.^E')
	    DO 10300 CPOS = 2, ILEN-1
		IF( ICON(COMARA(CPOS)) .LT. 64 ) GOTO 10300
		REGINQ = ICON( COMARA( CPOS ) ) - 64
		IF( REGINQ .LT. 1 .OR. REGINQ .GT. 26 )
     &			CALL BUG('Illegal region name in list.^E')
		CALL GETVAL( COORD, REGINQ, 1, IVAL )
		IF( IVAL .EQ. 0 )
     &			CALL BUG('Illegal region name in list.^E')
		CALL GETVAL( DISTO, REGNUM, REGINQ, IVAL )
		IF( IVAL .NE. 0 ) CALL BUG('Distance defined.^E')
		CALL GETNUM( COMARA(CPOS), ILEN-CPOS+1, IVAL, 10 )
		IF( IVAL .LT. 1 ) CALL BUG('Invalid destance.^E')
		CALL PUTVAL( -1, IVAL )
10300	    CONTINUE
10400	CONTINUE

	MAXCON = 0
10500	CALL GETALN( COMARA, ILEN, EOF )
	IF( EOF ) GOTO 10700
	    MAXCON = MAXCON + 1
	    I = ISERCH( COMARA, ' ', ILEN )
	    IF( I .EQ. 0 ) I = ISERCH( COMARA, ICON(9), ILEN )
	    IF( I .EQ. 0 ) CALL BUG('Illegal format for continent.^E')
	    DO 10600 J = 1, I-1
		REGNUM = ICON( COMARA(J) ) - 64
		IF( REGNUM .LT. 1 .OR. REGNUM .GT. 26 )
     &		CALL BUG('Illegal region in continent.^E')
		CALL GETVAL( COORD, REGNUM, 1, IVAL )
		IF( IVAL .EQ. 0 )
     &		CALL BUG('Illegal region in continent.^E')
		CALL GETVAL( CONTAN, MAXCON, REGNUM, IVAL )
		IF( IVAL .NE. 0 ) CALL BUG('Repeated region.^E')
		CALL PUTVAL( -1, 1 )
10600	    CONTINUE
	    CALL GETNUM( COMARA(I), ILEN-I+1, IVAL, 10 )
	    IF( IVAL .LT. 0 )CALL BUG('Illegal content-army number.^E')
	    CALL PUTVAL( CONARM, MAXCON, IVAL )
	GOTO 10500

10700	CALL CLOSE( 2 )
	CALL SETDIS( 0 )
	CALL PUTVAL( USEFUL, 7, MAXCON )
10800	CALL STRING('Input number of players: ^B')
	CALL GETNUM( 10, MAXUSR, 10 )
	IF( MAXUSR .LT. 1 .OR. MAXUSR .GT. 6 ) GOTO 10800
	CALL PUTVAL( USEFUL, 2, MAXUSR )
	CALL PUTVAL( USEFUL, 3, 0 )
	CALL PUTVAL( USEFUL, 8, 0 )
	IF( MAXUSR .GT. 1 ) GOTO 11000
	CALL PUTVAL( -1, 1 )
	CALL ADDVAL( USEFUL, 2, 1 )
	CALL ADDVAL( USEFUL, 3, 1 )
	I = IRAN( MAXREG )
	CALL PUTVAL( OWNER, I, 1 )
	CALL PUTVAL( NUMAT, I, 10 )
11000	CALL UNLOCK
	GOTO 20
20000	CALL GETVAL( USEFUL, 4, MAXCOM )
	IF( MAXCOM .EQ. 0 ) GOTO 20101
	DO 20100 I = 1, MAXCOM
	    NUMCOM = I
	    CALL GETVAL( TIMLFT, NUMCOM, IVAL )
	    IF( IVAL .GT. 0 ) CALL ADDVAL( -1, -1 )
	    IF( IVAL .NE. 1 ) GOTO 20100
	    CALL GETVAL( WHOS, NUMCOM, INVADR )
	    CALL GETVAL( AMTMOV, NUMCOM, NUMINV )
	    CALL GETVAL( REGTO, NUMCOM, R2 )
	    CALL GETVAL( OWNER, R2, DEFNDR )
	    CALL GETVAL( NUMAT, R2, NUMDEF )

C	    IF THE ARMIES INCOMING BELONG TO SOMEONE OTHER THAN THE
C	    THE ARMIES ALREADY THERE, WE HAVE A BATTLE.  SKIP TO BATTLE
C	    LOOP, OTHERWISE SIMPLY INCREASE THE NUMBER AT THE LOCATION.
	    IF( INVADR .NE. DEFNDR .AND. NUMDEF .GT. 0 ) GOTO 20010
	    NUMDEF = NUMDEF + NUMINV
	    GOTO 20030

20010	    IF( IRAN(11) .LE. 6 ) GOTO 20020	! ROLL DICE, INVADER DIED?
	    NUMINV = NUMINV - 1			! YUP, DECREMENT INVADERS
	    IF( NUMINV .GT. 0 ) GOTO 20010	! MORE INVADERS?  MORE BATTLE
	    GOTO 20040

20020	    NUMDEF = NUMDEF - 1			! DECREMENT DEFENDERS
	    IF( NUMDEF .GT. 0 ) GOTO 20010	! MORE DEFENDERS?  MORE BATTLE
	    NUMDEF = NUMINV			! DEFENDERS GONE, SWITCH SIDES
20030	    CALL PUTVAL( OWNER, R2, INVADR )

20040	    CALL PUTVAL( NUMAT, R2, NUMDEF )

20100	CONTINUE
20101	CONTINUE

	CALL ADDVAL( USEFUL, 6, 1 )
	CALL GETVAL( -1, CURTIM )
	IF( CURTIM .LE. INTRVL ) GOTO 20150
	CALL PUTVAL( -1, 0 )
	DO 20110 REGNUM = 1, MAXREG
	    CALL GETVAL( NUMAT, REGNUM+0, IVAL )
	    IF( IVAL .GE. 1 ) CALL ADDVAL( -1, 1 )
20110	CONTINUE

	DO 20140 I = 1, MAXCON
	    NUMCON = I
	    CONOWN = 0
	    DO 20120 J = 1, 26
		R1 = J
		CALL GETVAL( CONTAN, NUMCON, R1, IVAL )
		IF( IVAL .EQ. 0 ) GOTO 20120
		CALL GETVAL( NUMAT, R1, IVAL )
		IF( IVAL .EQ. 0 ) GOTO 20140
		CALL GETVAL( OWNER, R1, IVAL )
		IF( CONOWN .EQ. 0 ) CONOWN = IVAL
		IF( IVAL .NE. CONOWN ) GOTO 20140
20120	    CONTINUE
	    CALL GETVAL( CONARM, NUMCON, NUMARM )
	    DO 20130 J = 1, NUMARM
20125		R1 = IRAN( MAXREG )
		CALL GETVAL( CONTAN, NUMCON, R1, IVAL )
		IF( IVAL .EQ. 0 ) GOTO 20125
		CALL ADDVAL( NUMAT, R1, 1 )
20130	    CONTINUE
20140	CONTINUE

20150	NUMCOM = 0
	IF( MOD( CURTIM, 10 ) .NE. 0 ) GOTO 20181
	CALL GETVAL( USEFUL, 8, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 20181
	DO 20180 I = 1, MAXREG
	    NUMREG = I
	    CALL GETVAL( OWNER, NUMREG, IVAL )
	    IF( IVAL .NE. 1 ) GOTO 20180
	    CALL GETVAL( NUMAT, NUMREG, NMFREG )
	    IF( NMFREG .EQ. 0 ) GOTO 20180
	    BEST = NMFREG
	    DO 20160 J = 1, MAXREG
		REGINQ = J
		CALL GETVAL( DISTO, NUMREG, REGINQ, DIST )
		IF( DIST .EQ. 0 ) GOTO 20160
		CALL GETVAL( OWNER, REGINQ, OWNERQ )
		CALL GETVAL( NUMAT, REGINQ, NUMATQ )
		IF( OWNERQ .NE. 1 ) NUMATQ = -NUMATQ
		IF( NUMATQ .GE. BEST ) GOTO 20160
		BEST = NUMATQ
		BESTRG = REGINQ
		BESTDS = DIST
20160	    CONTINUE
	    IF( BEST .GE. NMFREG-1 ) GOTO 20180
	    NUMMEN = MIN0( NMFREG-1, NMFREG-BEST, 127 )
	    CALL ADDVAL( NUMAT, NUMREG, -NUMMEN )
20170	    NUMCOM = NUMCOM + 1
	    CALL GETVAL( TIMLFT, NUMCOM, IVAL )
	    IF( IVAL .NE. 0 ) GOTO 20170
	    CALL PUTVAL( -1, IFIX( SQRT(FLOAT(NUMMEN))*BESTDS) )
	    CALL PUTVAL( WHOS, NUMCOM, 1 )
	    CALL PUTVAL( REGFRM, NUMCOM, NUMREG )
	    CALL PUTVAL( REGTO, NUMCOM, BESTRG )
	    CALL PUTVAL( AMTMOV, NUMCOM, NUMMEN )
20180	CONTINUE
20181	CONTINUE
	CALL GETVAL( USEFUL, 4, MAXCOM )
	IF( NUMCOM .GT. MAXCOM ) CALL PUTVAL( -1, NUMCOM )

	CALL SETDIS( 1 )
	CALL PBACK( ICLWHI )
	CALL PCOLOR( ICLRED )
	DO 20200 I = 1, MAXREG
	    REGNUM = I
	    CALL GETVAL( COORD, REGNUM, 1, IX )
	    CALL GETVAL( COORD, REGNUM, 2, IY )
	    CALL GETVAL( NUMAT, REGNUM, IVAL )
	    CALL CURSOR( IX, IY )
	    IF( IVAL .EQ. 0 ) GOTO 20190
	    CALL NUMBER( IVAL, -2 )
	    CALL GETVAL( OWNER, REGNUM, IVAL )
	    CALL CHROUT( IVAL+64 )
	    GOTO 20200

20190	    CALL STRING('   ^E')
20200	CONTINUE
	CALL SETDIS( 0 )
	CALL PUTVAL( USEFUL, 5, 0 )
	GOTO 110
	END
	SUBROUTINE BUG( ARRAY )

C***	THIS PROCEDURE PRINTS OUT ERROR MESSAGES IN THE STRING ARRAY.

	INTEGER ARRAY( 1 ), VALUE	! ARRAY AND VALUE TO PRINT

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL SETDIS( 0 )			! MAKE SURE NORMAL I/O
	CALL COLCUR( 1, 1 )			! MESSAGE AT LOWER LEFT
	CALL COLSTR(ICLRED,'^M^J%BUG ^E')	! PRINT HEADER
	CALL STRING( ARRAY )			! PRINT ERROR MESSAGE
	CALL STRING('^M^J^B')			! DUMP THE BUFFER
	CALL NAP(3000)				! MAKE SURE HE SEES THE MESSAGE
	CALL GRAFOF				! RESET THE TERMINAL
	CALL PSTOP				! AND EXIT
	END
	SUBROUTINE GETALN( COMARA, ILEN, EOF )

C***	THIS PROCEDURE RETURNS AN UPPER CASE STRING OF CHARACTERS
C***	READ FROM THE FILE OPENED ON CHANNEL #2 OR EOF WHEN FOUND.
C***	IT WILL IGNORE COMMENTS (STUFF PRECEDED WITH A ;) AND NULL
C***	LINES (ILEN = 0).

	INTEGER COMARA( 80 ), ILEN	! STRING READ AND ITS LENGTH
	LOGICAL EOF			! TRUE ON END OF FILE

100	CALL GETSTR( COMARA, 80, ILEN, 2, EOF )	! GET STRING FROM FILE
	IF( EOF ) RETURN
	IF( ILEN .EQ. 0 .OR. COMARA(1) .EQ. ';' ) GOTO 100
	CALL ALLCAP( COMARA, ILEN )	! INSURE THAT ITS UPPER CASE
	RETURN
	END
	SUBROUTINE COMAND( ICHAR, COMARA, ARRIND )
C***
C***	ROUTINE GET COMMAND FROM USER IF ONE PRESENT.
C***
	INTEGER COMARA(81), INDEX, ARRIND, ICHAR, NUMTIM
	DATA INDEX/0/
C***
C***	IF THERE IS A CHARACTER OUT GET IT, ELSE, SLEEP FOR
C***	0.5 SECONDS OR UNTIL ONE IS.
C***
	NUMTIM = 0
100	ICHAR = -1
	IF( NUMTIM .GT. 10 ) RETURN
	NUMTIM = NUMTIM + 1
	CALL CURBUF
	CALL NAP( 1000, "14 )     
	CALL CHRBUF( ICHAR )
	IF( ICHAR .EQ. -1 )  RETURN
	IF( ICHAR .EQ. "10 .OR. ICHAR .EQ. "177 )  GOTO 300
	IF( ICHAR .EQ. "25 )  GOTO 400
	IF( ICHAR .EQ. "33 .AND. INDEX .EQ. 0 )  GOTO 200
	IF( ICHAR .LT. "40 )  GOTO 600
	IF( INDEX .GE. 7 )  GOTO 700
C***
C***	NOT SPECIAL CHARACTER, PUT IN ARRAY
C***
	INDEX = INDEX + 1
	CALL COLCUR( 72 + INDEX, 1 )
	CALL CHROUT( ICHAR )
	COMARA(INDEX) = ICON( ICHAR )
	GOTO 100
C***
C***	ESCAPE:  REPEAT LAST COMMAND
C***
200	INDEX = INDSTR
	CALL COLCUR( 73, 1 )
	IF( INDEX .NE. 0 )CALL STRING( COMARA, 1, INDEX )
	GOTO 600
C***
C***	DELETE CHARACTER
C***
300	IF( INDEX .EQ. 0 ) GOTO 600
	INDEX = INDEX - 1
	CALL COLCUR( 73 + INDEX, 1 )
	CALL CHROUT( ' ' )
	GOTO 100
C***
C***	DELETE LINE
C***
400	IF( INDEX .EQ. 0 ) GOTO 600
	CALL COLCUR( 73, 1 )
	CALL REPEAT( ' ', INDEX )
	INDEX = 0
	GOTO 100
C***
C***	CARRIAGE RETURN TYPED
C***
600	IF( INDEX .NE. 0 )  GOTO 700
	ICHAR = -1
	GOTO 900

700	COMARA(INDEX + 1) = 0
	CALL COLCUR( 73, 1 )
	CALL REPEAT( ' ', INDEX )
	CALL ALLCAP( COMARA, INDEX )
	ICHAR = COMARA(1)
900	ARRIND = INDEX
	INDSTR = INDEX
	INDEX = 0
	CALL NAP( 1000, 4 )
	RETURN
	END
	SUBROUTINE CEASE( USEFUL )

	CALL ADDVAL( USEFUL, 3, -1 )
	CALL GRAFOF
	CALL SETDIS( 0 )
	CALL CLRSCR
	CALL CLOSE( 1 )
	CALL EXPROG
	END

	SUBROUTINE COLCUR( IX, IY )
	CALL DEFCOL
	CALL CURSOR( IX, IY )
	RETURN
	END

    	SUBROUTINE COLSTR( ICOL, MSGARA )
	INTEGER MSGARA( 16 )
	CALL PCOLOR( ICOL )
	CALL STRING( MSGARA )
	RETURN
	END
