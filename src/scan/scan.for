Cindx#	scan.for - Unfinished game in a 3-d multi-player universe
C@HDR@	$Id$
C@HDR@
C@HDR@	Copyright (c) 1982-2026 Christopher Caldwell (Christopher.M.Caldwell0@gmail.com)
C@HDR@
C@HDR@	Permission is hereby granted, free of charge, to any person
C@HDR@	obtaining a copy of this software and associated documentation
C@HDR@	files (the "Software"), to deal in the Software without
C@HDR@	restriction, including without limitation the rights to use,
C@HDR@	copy, modify, merge, publish, distribute, sublicense, and/or
C@HDR@	sell copies of the Software, and to permit persons to whom
C@HDR@	the Software is furnished to do so, subject to the following
C@HDR@	conditions:
C@HDR@	
C@HDR@	The above copyright notice and this permission notice shall be
C@HDR@	included in all copies or substantial portions of the Software.
C@HDR@	
C@HDR@	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
C@HDR@	KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
C@HDR@	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
C@HDR@	AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
C@HDR@	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
C@HDR@	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
C@HDR@	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
C@HDR@	OTHER DEALINGS IN THE SOFTWARE.
C
Chist#	2026-02-17 - Christopher.M.Caldwell0@gmail.com - Created
C------------------------------------------------------------------------
Cdoc#	scan.for - Unfinished game in a 3-d multi-player universe
Cdoc#	Made with Roger Long's inspiration and Robert Kenney's HIPAK.MAC.
C------------------------------------------------------------------------
	REAL FUNCTION COSDEG( DEG )
	COSDEG = COS( DEG * 3.141592654/180.0 )
	RETURN
	END

	REAL FUNCTION SINDEG( DEG )
	SINDEG = SIN( DEG * 3.141592654/180.0 )
	RETURN
	END


	REAL FUNCTION SMCOS( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMCOS = COSDEG( D )
	RETURN
	END

	REAL FUNCTION SMSIN( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMSIN = SINDEG( D )
	RETURN
	END

	SUBROUTINE FMAIN

	IMPLICIT INTEGER ( B - W )

	INTEGER COMARA( 80 ), PAR( 20 ), FILSPC( 13 ), SCREEN( 960 )
	INTEGER COMLST( 5 )
	REAL X, Y, Z, AZIM, AELV, AROL, ARNG
	LOGICAL NEW, INIFLG, NEWANG

	COMMON/NHCOM/NEWANG
	COMMON /NAMES/ USEFUL, INUSE, COORD, SIZE, NUMOBJ

	DATA NEW/.TRUE./, ARNG/100.0/, X,Y,Z/5000.0,5000.0,5000.0/

	IF( COMLST(1) .NE. 0 ) GOTO 100
	COMLST(1) = ISXBIT('EXIT')	! "457051640000
	COMLST(2) = ISXBIT('NEW')	! "564567000000
	COMLST(3) = ISXBIT('POSITI')	! "605763516451
	COMLST(4) = ISXBIT('PROJEC')	! "606257524543
	COMLST(5) = ISXBIT('RANGE')	! "624156474500
100	CONTINUE

	CALL SETTTY( COMARA, PAR, ILEN, PRIVD, FILSPC )	! INIT GRAPHICS
	DO 105 I=1, ILEN
    	    IF( PAR(I) .EQ. ISXBIT('NEWANG') ) NEWANG=.TRUE.
105	CONTINUE

	CALL CHECK( INIFLG )
	IF( INIFLG ) CALL INITDB
	CALL DEFSCR( 1, SCREEN )
	CALL CTRAP
	    CALL CEASE
	CALL GRAFON
	CALL SETDIS( 1 )

1000	CALL CUBE( NEW, X,Y,Z, AZIM,AELV,AROL, ARNG )
	IF( NEW ) CALL NEWSCR( 1 )
	IF( .NOT. NEW ) CALL UPDATE( 1 )
	CALL CLRLIN
	NEW = .FALSE.

	CALL SETDIS( 0 )
	CALL COMAND( ICHAR, COMARA, ILEN )
	CALL SETDIS( 1 )
	IF( ICHAR .EQ. -1 .OR. ILEN .EQ. 0 ) GOTO 1000
	CALL PARSE( COMARA, ILEN, PAR, PLEN, 20 )
	IF( PLEN .EQ. 0 ) GOTO 1000
	IF( PLEN .LT. 20 ) CALL ARFILL( PAR(PLEN+1), 20-PLEN, 0 )
	ICOM = ISRSIX( COMLST, PAR(1), 5 )
	IF( ICOM .GT. 0 ) GOTO( 1100, 1200, 1300, 1400, 1500 ) ICOM
	IF( ICOM .LT. 0 ) CALL MESSAG('Ambiguous^E')
	IF( ICOM .EQ. 0 ) CALL MESSAG('Unknown^E')
	CALL STRING(' command ^E')
	CALL STRING( PAR(1), 6, -6 )
	CALL CHROUT('.')
	GOTO 1000

1100	CALL CEASE

1200	NEW = .TRUE.
	GOTO 1000

1300	CALL GETNUM( COMARA, ILEN, ITORX, 10, ITORY, 10, ITORZ, 10 )
	X = ITORX
	Y = ITORY
	Z = ITORZ
	GOTO 1000

1400	CALL GETNUM( COMARA, ILEN, IAZIM, 10, IAELV, 10, IAROL, 10 )
	AXIM = IAZIM
	AELV = IAELV
	AROL = IAROL
	GOTO 1000

1500	CALL GETNUM( COMARA, ILEN, IARNG, 10 )
	ARNG = IARNG
	GOTO 1000

	END
	SUBROUTINE INITDB

	IMPLICIT INTEGER ( B - W )

	COMMON /NAMES/ USEFUL, INUSE, COORD, SIZE, NUMOBJ

	DATA USEFUL, INUSE, COORD, SIZE/1,2,3,4/
	DATA NUMOBJ/1/
	DATA NOBJ/100/

	CALL INIT( USEFUL, 36, 1 )
	CALL INIT( INUSE, 1, 200 )
	CALL INIT( COORD, 36, 200, 3 )
	CALL INIT( SIZE, 36, 200 )

	DO 100 I = 1, NOBJ
	    IOBJ = NEWOBJ(.FALSE.)
	    CALL PUTVAL( COORD, IOBJ, 1, IRAN(10000)+0.0 )
	    CALL PUTVAL( COORD, IOBJ, 2, IRAN(10000)+0.0 )
	    CALL PUTVAL( COORD, IOBJ, 3, IRAN(10000)+0.0 )
	    CALL PUTVAL( SIZE, IOBJ, IRAN(100)+0.0 )
100	CONTINUE
	CALL PUTVAL( USEFUL, NUMOBJ, NOBJ )
	CALL UNLOCK
	RETURN
	END
	SUBROUTINE BUG( ARRAY )

C***	THIS PROCEDURE PRINTS OUT ERROR MESSAGES IN THE STRING ARRAY.

	INTEGER ARRAY( 1 ), VALUE	! ARRAY AND VALUE TO PRINT

	CALL SETDIS( 0 )		! MAKE SURE NORMAL I/O
	CALL CURSOR( 1, 1 )		! MESSAGE AT LOWER LEFT
	CALL STRING('^M^J%BUG ^E')	! PRINT HEADER
	CALL STRING( ARRAY )		! PRINT ERROR MESSAGE
	CALL STRING('^M^J^B')		! DUMP THE BUFFER
	CALL GRAFOF			! RESET THE TERMINAL
	CALL PSTOP			! AND EXIT
	END
	INTEGER FUNCTION NEWOBJ( LOCKIT )

	IMPLICIT INTEGER ( A - Z )

	LOGICAL LOCKIT

	COMMON /NAMES/ USEFUL, INUSE, COORD, SIZE, NUMOBJ

	IF( LOCKIT ) CALL LOCK
	CALL GETVAL( USEFUL, NUMOBJ, MAXOBJ )
	IF( LOCKIT ) GOTO 101
	DO 100 I = 1, MAXOBJ
	    IOBJ = I
	    CALL GETVAL( INUSE, IOBJ, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 200
100	CONTINUE
101	CONTINUE
	IOBJ = MAXOBJ + 1
	CALL PUTVAL( USEFUL, NUMOBJ, IOBJ )
200	CALL PUTVAL( INUSE, IOBJ, 1 )
	NEWOBJ = IOBJ
	RETURN
	END
	SUBROUTINE MESSAG( ARRAY )

	INTEGER ARRAY( 7 ), NUMTHR

	IF( NUMTHR .LE. 0 ) GOTO 100
	CALL CURSOR( 45, 2 )
	CALL REPEAT( ' ', 35 )
100	CALL CURSOR( 45, 2 )
	CALL STRING( ARRAY )
	NUMTHR = 10
	RETURN

	ENTRY CLRLIN

	NUMTHR = NUMTHR - 1
	IF( NUMTHR .NE. 0 ) RETURN
	CALL CURSOR( 45, 2 )
	CALL REPEAT( ' ', 35 )
	RETURN
	END
	SUBROUTINE CEASE

	CALL GRAFOF
	CALL SETDIS( 0 )
	CALL CLRSCR
	CALL CLOSE( 1 )
	CALL EXPROG
	END
	SUBROUTINE COMAND( ICHAR, COMARA, ARRIND )
C***
C***	ROUTINE GET COMMAND FROM USER IF ONE PRESENT.
C***
	INTEGER COMARA(80), INDEX, ARRIND, ICHAR, NUMTIM
	DATA INDEX/0/
C***
C***	IF THERE IS A CHARACTER OUT GET IT, ELSE, SLEEP FOR
C***	0.5 SECONDS OR UNTIL ONE IS.
C***
	NUMTIM = 0
100	ICHAR = -1
	IF( NUMTIM .GT. 10 ) RETURN
	NUMTIM = NUMTIM + 1
	CALL CURBUF
	CALL NAP( 1000, "14 )     
	CALL CHRBUF( ICHAR )
	IF( ICHAR .EQ. -1 )  RETURN
	IF( ICHAR .EQ. "10 .OR. ICHAR .EQ. "177 )  GOTO 300
	IF( ICHAR .EQ. "25 )  GOTO 400
	IF( ICHAR .EQ. "33 .AND. INDEX .EQ. 0 )  GOTO 200
	IF( ICHAR .LT. "40 )  GOTO 600
	IF( INDEX .GE. 78 )  GOTO 700
C***
C***	NOT SPECIAL CHARACTER, PUT IN ARRAY
C***
	INDEX = INDEX + 1
	CALL CURSOR( 1 + INDEX, 1 )
	CALL CHROUT( ICHAR )
	COMARA(INDEX) = ICON( ICHAR )
	GOTO 100
C***
C***	ESCAPE:  REPEAT LAST COMMAND
C***
200	INDEX = INDSTR
	CALL CURSOR( 2, 1 )
	IF( INDEX .NE. 0 )CALL STRING( COMARA, 1, INDEX )
	GOTO 600
C***
C***	DELETE CHARACTER
C***
300	IF( INDEX .EQ. 0 ) GOTO 600
	INDEX = INDEX - 1
	CALL CURSOR( 2 + INDEX, 1 )
	CALL CHROUT( ' ' )
	GOTO 100
C***
C***	DELETE LINE
C***
400	IF( INDEX .EQ. 0 ) GOTO 600
	CALL CURSOR( 2, 1 )
	CALL REPEAT( ' ', INDEX )
	INDEX = 0
	GOTO 100
C***
C***	CARRIAGE RETURN TYPED
C***
600	IF( INDEX .NE. 0 )  GOTO 700
	ICHAR = -1
	GOTO 900

700	COMARA(INDEX + 1) = 0
	CALL CURSOR( 2, 1 )
	CALL REPEAT( ' ', INDEX )
	CALL ALLCAP( COMARA, INDEX )
	ICHAR = COMARA(1)
900	ARRIND = INDEX
	INDSTR = INDEX
	INDEX = 0
	CALL NAP( 1000, 4 )
	RETURN
	END
	SUBROUTINE CUBE( NEW, XVIEW,YVIEW,ZVIEW, AZIM,AELV,AROL, ARNG )

	IMPLICIT INTEGER ( B - W )

	INTEGER DIRS(30), SCANX
	LOGICAL NEW
	REAL XVIEW, YVIEW, ZVIEW, AZIM, AELV, AROL, ARNG, X, Y, Z, RADIUS
	REAL XVA, XVB, XVC, XVD, XVS
	REAL YVA, YVB, YVC, YVD, YVS, YSCAN
	REAL ZVA, ZVB, ZVC, ZVD, ZVS, ZSCAN
	REAL SMCOS, SMSIN, COSDEG, SINDEG

	COMMON /NAMES/ USEFUL, INUSE, COORD, SIZE, NUMOBJ

	DATA DIRS/
     &	5050,4950,5150,5049,5051,4949,5151,4951,5149,5250,
     &	4850,5250,5048,5052,4849,5251,4851,5249,4948,5152,
     &	4952,5148,4750,5350,5047,5053,4848,5252,4852,5248 /

	IF( .NOT. NEW ) GOTO 20
	CALL CLRSCR
	CALL CURSOR( 1, 24 )
	CALL CHROUT( '/' )
	CALL REPEAT( '-', 41 )
	CALL CHROUT( '\' )
	CALL CRLF
	DO 10 IY = 1, 21
	    CALL CHROUT('|')
	    CALL CURSOR( 43, 24-IY )
	    CALL CHROUT('|')
	    CALL CRLF
10	CONTINUE
	CALL CHROUT( '\' )
	CALL STRING('- Ber:___/___ --- Rol:___ --- Ran:_____ -^E')
	CALL CHROUT( '/' )
	CALL CURSOR( 45, 24 )
	CALL STRING('Bearing Range    Velocity^E')
	CALL CURSOR( 1, 1 )
	CALL CHROUT('>')

20	DO 30 IY = 1, 21
	    CALL CURSOR( 2, 24-IY )
	    CALL REPEAT( ' ', 41 )
30	CONTINUE
	CALL CURSOR( 8, 2 )
	CALL NUMBER( AZIM, 3, 10, -1 )
	CALL CHROUT('/')
	CALL LNUMBR( AELV, 3, 10, -1 )
	CALL CURSOR( 24, 2 )
	CALL NUMBER( AROL, 3, 10, -1 )
	CALL CURSOR( 36, 2 )
	CALL NUMBER( ARNG, 5, 10, -1 )
	CALL CHROUT( ' ' )

	XVA = SMCOS( AZIM ) * COSDEG(AELV)
	XVB = SMSIN( AZIM ) * COSDEG(AELV)
	XVC = SINDEG(AELV )
	XVD = -(XVA*XVIEW + XVB*YVIEW + XVC*ZVIEW)
	XVS = SQRT( XVA*XVA + XVB*XVB + XVC*XVC )

	YVA = SMCOS( AZIM+90.0 ) * COSDEG(AELV+AROL)
	YVB = SMSIN( AZIM+90.0 ) * COSDEG(AELV+AROL)
	YVC = SINDEG(AELV+AROL)
	YVD = -(YVA*XVIEW + YVB*YVIEW + YVC*ZVIEW)
	YVS = SQRT( YVA*YVA + YVB*YVB + YVC*YVC )

	ZVA = SMCOS( AZIM+90.0 ) * COSDEG((AELV+AROL+90.0) )
	ZVB = SMSIN( AZIM+90.0 ) * COSDEG((AELV+AROL+90.0) )
	ZVC = SINDEG(AELV+AROL+90.0)
	ZVD = -(ZVA*XVIEW + ZVB*YVIEW + ZVC*ZVIEW)
	ZVS = SQRT( ZVA*ZVA + ZVB*ZVB + ZVC*ZVC )

	NOBJDS = 23
	CALL GETVAL( USEFUL, NUMOBJ, MAXOBJ )
	DO 300 I = 1, MAXOBJ
	    IOBJ = I
	    CALL GETVAL( INUSE, IOBJ, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 300
	    CALL GETVAL( COORD, IOBJ, 1, X )
	    CALL GETVAL( COORD, IOBJ, 2, Y )
	    CALL GETVAL( COORD, IOBJ, 3, Z )
	    CALL CARPOL( XVIEW,YVIEW,ZVIEW, X,Y,Z, AZ,AE,AR )
	    IF( AR .GT. ARNG ) GOTO 100
	    IF( NOBJDS .LT. 3 ) GOTO 100
	    CALL CURSOR( 45, NOBJDS )
	    CALL NUMBER( AZ, 3, 10, -1 )
	    CALL CHROUT( '/' )
	    CALL LNUMBR( AE, 3, 10, -1 )
	    CALL CHROUT( ' ' )
	    CALL NUMBER( AR, 5, 10, -1 )
	    NOBJDS = NOBJDS - 1
100	    CONTINUE
	    
	    SCANX = ( XVA*X+XVB*Y+XVC*Z+XVD ) / ( ARNG*XVS ) + 0.5
	    YSCAN = ( YVA*X+YVB*Y+YVC*Z+YVD ) / ( ARNG*YVS )
	    ZSCAN = ( ZVA*X+ZVB*Y+ZVC*Z+ZVD ) / ( ARNG*ZVS )
	    IF( IABS(SCANX).GT.10 .OR. ABS(YSCAN).GT.10 .OR.
     &		ABS(ZSCAN).GT.10 ) GOTO 300
	    IF( SCANX .LT. 0 ) ICHAR = 47-SCANX
	    IF( SCANX .GE. 0 ) ICHAR = 64+SCANX
	    CALL GETVAL( SIZE, IOBJ, RADIUS )
	    IRAD = MIN0( IFIX(4*RADIUS/ARNG)+1, 30 )
	    DO 200 INDEX = 1, IRAD
		IX = IFIX(2*YSCAN) + DIRS(INDEX)/100 - 28
		IF( IX .LT. 2 .OR. IX .GT. 42 ) GOTO 200
		IY = IFIX(ZSCAN) + MOD(DIRS(INDEX),100) - 37
		IF( IY .LT. 3 .OR. IY .GT. 23 ) GOTO 200
		CALL CURSOR( IX, IY )
		CALL CHROUT( ICHAR )
200	    CONTINUE
300	CONTINUE
	IF( NOBJDS .LE. 2 ) RETURN
	CALL CURSOR( 45, NOBJDS )
	CALL REPEAT( ' ', 13 )
	NOBJDS = NOBJDS - 1
	GOTO 300
	END
	SUBROUTINE CARPOL( X0,Y0,Z0, X1,Y1,Z1, AZ,AE,AR )

	IMPLICIT INTEGER ( B - W )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG

	XD = X1 - X0
	YD = Y1 - Y0
	ZD = Z1 - Z0
C	NEWANG LOGIC NOT TESTED AT ALL!
	AZ = ATAN( YD/(XD+0.0001) ) / 0.017453293
	IF( X1 .LT. X0 ) AZ = AZ + 180.0
	IF( NEWANG ) AZ = 90 - AZ
	APARTD = SQRT( XD*XD + YD*YD )
	AE = ATAN( ZD/(APARTD+0.0001) ) / 0.017453293
C	END NEWANG LOGIC
	AR = SQRT( APARTD*APARTD + ZD*ZD )
	RETURN
	END
