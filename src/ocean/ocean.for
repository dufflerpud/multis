C	@HDR@	$Id$
C	@HDR@		Copyright 1979-2024 by
C	@HDR@		Christopher Caldwell/Brightsands
C	@HDR@		P.O. Box 401, Bailey Island, ME 04003
C	@HDR@		All Rights Reserved
C	@HDR@
C	@HDR@	This software comprises unpublished confidential information
C	@HDR@	of Brightsands and may not be used, copied or made available
C	@HDR@	to anyone, except in accordance with the license under which
C	@HDR@	it is furnished.
C
C
C
C	CREATED DECEMBER 29, 1979
C
C		** OCEAN **
C
C		BY CHRIS CALDWELL
C		  AT THE UNIVERSITY OF NEW HAMPSHIRE
C
C
C

	REAL FUNCTION COSDEG( DEG )
	COSDEG = COS( DEG * 3.141592654/180.0 )
	RETURN
	END

	REAL FUNCTION SINDEG( DEG )
	SINDEG = SIN( DEG * 3.141592654/180.0 )
	RETURN
	END


	REAL FUNCTION SMCOS( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMCOS = COSDEG( D )
	RETURN
	END

	REAL FUNCTION SMSIN( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMSIN = SINDEG( D )
	RETURN
	END


	SUBROUTINE DEFCOL

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLBLA )
	RETURN
	END

	SUBROUTINE DISPLA
     &( SHIPX, SHIPY, IDEPTH, DEGREE, ICHAR, DAMAGE, KIND, IPORT )
C
C***	SUBROUTINE UPDATES RADAR AND SONAR
C
	IMPLICIT INTEGER( A-Z )
	INTEGER ABVARA(19,19), SIDARA(10,19,2), DAMAGE(8,2)
	LOGICAL NEXT
	REAL SMCOS, SMSIN

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA
C
	IBOT = 9
	IF( KIND .EQ. 2 ) IBOT = 1
	IF( KIND .EQ. 5 ) IBOT = 17
	ITOP = 27
	IF( KIND .EQ. 2 ) ITOP = 19
	IF( KIND .EQ. 5 ) ITOP = 35
C
C***	GET INFORMATION ABOUT PORTS
C
	IF( IP1C .NE. 0 ) GOTO 100
	CALL GETVAL( 3, 1, 3, IP1X )
	CALL GETVAL( 3, 1, 4, IP1Y )
	CALL GETVAL( 3, 1, 1, IP1CS )
	CALL CONVRT( IP1CS, 1, 6, IP1C, 0 )
C	IP1C = SHIFT( IP1C, -30 )
C	IP1C = IP1C + 32
	CALL GETVAL( 3, 2, 3, IP2X )
	CALL GETVAL( 3, 2, 4, IP2Y )
	CALL GETVAL( 3, 2, 1, IP2CS )
	CALL CONVRT( IP2CS, 1, 6, IP2C, 0 )
C	IP2C = SHIFT( IP2C, -30 )
C	IP2C = IP2C + 32
C
C***	PRINT OUT RADAR
C
100	IPOSY = 20
	ISHIPX = SHIPX + 0.5
	ISHIPY = SHIPY + 0.5
	CALL GETVAL( 5, 1, IEX )
	CALL GETVAL( 5, 2, IEY )
	CALL GETVAL( 5, 3, IED )
	CALL GETVAL( 5, 4, IEF )
	DO 400 IYTEMP = ISHIPY+9, ISHIPY-9, -1
	    NEXT = .FALSE.
	    IY = IYTEMP
	    IPOSY = IPOSY - 1
	    IPOSX = 0
	    DO 400 IXTEMP = ISHIPX-9, ISHIPX+9
		IX = IXTEMP
		IPOSX = IPOSX + 1
		IF(SQRT((IPOSX-10+0.)^2+(IPOSY-10+0.)^2).GT.9.5)GOTO 400
		IF( ICHAR .EQ. 'N' )  ABVARA(IPOSX,IPOSY)=' '
		IF( IX .LT. 1 .OR. IX .GT. 120 .OR. IY .LT. 1 .OR.
     &		    IY .GT. 120 ) GOTO 200
		CALL GETVAL( 1, IX, IY, IDEP )
		IF( IRIGHT(IDEP) .GE. IDEPTH ) GOTO 150
		IPCHAR = ' '
		IPCOLR = ICLBLA
		GOTO 160
150		IF( IRIGHT(IDEP) .GE. 18 ) GOTO 155
		IPCHAR = '-'
		IPCOLR = ICLDBL
		GOTO 160
155		IPCHAR = '#'
		IPCOLR = ICLGRE
160		DIST = SQRT((IEX-IX+0.)^2+(IEY-IY+0.)^2+(IED-IDEPTH+0.)^2)
		IF( DIST .GT. IEF .OR. IEF .EQ. 0 ) GOTO 165
		IPCHAR = "42+DIST
		IPCOLR = ICLYEL
165		IF( IX .EQ. IP1X .AND. IY .EQ. IP1Y )  IPCHAR = IP1C
		IF( IX .EQ. IP2X .AND. IY .EQ. IP2Y )  IPCHAR = IP2C
		IF( ILEFT(IDEP) .EQ. 0 ) GOTO 300
		IF( ILEFT(IDEP) .EQ. 26+IPORT ) IPCHAR = '+'
		IF( ILEFT(IDEP) .GT. 26 ) GOTO 300
		CALL GETVAL( 2, ILEFT(IDEP), 7, IVAL )
		IF( IVAL .GT. 5100 ) IPCHAR = '.'
		CALL GETVAL( 2, ILEFT( IDEP ), 4, IVAL )
		IF( IVAL .LT. IDEPTH .AND. IVAL .LT. 18 ) GOTO 300
		IPCHAR = 64 + ILEFT( IDEP )
		GOTO 300
C
200		IPCHAR = '#'
		IPCOLR = ICLGRE
C
300		IF( DAMAGE( 3, 1 ) .EQ. 0 ) GOTO 320
		IPCHAR = '%'
		IPCOLR = ICLPUR
320		IF( ABVARA( IPOSX, IPOSY ) .NE. IPCHAR ) GOTO 350
		NEXT = .FALSE.
		GOTO 400
350		IF( .NOT. NEXT )CALL COLCUR( IPOSX*2, 4+IPOSY )
		CALL PBACK( IPCOLR )
		IF( IPCHAR.EQ.' ' .OR. IPCHAR.EQ.'-' .OR. IPCHAR.EQ.'#' )
     &		    GOTO 355
		CALL PCOLOR( ICLWHI )
		GOTO 360

355		CALL PCOLOR( IPCOLR )

360		CALL CHROUT( IPCHAR )
		CALL CHROUT(' ')
		ABVARA( IPOSX, IPOSY ) = IPCHAR
		NEXT = .TRUE.
400	CONTINUE
C
C***	LOAD SONAR ARRAY
C
	DO 500 ITEMP = 1, 10
	    I = ITEMP
	    IX = SHIPX + SMCOS( FLOAT(DEGREE) )*FLOAT(I-1)+.5
	    IY = SHIPY + SMSIN( FLOAT(DEGREE) )*FLOAT(I-1)+.5
	    IVAL = 21
	    IF( IX .GT. 1 .AND. IX .LE. 120 .AND. IY .GT. 1 .AND.
     &		IY .LE. 120 ) CALL GETVAL( 1, IX, IY, IVAL )
	    ID = ILEFT( IVAL )
	    ID1 = 0
	    IF( ID .GT. 26 )GOTO 480
	    IF( ID .NE. 0 )  CALL GETVAL( 2, ID, 4, ID1 )
	    IVAL = IRIGHT( IVAL )
	    GOTO 490
C
480	    IF( 26+IPORT .NE. ID ) IVAL = IRIGHT( IVAL )
	    IF( 26+IPORT .NE. ID ) GOTO 490
	    ID = -21
	    ID1 = 18
	    IVAL = IRIGHT( IVAL )
C
490	    DO 500 IZTEMP = IBOT, ITOP
		IZ = IZTEMP
		IORZ = IZ - 8
		IF( KIND .EQ. 2 ) IORZ = IZ
		IF( KIND .EQ. 5 ) IORZ = IZ - 16
		ICOL = ICLLBL
		IF( IZ .LE. 18 ) ICOL = ICLDBL
		IF( ICHAR .EQ. 'N' ) SIDARA( I, IORZ, 2 ) = 32
		IPCHAR = 32
		DIST = SQRT((IEX-IX+0.)^2+(IEY-IY+0.)^2+(IED-IZ+0.)^2)
		IF( DIST .GT. IEF .OR. IEF .EQ. 0 ) GOTO 495
		IPCHAR = "42+DIST
		ICOL = ICLYEL
495		IF( IVAL .GE. IZ )  IPCHAR = 35
		IF( ID1 .EQ. IZ )  IPCHAR = ID+64
		IF( IPCHAR .EQ. ' ' .AND. IZ .EQ. 18 )  IPCHAR = 44
		IPCHAR = IPCHAR + 256 * ICOL
		IF( DAMAGE(4,1).NE.0 .OR. ICHAR.EQ.'N')
     &		    IPCHAR = 32 + 256 * ICLBLA
		SIDARA( I, IORZ, 1 ) = IPCHAR
500	CONTINUE

C
C***	PRINT OUT SONAR
C
	DO 510 IORZ = 19, 1, -1
	    NEXT = .FALSE.
	    DO 510 I = 1, 10
		IPCHAR = SIDARA( I, IORZ, 1 )
		IF( IPCHAR .NE. SIDARA( I, IORZ, 2 ) ) GOTO 505
		NEXT = .FALSE.
		GOTO 510
505		IF( .NOT. NEXT ) CALL COLCUR( 39+2*I, 4+IORZ )
		ICOL = IPCHAR / 256
		IPCR = MOD( IPCHAR, 256 )
		IF( IPCR .EQ. 35 ) ICOL = ICLBLA
		CALL PBACK( ICOL )
		IF( IPCR.NE.35 .AND. IPCR .NE. 32 ) GOTO 508
		CALL PCOLOR( ICOL )
		CALL REPEAT( IPCR, 2 )
		GOTO 509

508		CALL CHROUT(' ')
		CALL PCOLOR( ICLWHI )
		CALL CHROUT( IPCR )
		IPCR = 32

509		IF( I .EQ. 10 ) CALL CHROUT(IPCR)
		IOCHAR = IPCHAR
		SIDARA( I, IORZ, 2 ) = IPCHAR
		NEXT = .TRUE.
510	CONTINUE
C
C***	PRINT OUT SONAR SCAN DIRECTION
C
	IF( DEGREE .EQ. ODEGRE .AND. ICHAR .NE. 'N' )  RETURN
	CALL COLCUR( 55, 24 )
	CALL NUMBER( DEGREE, 3 )
	ODEGRE = DEGREE
	RETURN
	END
	SUBROUTINE INITDB( DEBUG, WANNAM )
C
C***	SET UP DATA BASE
C
	IMPLICIT INTEGER( A-Z )
C
	INTEGER SNAME1( 2 ), SNAME2( 2 ), ARRAY( 12 ), COMARA( 60 )
	LOGICAL DEBUG, WANNAM
C
	IF( DEBUG )CALL CLRSCR
C
C***	MASTER ARRAY CONSISISTING OF DEPTHS IN RIGHT OF WORDS
C***	AND ZEROS OR SHIP NUMBERS IN LEFT OF WORDS
	CALL INIT( 1, 36, 120, 120 )
C
C***	ARRAY CONTAINING SHIP INFORMATION
C***	WORD		CONTAINING
C***	1		JOB NUMBER
C***	2		X COORDINATE
C***	3		Y COORDINATE
C***	4		DEPTH
C***	5		FIRST 6 CHARACTERS OF SHIP'S NAME
C***	6		LAST 6 CHARACTERS OF SHIP'S NAME
C***	7		SOUND GENERATED BY SHIP
C***	8		PROJECTILE HIT FLAG
C***	9		SHIP'S  AFFILIATION
C***	10		SHIP TYPE
	CALL INIT( 2, 36, 26, 10 )
C
C***	ARRAY CONTAINING PORT INFORMATION
C***	WORD		CONTAINING
C***	1		FIRST 6 LETTERS OF PORT
C***	2		LAST 6 LETTERS OF PORT
C***	3		X COORDINATE OF PORT
C***	4		Y COORDINATE OF PORT
C***	5		NUMBER OF SHIPS PLAYING FOR THAT PORT
C***	6		NUMBER OF HITS ON PORT
	CALL INIT( 3, 36, 2, 6 )
C
C***	ARRAY CONSISTING OF PPNS OF PEOPLE WHO HAVE BEEN KILLED
	CALL INIT( 4, 36, 50 )
C
C***	ARRAY CONSISTING OF EXPLOSION INFORMATION
C***	AND GENERAL NON-ARRAY TYPE INFORMATION
C***	WORD		CONTAINING
C***	1		X COORDINATE OF EXPLOSION
C***	2		Y COORDINATE OF EXPLOSION
C***	3		DEPTH OF EXPLOSION
C***	4		FORCE OF EXPLOSION
C***	5		FLAG INDICATING THAT PORT #1 HAD A PLAYER
C***	6		FLAG INDICATING THAT PORT #2 HAD A PLAYER
	CALL INIT( 5, 18, 6 )
C
C***	ARRAY CONSISTING OF MESSAGE INFO
C***	WORD		CONTAINING
C***	1		WHO TO
C***	2		LENGTH
C***	3		WHO FROM
C***	4-63		MESSAGE
	CALL INIT( 6, 36, 63 )
C
C***	MAKE SURE ALL BORDERS ARE LAND
C
	IF( DEBUG )CALL COLCUR( 1, 24 )
	IF( DEBUG )CALL STRING('[Initializing borders]^M^J^E')
	DO 100 ITEMP = 1, 120
	    I = ITEMP
	    CALL PUTVAL( 1, I, 1, 20 )
	    CALL PUTVAL( 1, I, 120, 20 )
	    CALL PUTVAL( 1, 1, I, 20 )
	    CALL PUTVAL( 1, 120, I, 20 )
100	CONTINUE
C
C***	NOW GENERATE RANDOM DEPTHS EVERY 10 X 10 UNITS
C
	IF( DEBUG )CALL COLCUR( 1, 23 )
	IF( DEBUG )CALL STRING('[Random sequence]^M^J^E')
	DO 200 XTEMP = 10, 110, 10
	    X = XTEMP
	    DO 200 YTEMP = 10, 110, 10
		Y = YTEMP
		IF( DEBUG )CALL COLCUR( X/2+1, Y/10+9 )
		IDEPTH = IRAN( 20 )
		IF( DEBUG )CALL NUMBER( IDEPTH, 2 )
		CALL PUTVAL( 1, X, Y, IDEPTH )
200	CONTINUE
C
C***	NOW INTERPOLATE BETWEEN ALL THOSE POINTS
C
	IF( DEBUG )CALL COLCUR( 1, 22 )
	IF( DEBUG )CALL STRING('[Generalization sequence]^M^J^E')
	DO 700 XTEMP = 2, 119
	    X = XTEMP
	    XREL = MOD( X, 10 )
	    XPOS = (X/10)*10
	    XFPOS = XPOS
	    IF( XFPOS .EQ. 0 )  XFPOS = 1
	    DO 700 YTEMP = 2, 119
		Y = YTEMP
		YREL = MOD( Y, 10 )
C
		IF( XREL .NE. 0 .OR. YREL .NE. 0 ) GOTO 300
		IF( DEBUG )CALL COLCUR( X/2+3, Y/10+9 )
		IF( DEBUG )CALL CHROUT('#')
C
300		YPOS = (Y/10)*10
		YFPOS = YPOS
		IF( YFPOS .EQ. 0 )  YFPOS = 1
C
		IF( XREL .EQ. 0 .AND. YREL .NE. 0 ) GOTO 400
		IF( YREL .EQ. 0 .AND. XREL .NE. 0 ) GOTO 500
		IF( XREL .EQ. 0 .AND. YREL .EQ. 0 ) GOTO 700
C
		CALL GETVAL( 1, XFPOS, YFPOS, X0Y0 )
		CALL GETVAL( 1, XPOS+10, YFPOS, X1Y0 )
		CALL GETVAL( 1, XFPOS, YPOS+10, X0Y1 )
		CALL GETVAL( 1, XPOS+10, YPOS+10, X1Y1 )
		DEPTH1 = X0Y0 + XREL*(X1Y0-X0Y0)/10
		DEPTH2 = X0Y1 + XREL*(X1Y1-X0Y1)/10
		DEPTH = DEPTH1 + YREL*(DEPTH2-DEPTH1)/10
		GOTO 600
C
400		CALL GETVAL( 1, XFPOS, YFPOS, X0Y0 )
		CALL GETVAL( 1, XFPOS, YPOS+10, X0Y1 )
		DEPTH = X0Y0 + YREL*(X0Y1-X0Y0)/10
		GOTO 600
C
500		CALL GETVAL( 1, XFPOS, YFPOS, X0Y0 )
		CALL GETVAL( 1, XPOS+10, YFPOS, X1Y0 )
		DEPTH = X0Y0 + XREL*(X1Y0-X0Y0)/10
C
600		CALL PUTVAL( 1, X, Y, DEPTH )
700	CONTINUE
C
C***	SET UP PORTS
C
	IF( DEBUG )CALL COLCUR( 1, 21 )
	IF( DEBUG )CALL STRING('[Initializing ports]^M^J^E')
C
	IF( WANNAM ) GOTO 770
C
C***	USER DOESN'T WANT TO SETUP THE NAMES, PUT IN DEFAULTS
C
	CALL CONVRT('Ichthyopolis', 12, 5, SNAME1, 6 )
	CALL CONVRT('Oceanus     ', 12, 5, SNAME2, 6 )
	GOTO 1000
C
C***	USER IS PRIV'D.  ALLOW HIM TO SET UP PORT NAMES
C
770	IF( .NOT. DEBUG )CALL CLRSCR
800	CALL COLCUR( 1, 9 )
	CALL STRING('Enter name of port #1:                       ^E')
	CALL COLCUR( 24, 9 )
	CALL GETSTR( ARRAY, 12, I )
	CALL COLCUR( 1, 7 )
	CALL STRING('                                      ^E')
	ICHAR1 = ICON( ARRAY(1) ) - 64
	IF( ICHAR1 .LT. 1 .OR. ICHAR1 .GT. 26 ) GOTO 900
	CALL CONVRT( ARRAY, 12, 1, SNAME1, 6 )
	CALL COLCUR( 1, 8 )
	CALL STRING('Enter name of port #2:                       ^E')
	CALL COLCUR( 24, 8 )
	CALL GETSTR( ARRAY, 12, I )
	ICHAR2 = ICON( ARRAY(1) ) - 64
	IF( ICHAR1 .EQ. ICHAR2 .OR. ICHAR2 .LT.1 .OR. ICHAR2 .GT. 26 )
     & GOTO 900
	CALL CONVRT( ARRAY, 12, 1, SNAME2, 6 )
	GOTO 1000
C
900	CALL COLCUR( 1, 7 )
	CALL STRING('Port names must be unique.^E')
	GOTO 800
C
C***	PUT FIRST PORT IN BASE (MAKE UP ITS COORDINATES)
C
1000	CALL PUTVAL( 3, 1, 1, SNAME1( 1 ) )
	CALL PUTVAL( 3, 1, 2, SNAME1( 2 ) )
C
1100	Y = IRAN( 100 ) + 10
	CALL PUTVAL( 3, 1, 4, Y )
	DO 1200 TEMPX = 2, 120
	    X = TEMPX
	    CALL GETVAL( 1, X, Y, IVAL )
	    IF( IVAL .LT. 18 .AND. X .EQ. 2 ) GOTO 1100
	    IF( IVAL .LE. 17 ) GOTO 1300
1200	CONTINUE
1300	X = X - 1
	CALL PUTVAL( 3, 1, 3, X )
	CALL GETVAL( 1, X, Y-1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X+1, Y-1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X, Y+1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X+1, Y+1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
C
C***	PUT SECOND PORT IN DATA BASE (MAKE UP ITS COORDINATES)
C
	CALL PUTVAL( 3, 2, 1, SNAME2( 1 ) )
	CALL PUTVAL( 3, 2, 2, SNAME2( 2 ) )
C
1400	Y = IRAN( 100 ) + 10
	CALL PUTVAL( 3, 2, 4, Y )
	DO 1500 TEMPX = 119, 1, -1
	    X = TEMPX
	    CALL GETVAL( 1, X, Y, IVAL )
	    IF( IVAL .LT. 18 .AND. X .EQ. 119 ) GOTO 1400
	    IF( IVAL .LE. 17 ) GOTO 1600
1500	CONTINUE
1600	X = X + 1
	CALL PUTVAL( 3, 2, 3, X )
	CALL GETVAL( 1, X, Y-1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X-1, Y-1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X, Y+1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
	CALL GETVAL( 1, X-1, Y+1, IVAL )
	IF( IVAL .GE. 18 )  CALL PUTVAL( -1, 17 )
C
C***	UNLOCK DATA BASE SO OTHERS MAY PLAY AND RETURN
C
	IF( DEBUG )CALL COLCUR( 1, 6 )
	IF( DEBUG )CALL STRING('[Initialization completed]^M^J^E')
	CALL UNLOCK
	RETURN
	END
	SUBROUTINE EDIT( COMARA, LENGTH )
	IMPLICIT INTEGER (A-Z)
	INTEGER COMARA( 60 )

	CALL STRING('Array #^E')
	IF( LENGTH .EQ. 0 ) GOTO 100
	CALL GETNUM( COMARA, LENGTH, I1, 10, I2, 10, I3, 10, I4, 10 )
100	IF( I1 .GT. 3 ) GOTO 200
	CALL NUMBER( I1 )
	CALL CHROUT('(')
	CALL NUMBER( I2 )
	CALL CHROUT(',')
	CALL NUMBER( I3 )
	CALL GETVAL( I1, I2, I3, IVAL )
	GOTO 300
200	CALL NUMBER( I1 )
	CALL CHROUT('(')
	CALL NUMBER( I2 )
	CALL GETVAL( I1, I2, IVAL )
300	CALL STRING(') = ^E')
	CALL NUMBER( ILEFT( IVAL ) )
	CALL STRING(',,^E')
	CALL NUMBER( IRIGHT( IVAL ) )
	CALL STRING('  Octal: ^E')
	CALL NUMBER( ILEFT( IVAL ), 0, 8 )
	CALL STRING(',,^E')
	CALL NUMBER( IRIGHT( IVAL ), 0, 8 )
	CALL STRING('  Sixbit: ^E')
	CALL STRING( IVAL, 6, 6 )
	IF( COMARA(1) .NE. 'C' ) RETURN
	IF( I1 .LE. 3 ) CALL PUTVAL( -I1, I4 )
	IF( I1 .GT. 3 ) CALL PUTVAL( -I1, I3 )
	RETURN
	END
	SUBROUTINE MAP
C
C***	PRINT OUT A GREY-TONE MAP ON THE LINE PRINTER
C
	IMPLICIT INTEGER ( A - Z )
C
	INTEGER SCALE1( 20 ), SCALE2( 20 ), FILESP( 13 ), STNAME(2)
	LOGICAL ERROR
C
	DATA SCALE1/'@','#','*','&','=','+','-',',','.','@',
     & '#','*','&','=','+','-','.',' ',' ',' '/
	DATA SCALE2/'%','%','%','%','@','@','@','@','@',' ',
     & ' ',' ',' ',' ',' ',' ',' ',' ',' ',' '/
C
C***	FIND OUT WHERE PORTS ARE
C
	CALL GETVAL( 3, 1, 3, IP1X )
	CALL GETVAL( 3, 1, 4, IP1Y )
	CALL GETVAL( 3, 1, 1, IP1CS )
	CALL CONVRT( IP1CS, 1, 6, IP1C, 0 )
C	IP1C = SHIFT( IP1C, -30 )
C	IP1C = IP1C + 32
	CALL GETVAL( 3, 2, 3, IP2X )
	CALL GETVAL( 3, 2, 4, IP2Y )
	CALL GETVAL( 3, 2, 1, IP2CS )
	CALL CONVRT( IP2CS, 1, 6, IP2C, 0 )
C	IP2C = SHIFT( IP2C, -30 )
C	IP2C = IP2C + 32
C
C***	FIND OUT WHICH LINE PRINTER THE USER IS CLOSEST TO AND OPEN IT
C
	CALL NODLIN( ITTY( JOB(0) ), I, J )
	IF( I .LT. "30 )  I = "36
	FILESP( 3 )=ISXBIT('LPT00')
	FILESP( 3 ) = FILESP( 3 ) + "10000*(I/"10)
	FILESP( 3 ) = FILESP( 3 ) + "100*MOD( I, 8 )
	FILESP( 4 ) = ISXBIT('OCEAN')
	FILESP( 5 ) = ISXBIT('MAP')
	FILESP( 6 ) = "077
	CALL PPN( P, PN )
	FILESP( 7 ) = P
	FILESP( 8 ) = PN
	CALL OFILE( 2, FILESP, 0 )
	IF( .NOT. ERROR(0) ) GOTO 200
100	CALL STRING('Cannot open ^E')
	CALL OUTSPC( FILESP )
	CALL CRLF
	RETURN
C
200	CALL WFILE( 2, FILESP )
	IF( ERROR(0) ) GOTO 100
	CALL STRING('Generating map on ^E')
	CALL OUTSPC( FILESP )
	CALL CRLF
	CALL OUTBUF( 1 )
	CALL SELECT( 2 )
C
C***	PRINT OUT A HEADING ON THE MAP
C
	DO 300 I = 1, 55
	    CALL CHROUT(' ')
300	CONTINUE
	CALL STRING('***  O c e a n  ***^M^J^J^S     ^E')
C
C***	NOW PRINT OUT THE MAP
C
	DO 400 ITEMP = 10, 110, 10
	    I = ITEMP
	    CALL NUMBER( I, 10 )
400	CONTINUE
	CALL STRING('^M^S    ^E')
C
	DO 500 ITEMP = 1, 122
	    I = ITEMP
	    IF( MOD( I-1, 10 ) .EQ. 0 )  CALL CHROUT('+')
	    IF( MOD( I-1, 10 ) .NE. 0 )  CALL CHROUT('-')
500	CONTINUE
	CALL STRING('^M^E')
C
	DO 1600 YTEMP = 120, 1, -1
	    Y = YTEMP
	    IF( MOD( Y, 10 ) .EQ. 0 ) GOTO 600
	    CALL STRING('^S    |^E')
	    GOTO 700
600	    CALL CHROUT( "23 )
	    CALL NUMBER( Y, 3 )
	    CALL STRING(' +^E')
C
C***	FIRST SCALE
C
700	    DO 1000 XTEMP = 1, 120
		X = XTEMP
		IF( X .EQ. IP1X .AND. Y .EQ. IP1Y ) GOTO 800
		IF( X .EQ. IP2X .AND. Y .EQ. IP2Y ) GOTO 900
		CALL GETVAL( 1, X, Y, DEPTH )
		CALL CHROUT( SCALE1( IRIGHT( DEPTH ) ) )
		GOTO 1000
C
800		CALL CHROUT( IP1C )
		GOTO 1000
C
900		CALL CHROUT( IP2C )
1000	    CONTINUE
	    IF( MOD( Y, 10 ) .NE. 0 ) GOTO 1100
	    CALL STRING('+ ^E')
	    CALL NUMBER( Y )
	    GOTO 1200
C
1100	    CALL CHROUT('|')
C
1200	    CALL STRING('^M     ^E')
C
C***	SECOND SCALE
C
	    DO 1500 XTEMP = 1, 120
		X = XTEMP
		IF( X .EQ. IP1X .AND. Y .EQ. IP1Y ) GOTO 1300
		IF( X .EQ. IP2X .AND. Y .EQ. IP2Y ) GOTO 1400
		CALL GETVAL( 1, X, Y, DEPTH )
		CALL CHROUT( SCALE2( IRIGHT( DEPTH ) ))
		GOTO 1500
C
1300		CALL CHROUT(IP1C)
		GOTO 1500
C
1400		CALL CHROUT(IP2C)
1500	    CONTINUE
1600	CONTINUE
	CALL STRING('^S    ^E')
C
	DO 1700 ITEMP = 1, 122
	    I = ITEMP
	    IF( MOD( I-1, 10 ) .EQ. 0 )  CALL CHROUT('+')
	    IF( MOD( I-1, 10 ) .NE. 0 )  CALL CHROUT('-')
1700	CONTINUE
	CALL STRING('^M^S     ^E')
C
	DO 1800 ITEMP = 10, 120, 10
	    I = ITEMP
	    CALL NUMBER( I, 10 )
1800	CONTINUE
C
C***	PRINT OUT KEY INFORMATION
C
	CALL STRING('^M^S^S
     &                                                         ^E')
	CALL STRING('76543210987654321012^M^S    ^E')
C
C***	PRINT OUT NAME OR PORT # 1 AND ITS COORDINATE
C
	CALL GETVAL( 3, 1, 1, STNAME(1) )
	CALL GETVAL( 3, 1, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL STRING('  ^E')
	CALL NUMBER( IP1X, -3 )
	CALL CHROUT('-')
	CALL NUMBER( IP1Y, -3 )
C
C***	PRINT OUT KEY
C
	CALL STRING('                           Key: ^E')
	DO 1900 ITEMP = 1, 20
	    I = ITEMP
	    CALL CHROUT( SCALE1(I) )
1900	CONTINUE
	CALL STRING('^M
     &                                                         ^E')
	DO 2000 ITEMP = 1, 20
	    I = ITEMP
	    CALL CHROUT( SCALE2(I) )
2000	CONTINUE
C
C***	PRINT OUT NAME OF SECOND PORT AND ITS COORDINATES
C
	CALL STRING('                            ^E')
	CALL GETVAL( 3, 2, 1, STNAME(1) )
	CALL GETVAL( 3, 2, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL STRING('  ^E')
	CALL NUMBER( IP2X, -3 )
	CALL CHROUT('-')
	CALL NUMBER( IP2Y, -3 )
C
C***	CLOSE FILE AND RETURN
C
	CALL CLOSE( 2 )
	CALL SELECT( 1 )
	RETURN
	END
	SUBROUTINE PRINT( KIND )

	INTEGER STNAME(2)
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA
C
C***	PRINT OUT ALL INITIAL INFORMATION FOR USER
C
	IF( ICLWHI .NE. 0 ) GOTO 3
	ICLWHI = 1
	ICLDBL = 2
	ICLRED = 3
	ICLLBL = 4
	ICLPUR = 5
	ICLGRE = 6
	ICLYEL = 7
	ICLBLA = 8

3	CALL CLRSCR
C
	CALL USRSET( "2002, "1 )
C
	CALL CURSOR( 1, 24 )
	CALL PBACK( ICLWHI )
	CALL PCOLOR( ICLWHI )
	CALL REPEAT('-',44)
	CALL DEFCOL
	CALL STRING(' Azimuth:     ^E')
	CALL PBACK( ICLWHI )
	CALL PCOLOR( ICLWHI )
	CALL STRING('----^E')
	DO 100 IY = 1, 19
	    CALL CURSOR( 1, 24-IY )
	    CALL CHROUT('|')
	    IX = 20 - 2 * IFIX( SQRT(100.-(IY-10+0.)^2) + 0.5 )
	    IF( IX .EQ. 0 ) GOTO 51
	    DO 50 I = 1, IX
		CALL CHROUT('@')
50	    CONTINUE
51	    CONTINUE
	    IX1 = 19 + 2 * IFIX( SQRT(100.-(IY-10+0.)^2) + 0.5 )
	    IF( IX1 .GE. 38 ) IX1 = 39
	    IF( IX .GE. IX1-1 ) GOTO 59
	    CALL PBACK( ICLBLA )
	    DO 58 I = IX, IX1-3
		CALL CHROUT( ' ' )
58	    CONTINUE
	    CALL PBACK( ICLWHI )
59	    IF( IX1 .EQ. 39 ) GOTO 61
	    DO 60 I = IX1, 38
		CALL CHROUT('@')
60	    CONTINUE
61	    CONTINUE
	    CALL STRING('||^E')
	    CALL PBACK( ICLBLA )
	    CALL STRING('                     ^E')
	    CALL PBACK( ICLWHI )
	    CALL CHROUT('|')
100	CONTINUE
	CALL CURSOR( 1, 4 )
	CALL REPEAT( '-', 62 )
	CALL COLCUR( 1, 3 )
	IF( KIND .EQ. 5 ) CALL STRING('Eng:            Rdr:
     &    Gtr:                    Msl:                    Sfg:^E')
	IF( KIND .EQ. 5 ) GOTO 105
	CALL STRING('Eng:    Hlm:    Rdr:    Snr:    ^E')
	IF( KIND .EQ. 1 ) CALL STRING('
     &Com:            Msl:    Dep:            Sfg:^E')
	IF( KIND .EQ. 2 ) CALL STRING('
     &Tp1:    Tp2:    Msl:    Dcl:    Bal:    Lsp:^E')
	IF( KIND .EQ. 3 ) CALL STRING('
     &                Msl:    Dep:    Min:    Sfg:^E')
	IF( KIND .EQ. 4 ) CALL STRING('
     &Tp1:    Tp2:                            Sfg:^E')
C
105	CALL COLCUR( 64, 24 )
	CALL STRING('Time:^E')
	CALL COLCUR( 64, 23 )
	CALL STRING('Sector:    -^E')
	CALL COLCUR( 64, 21 )
	CALL STRING('Speed:    (   )^E')
	CALL COLCUR( 64, 20 )
	CALL STRING('Azimuth:    (   )^E')
	CALL COLCUR( 64, 17 )
	CALL STRING('Vol:       (   )^E')
C
C***	PRINT OUT INFORMATION ON PORTS
C
	CALL COLCUR( 64, 12 )
	CALL GETVAL( 3, 1, 1, STNAME(1) )
	CALL GETVAL( 3, 1, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL COLCUR( 64, 11 )
	CALL GETVAL( 3, 1, 3, IX )
	CALL NUMBER( IX, -3 )
	CALL CHROUT( '-' )
	CALL GETVAL( 3, 1, 4, IY )
	CALL NUMBER( IY, -3 )
	CALL STRING(' State:^E')
	CALL COLCUR( 64, 9 )
	CALL GETVAL( 3, 2, 1, STNAME(1) )
	CALL GETVAL( 3, 2, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL COLCUR( 64, 8 )
	CALL GETVAL( 3, 2, 3, IX )
	CALL NUMBER( IX, -3 )
	CALL CHROUT( '-' )
	CALL GETVAL( 3, 2, 4, IY )
	CALL NUMBER( IY, -3 )
	CALL STRING(' State:^E')
C
	CALL COLCUR( 1, 1 )
	CALL STRING('Command:^E')
C
200	IF( KIND .NE. 1 ) GOTO 250
	CALL COLCUR( 64, 18 )
	CALL STRING('Charges:^E')
	CALL COLCUR( 64, 16 )
	CALL STRING('Missiles:^E')
	CALL COLCUR( 64, 15 )
	CALL STRING('Auto fire:^E')
	GOTO 999
C
250	IF( KIND .NE. 2 ) GOTO 300
	CALL COLCUR( 64, 22 )
	CALL STRING('Depth:^E')
	CALL COLCUR( 64, 19 )
	CALL STRING('Pitch:     (   )^E')
	CALL COLCUR( 64, 18 )
	CALL STRING('Ballast:    %^E')
	CALL COLCUR( 64, 16 )
	CALL STRING('Missiles:^E')
	CALL COLCUR( 64, 15 )
	CALL STRING('Torpedos:^E')
	CALL COLCUR( 64, 14 )
	CALL STRING('Hull:    %^E')
	CALL COLCUR( 64, 13 )
	CALL STRING('Water:    %^E')
	CALL COLCUR( 64, 5 )
	CALL STRING('Torp. 1:^E')
	CALL COLCUR( 64, 4 )
	CALL STRING('Torp. 2:^E')
	GOTO 999
C
300	IF( KIND .NE. 3 ) GOTO 400
	CALL COLCUR( 64, 19 )
	CALL STRING('Mines:^E')
	CALL COLCUR( 64, 18 )
	CALL STRING('Charges:^E')
	CALL COLCUR( 64, 16 )
	CALL STRING('Missiles:^E')
	GOTO 999
C
400	IF( KIND .NE. 4 ) GOTO 500
	CALL COLCUR( 64, 15 )
	CALL STRING('Torpedos:^E')
	CALL COLCUR( 64, 5 )
	CALL STRING('Torp. 1:^E')
	CALL COLCUR( 64, 4 )
	CALL STRING('Torp. 2:^E')
	GOTO 999
C
500	IF( KIND .NE. 5 ) GOTO 999
	CALL COLCUR( 64, 22 )
	CALL STRING('Altitude:^E')
	CALL COLCUR( 64, 19 )
	CALL STRING('Pitch:     (   )^E')
	CALL COLCUR( 64, 16 )
	CALL STRING('Missiles:^E')
999	RETURN
	END
	SUBROUTINE COMAND( ICHAR, COMARA, ARRIND )
C
C  --	ROUTINE GET COMMAND FROM USER IF ONE PRESENT.
C
	INTEGER COMARA(61), INDEX, ARRIND, ICHAR
	DATA INDEX/0/
C
C  --	IF THERE IS A CHARACTER OUT GET IT, ELSE, SLEEP FOR
C  --	0.5 SECONDS OR UNTIL ONE IS.
C
10	CALL NAP( 500, "14 )
	CALL CHRBUF( ICHAR )
	IF( ICHAR .EQ. -1 ) RETURN
	IF( ICHAR .EQ. "10 .OR. ICHAR .EQ. "177 ) GOTO 20
	IF( ICHAR .EQ. "25 ) GOTO 40
	IF( ICHAR .EQ. "15 ) GOTO 45
	IF( ICHAR .EQ. "33 .AND. INDEX .EQ. 0 ) GOTO 15
	IF( ICHAR .LT. "40 ) GOTO 10
	IF( INDEX .GE. 60 ) GOTO 50
C
C  --	NOT SPECIAL CHARACTER, PUT IN ARRAY
C
	INDEX = INDEX + 1
	CALL COLCUR( 9 + INDEX, 1 )
	CALL CHROUT( ICHAR )
	CALL OUTBUF( 1 )
	COMARA(INDEX) = ICON( ICHAR )
	GOTO 10
C
C  --	ESCAPE:  REPEAT LAST COMMAND
C
15	IF( COMARA(1) .EQ. 'R' ) INDSTR = 0
	INDEX = INDSTR
	CALL COLCUR( 10, 1 )
	IF( INDEX .NE. 0 )CALL STRING( COMARA, 1, INDEX )

	GOTO 45
C
C  --	DELETE CHARACTER
C
20	CALL COLCUR( 9 + INDEX, 1 )
	CALL CHROUT( ' ' )
	CALL OUTBUF( 1 )
	INDEX = INDEX - 1
	IF( INDEX .LT. 0 ) INDEX = 0
	GOTO 10
C
C  --	DELETE LINE
C
40	CALL COLCUR( 10, 1 )
	DO 43 I = 1, INDEX
	    CALL CHROUT(' ')
43	CONTINUE
	CALL OUTBUF( 1 )
	INDEX = 0
	GOTO 10
C
C  --	CARRIAGE RETURN TYPED
C
45	IF( INDEX .NE. 0 ) GOTO 50
	ICHAR = -1
	GOTO 70
50	COMARA(INDEX + 1) = 0
	CALL COLCUR( 10, 1 )
	DO 60 I = 1, INDEX
	CALL CHROUT(' ')
60	CONTINUE
	CALL ALLCAP( COMARA, 2 )
	ICHAR = COMARA(1)
70	ARRIND = INDEX
	INDSTR = INDEX
	INDEX = 0
	CALL OUTBUF( 1 )
	CALL NAP( 500, 4 )
	RETURN
	END
	SUBROUTINE CEASE( IX, IY, IPLAYR )
C
C***	DELETE USER FROM THE DATA BASE
C
	CALL UNLOCK
	CALL LOCK
	CALL EXPLOD( IX, IY, 18, 0, IVAL )
	CALL ADDVAL( 1, IX, IY, -"1000000*IPLAYR )
	CALL PUTVAL( 2, IPLAYR, 1, 0 )
	CALL GETVAL( 2, IPLAYR, 9, IVAL )
	CALL ADDVAL( 3, IVAL, 5, -1 )
	CALL GETVAL( 2, IPLAYR, 10, IVAL )
	IF( IVAL .EQ. 5 ) GOTO 10
	CALL GETVAL( 4, 1, IVAL )
	CALL ADDVAL( -4, 1 )
	CALL PPN( I, IPN )
	IVAL = IVAL + 1
	CALL PUTVAL( 4, IVAL+1, IPN )
10	CALL USRSET( "2007, "0 )
	CALL USRSET( "2002, "0 )
	CALL USRSET( "2021, "1 )
	CALL COLCUR( 1, 1 )
	CALL CLOSE( 1 )
	CALL UNLOCK
	CALL EXPROG
	END
	SUBROUTINE CLRLIN
C
C***	CLEAR THE INFORMATION LINE AND PREPARE TO PRINT ON IT
C
	CALL COLCUR( 1, 2 )
	DO 100 I = 1, 79
	    CALL CHROUT(' ')
100	CONTINUE
	CALL COLCUR( 1, 2 )
	RETURN
	END
	SUBROUTINE HURT( KIND, IHFAC, IMUCH, DAMAGE )
C
C***	DAMAGE THE USER ACCORDING TO IMUCH
C
	INTEGER DAMAGE( 10, 2 ), ODDS( 50 )
	DATA ODDS/	1, 1, 2, 5, 5, 5, 3, 4, 0, 5,
     &			1, 1, 2, 4, 3, 5, 3, 2, 2, 1,
     &			1, 1, 2, 5, 0, 0, 3, 3, 3, 5,
     &			1, 1, 2, 5, 5, 5, 0, 0, 0, 6,
     &			2, 0, 2, 5, 0, 0, 3, 0, 0, 5 /
C
	IMUCH = IABS( IMUCH )
	DO 200 ITEMP = 1, IMUCH
	    ITHRU = 0
100	    I = IRAN( 10 )
	    IF( IRAN( 8 ) .GT. ODDS( 10*(KIND-1)+I ) ) GOTO 100
	    ITHRU = ITHRU + 1
	    IF( DAMAGE( I, 1 ) .EQ. -1 .AND. ITHRU .LT. 10 ) GOTO 100
	    IF( DAMAGE( I, 1 ) .EQ. -1 ) GOTO 200
	    DAMAGE( I, 1 ) = DAMAGE( I, 1 ) + 1
	    IF( DAMAGE(I,1) .GT. 9 )  DAMAGE( I, 1 ) = -1
200	CONTINUE
	IHFAC = IHFAC - IMUCH
	IF( IHFAC .LT. 0 )  IHFAC = 0
	RETURN
	END
	SUBROUTINE ENDHIM( VICTIM )
C
C***	ROUTINE REMOVES DETACHED JOB FROM DATABASE
C
	INTEGER VICTIM
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL LOCK
	CALL GETVAL( 2, VICTIM, 2, ISX )
	CALL GETVAL( 2, VICTIM, 3, ISY )
	CALL GETVAL( 1, ISX, ISY, IVAL )
	CALL PUTVAL( -1, IRIGHT( IVAL ) )
	CALL GETVAL( 2, VICTIM, 9, IPORT )
	CALL ADDVAL( 3, IPORT, 5, -1 )
	CALL PUTVAL( 2, VICTIM, 1, 0 )
	CALL ADDUSR( -1 )
	CALL UNLOCK
	CALL CLRLIN
	CALL COLSTR(ICLYEL,'*** Job ^E')
	CALL NUMBER( IVAL )
	CALL CHROUT('(')
	CALL CHROUT( IVAL + 64 )
	CALL STRING(') removed from data base ***^E')
	VICTIM = 0
	RETURN
	END
	SUBROUTINE EXPLOD( IX, IY, IZ, IFORCE, IFLAG )
C
C***	SET UP AN EXPLOSION
C
	CALL PUTVAL( 5, 1, IX )
	CALL PUTVAL( 5, 2, IY )
	CALL PUTVAL( 5, 3, IZ )
	CALL PUTVAL( 5, 4, IFORCE )
	IFLAG = 3
	RETURN
	END
	SUBROUTINE SYSWHO( IJOB )
	INTEGER UNAME(2)
	IF( JOB(IJOB) .EQ. 0 ) RETURN
	CALL STRING('Job ^E')
	CALL NUMBER( IJOB )
	CALL CHROUT(' ')
	UNAME(1) = IGTAB( IJOB, "31 )
	UNAME(2) = IGTAB( IJOB, "32 )
	CALL STRING( UNAME, 6, 12 )
	CALL STRING(' [^E')
	CALL NUMBER( ILEFT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL CHROUT(',')
	CALL NUMBER( IRIGHT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL STRING('] ^E')
	CALL STRING(' TTY^E')
	CALL NUMBER( ITTY( IJOB ), 0, 8 )
	CALL STRING(' at ^E')
	CALL NODLIN( ITTY(IJOB), IN, IL )
	CALL STRING( NODE( IN ), 6, 6 )
	CALL CHROUT('(')
	CALL NUMBER( IN, 0, 8 )
	CALL STRING(')^E')
C	CALL STRING(' line ^E')
C	CALL NUMBER( IL, 0, 8 )
C	CALL CHROUT(' ')
C	CALL STRING( JSTAT( IJOB ), 6, 2 )
	RETURN
	END
	SUBROUTINE WHO( ICCHAR )
C
C***	SUBROUTINE PRINTS OUT STATISTICS ON USER
C
	INTEGER UNAME(2)
	CALL CHROUT(' ')
	CALL CHROUT( ICCHAR+64 )
	CALL STRING(': ^E')
	CALL GETVAL( 2, ICCHAR, 10, IVAL )
	CALL PKIND( IVAL )
	IF( IVAL .GT. 1 .AND. IVAL .LT. 5 ) CALL CHROUT(' ')
	CALL CHROUT(' ')
	CALL GETVAL( 2, ICCHAR, 5, UNAME(1) )
	CALL GETVAL( 2, ICCHAR, 6, UNAME(2) )
	CALL STRING( UNAME, 6, 12 )
	CALL GETVAL( 2, ICCHAR, 1, IJOB )
	CALL CHROUT(' ')
	CALL SYSWHO( IJOB )
	CALL CRLF
	RETURN
	END
	SUBROUTINE PKIND( KIND )
C
C***	PRINTS OUT KIND OF SHIP
C
	IF( KIND .EQ. 1 ) CALL STRING('Battleship^E')
	IF( KIND .EQ. 2 ) CALL STRING('Submarine^E')
	IF( KIND .EQ. 3 ) CALL STRING('Destroyer^E')
	IF( KIND .EQ. 4 ) CALL STRING('P.T. boat^E')
	IF( KIND .EQ. 5 ) CALL STRING('Helicopter^E')
	RETURN
	END
	SUBROUTINE NOWAIT
	CALL ADDUSR( -1 )
10	CALL TSTOP
	GOTO 10
	END
	SUBROUTINE FMAIN
C
	LOGICAL INIFLG, SELPRT, EOT, WANMAP, DEBUG, WANNAM, ATOFIR, OFIRE
	LOGICAL NOTFRS, LPRIVD, ERROR, IDOCK
	INTEGER COMARA(60), STNAME(2), DAMAGE(10,2)
	INTEGER PARARA(20), FILSPC(13)
	LOGICAL LOGDIN, NEWANG
	REAL SMSIN, SMCOS

	COMMON/NHCOM/NEWANG
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	DATA ITORP/20/, ICHAR/'N'/, IRADR/-1/, IHFAC/100/
	DATA IDC/20/, IMINE/10/, IMISSL/5/

C
C***	CHECK USER TO SEE IF HE'S WELCOME, SET UP SWITCHES,
C***	INITIALIZE DATABASE AND OPEN TTY
C
	CALL PPN( I, IPN )
	CALL USRSET( "1030, TTYSPD )
	CALL SETTTY( COMARA, PARARA, LENGTH, LPRIVD, FILSPC )
	NEWANG = .TRUE.
	IF( LENGTH .EQ. 0 ) GOTO 100
	IF(ISERCH(PARARA,ISXBIT('MAP'),LENGTH).NE.0) WANMAP = .TRUE.
	IF(ISERCH(PARARA,ISXBIT('OLDANG'),LENGTH).NE.0) NEWANG = .FALSE.
	IF(ISERCH(PARARA,ISXBIT('DEBUG'),LENGTH).NE.0 .AND. LPRIVD )
     &	DEBUG = .TRUE.
	IF(ISERCH(PARARA,ISXBIT('NAME'),LENGTH).NE.0 .AND. LPRIVD )
     &	DEBUG = .TRUE.

C***	DEFINED KINDS OF CRAFT AND THEIR POWERS ARE:
C
C***	KIND	MAXSPEED	TYPE		WEAPONS
C***	1	10		BATTLESHIP (2*GS, 20TRP, 20DC, 10MIS)
C***	2	20		SUBMARINE  (20TRP, 5MIS)
C***	3	30		DESTROYER  (1G, 20DC, 5MIS, 5MIN)
C***	4	40		P.T. BOAT  (1G, 4TRP)
C***	5	50		HELICOPTER (1G, 15MIS)
C
	IF(ISERCH(PARARA,ISXBIT('BATTLE'),LENGTH).NE.0) KIND = 1
	IF(ISERCH(PARARA,ISXBIT('SUBMAR'),LENGTH).NE.0) KIND = 2
	IF(ISERCH(PARARA,ISXBIT('DESTRO'),LENGTH).NE.0) KIND = 3
	IF(ISERCH(PARARA,ISXBIT('PT'),LENGTH).NE.0) KIND = 4
	IF(ISERCH(PARARA,ISXBIT('HELICO'),LENGTH).NE.0) KIND = 5
	IF(ISERCH(PARARA,ISXBIT('PORT'),LENGTH).NE.0)SELPRT = .TRUE.
100	CALL CTRAP
	CALL NOWAIT
	CALL CHECK( INIFLG )
	IF( .NOT. INIFLG ) GOTO 150
	CALL CTRAP
	CALL STRING('^M^JPlease wait for initialization^M^J^E')
	CALL INITDB( DEBUG, WANNAM )
C
150	NOTFRS = .FALSE.
	CALL GETVAL( 4, 1, IVAL )
	IF(IVAL.EQ.0 .OR. IPN.EQ."17433 ) GOTO 201
	DO 200 I = 1, IVAL
	    CALL GETVAL( 4, I+1, ICPN )
	    IF( ICPN .EQ. IPN ) NOTFRS = .TRUE.
200	CONTINUE
201	CONTINUE
C
	CALL OFILE( 1, ISXBIT('TTY'), "10 )
	IF( ERROR(0) )  RETURN
	CALL SELECT( 1 )
C
C***	IF THE USER WANTS A MAP, GIVE IT TO HIM
C
	CALL ENABLE
	IF( WANMAP ) CALL MAP
C
C***	SET UP USER'S PORT OR ASK HIM WHO'S SIDE HE'S ON
C
	IF( SELPRT ) GOTO 210
	CALL GETVAL( 3, 1, 5, IP1 )
	CALL GETVAL( 3, 2, 5, IP2 )
	IF( IP1 .LT. IP2 )  IPORT = 1
	IF( IP2 .LT. IP1 )  IPORT = 2
	IF( IP1 .EQ. IP2 )  IPORT = IRAN( 2 )
	GOTO 290
C
210	CALL STRING('1: ^E')
	CALL GETVAL( 3, 1, 1, STNAME(1) )
	CALL GETVAL( 3, 1, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL CRLF
	DO 220 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 220
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .EQ. 1 ) CALL WHO(I)
220	CONTINUE
C
	CALL STRING('2: ^E')
	CALL GETVAL( 3, 2, 1, STNAME(1) )
	CALL GETVAL( 3, 2, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL CRLF
	DO 230 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 230
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .EQ. 2 ) CALL WHO(I)
230	CONTINUE
C
240	CALL STRING('^MPort (1 or 2):        ^MPort (1 or 2): ^E')
	CALL OUTBUF( 1 )
	CALL CHRWAT( IPORT )
	IPORT = IPORT - 48
	IF( IPORT .NE. 1 .AND. IPORT .NE. 2 ) GOTO 240
	CALL CRLF
C
C***	IF USER HASN'T CHOSEN HIS TYPE OF SHIP, ASK HIM
C
290	IF( NOTFRS ) KIND = 5
	IF( KIND .NE. 0 ) GOTO 400
	DO 300 ITEMP = 1, 5
	    I = ITEMP
	    CALL NUMBER( I )
	    CALL STRING(': ^E')
	    CALL PKIND( I )
	    CALL CRLF
300	CONTINUE
301	CONTINUE
	CALL STRING('^MEnter ship type ( 1, 2, 3, 4 or 5 ):        ^M
     &Enter ship type ( 1, 2, 3, 4 or 5 ): ^E')
	CALL OUTBUF( 1 )
	CALL CHRWAT( KIND )
	KIND = KIND - 48
	IF( KIND .GT. 5 .OR. KIND .LT. 1 ) GOTO 301
	CALL CRLF
C
C***	GET SHIP'S NAME
C
400	CALL PKIND( KIND )
	CALL STRING('''s name: ^E')
	CALL OUTBUF( 1 )
	CALL GETSTR( COMARA, 12, LENGTH )
	CALL CONVRT( COMARA, 12, 1, STNAME, 6 )
	DO 500 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 500
	    CALL GETVAL( 2, I, 5, NAME1 )
	    CALL GETVAL( 2, I, 6, NAME2 )
	    IF(STNAME(1).NE.NAME1 .OR. STNAME(2).NE.NAME2) GOTO 500
	    CALL STRING('Craft name is already in use.  ^E')
	    GOTO 400
500	CONTINUE
C
C***	GET SHIP'S SCAN CHARACTER
C
600	CALL STRING('^MInput character to represent the "^E')
	IF( LENGTH .GT. 0 )CALL STRING( COMARA, 1, LENGTH )
	CALL STRING('" in scan:    ^E')
	CALL STRING('^MInput character to represent the "^E')
	IF( LENGTH .GT. 0 ) CALL STRING( COMARA, 1, LENGTH )
	CALL STRING('" in scan: ^E')
	CALL OUTBUF( 1 )
	CALL CHRWAT( IPLAYR )
	IF( IPLAYR .GT. 91 ) IPLAYR = IPLAYR - 32
	IPLAYR = IPLAYR - 64
	IF( IPLAYR .LT. 1 .OR. IPLAYR .GT. 26 ) GOTO 600
	CALL GETVAL( 2, IPLAYR, 1, I )
	IF( I .NE. 0 ) GOTO 600
	CALL CRLF
C
	CALL PUTVAL( 2, IPLAYR, 5, STNAME(1) )
	CALL PUTVAL( 2, IPLAYR, 6, STNAME(2) )
	CALL PUTVAL( 2, IPLAYR, 1, JOB(0) )
	CALL ADDVAL( 3, IPORT, 5, 1 )
	CALL PUTVAL( 2, IPLAYR, 9, IPORT )
	IF( KIND .LT. 4 ) CALL PUTVAL( 5, 4+IPORT, 1 )
	CALL PUTVAL( 2, IPLAYR, 10, KIND )
	IF( KIND .EQ. 1 ) IMISSL = 12
	IF( KIND .EQ. 4 ) ITORP = 4
	IF( KIND .EQ. 5 ) IMISSL = 15
C
C***	FIND OUT WHERE THE PORTS ARE
C
	CALL GETVAL( 3, 1, 3, IPRTX1 )
	CALL GETVAL( 3, 1, 4, IPRTY1 )
	CALL GETVAL( 3, 2, 3, IPRTX2 )
	CALL GETVAL( 3, 2, 4, IPRTY2 )
C
C***	MAKE UP SHIP COORDINATES
C
1000	ISHIPX = IRAN( 120 )
	ISHIPY = IRAN( 120 )
	IDEPTH = 18
	IF( KIND .EQ. 2 ) IDEPTH = IRAN( 17 ) + 1
	IF( KIND .EQ. 5 ) IDEPTH = IRAN( 16 ) + 18
	CALL GETVAL( 1, ISHIPX, ISHIPY, IVAL )
	IF( IVAL .GE. IDEPTH ) GOTO 1000
	IF(( IPORT .EQ. 1 .AND.
     &	SQRT((ISHIPX-IPRTX2+0.)^2+(ISHIPY-IPRTY2+0.)^2) .LE. 25 ) .OR.
     &	(IPORT .EQ. 2 .AND.
     &	SQRT((ISHIPX-IPRTX1+0.)^2+(ISHIPY-IPRTY1+0.)^2) .LE. 25 ))
     & GOTO 1000
	SHIPX = ISHIPX
	SHIPY = ISHIPY
	DEPTH = IDEPTH
	CALL ADDVAL( -1, IPLAYR*"1000000 )
	CALL PUTVAL( 2, IPLAYR, 2, ISHIPX )
	CALL PUTVAL( 2, IPLAYR, 3, ISHIPY )
	CALL PUTVAL( 2, IPLAYR, 4, IDEPTH )
	CALL PUTVAL( 2, IPLAYR, 8, 0 )
	IAZ = IRAN( 360 )
	ITAZ = IAZ
C
C***	SET UP TERMINAL CHARACTERISTICS
C
	CALL USRSET( "2006, "1 )
	CALL USRSET( "2025, "0 )
	CALL USRSET( "2007, "1 )
	CALL USRSET( "2010, "1 )
	CALL USRSET( "2021, "0 )
C
C***	AND SET IT UP SO THE USER CAN ^C OUT IF HE WANTS
C
	CALL CTRAP
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C*************************************
C***	BEGINNING OF GAME LOOP    ****
C*************************************
C
1100	IF(IGTAB("54,"11)*100/IGTAB("50,"11).LE.85.OR.IPN.EQ."17433)
     &	GOTO 1101
	CALL CLRSCR
	CALL COLCUR( 20, 1 )
	CALL STRING('^I^I** EMERGENCY **^M^J^JCRITICAL:^M^J^J^E')
	CALL STRING('As you stare out to sea, you notice a^M^J^J
     &large dotted white line labeled "S T Y X L I N E".  When^M^J^J
     &your vessel crosses it, you exit to the monitor.^M^J^J^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
1101	CALL USRSET( "2030, TTYSPD )
	CALL USRSET( "2031, TTYSPD )
	IF( ICHAR .EQ. 'N' )  CALL PRINT( KIND )
	IF(DAMAGE(5,1).EQ.0.AND.DAMAGE(10,1).EQ.0)GOTO 1103
	IF( .NOT. ATOFIR .OR. KIND .NE. 1 ) GOTO 1103
	ATOFIR = .FALSE.
C
C***	CHECK TO SEE IF THE GAME HAS ENDED (A PORT HAS BEEN DESTROYED)
C
1103	CALL GETVAL( 3, IPORT, 6, IVAL )
	IF( IVAL .LT. 7 ) GOTO 1200
	CALL CLRLIN
	CALL COLSTR
     &(ICLRED,'***** Your port has been destroyed *****^G^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
1200	CALL GETVAL( 3, 3-IPORT, 6, IVAL )
	IF( IVAL .LT. 7 ) GOTO 1300
	CALL CLRLIN
	CALL COLSTR
     &(ICLLBL,'***** The enemy port has been destroyed *****^G^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C***	CHECK TO SEE IF ALL THE OPPONENTS ARE GONE
C
1300	CALL GETVAL( 5, 7-IPORT, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 1350
	DO 1330 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 1330
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .EQ. IPORT ) GOTO 1330
	    CALL GETVAL( 2, I, 10, IVAL )
	    IF( IVAL .NE. 0 .AND. IVAL .LT. 5 ) GOTO 1350
1330	CONTINUE
	CALL CLRLIN
	CALL COLSTR(ICLLBL,
     &'*** There are no more major opponents. ***^G^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C***	IF USER IS DAMAGED BEYOND REPAIR (OR HOPES OF GETTING TO
C***	PORT) DESTROY HIM
C
1350	IF( DAMAGE(1,1) .EQ. -1 .OR. DAMAGE(2,1) .EQ. -1 ) GOTO 1360
	IF( KIND .EQ. 5 .AND. DAMAGE(1,1) .NE. 0 ) GOTO 1360
	IF( KIND .NE. 2 .OR. ( DAMAGE(10,1) .NE. -1 .AND.
     &( DAMAGE(8,1) .NE. -1 .OR. DAMAGE(9,1) .NE. -1 .OR.
     & IDEPTH .EQ. 18 ) ) ) GOTO 1400
1360	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** Fatal damage to ship.  You lose ***^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C***	CHECK TO SEE IF SHIP WAS HIT BY SOMETHING
C
1400	CALL GETVAL( 2, IPLAYR, 8, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 1500
	CALL PUTVAL( -1, 0 )
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' struck by a ^E')
	IF( IVAL .EQ. 5 ) CALL STRING('ATS missile^E')
	IF( IVAL .EQ. 10 )  CALL STRING('torpedo ***^E')
	IF( IVAL .EQ. 11 ) CALL STRING('shell ***^E')
	IF( IVAL .EQ. 15 ) CALL STRING('battleship shell ***^E')
	IF( IVAL .EQ. 20 )  CALL STRING('STP missile ***^E')
	CALL HURT( KIND, IHFAC, IVAL, DAMAGE )
C
C***	CHECK TO SEE IF THERE WAS AN EXPLOSION AROUND
C
1500	CALL GETVAL( 5, 1, IEX )
	CALL GETVAL( 5, 2, IEY )
	CALL GETVAL( 5, 3, IED )
	CALL GETVAL( 5, 4, IEF )
	DIST=SQRT((IEX-ISHIPX+0.)^2+(IEY-ISHIPY+0.)^2+(IED-IDEPTH+0.)^2)
	IF( DIST .GT. IEF .OR. IEF .EQ. 0 ) GOTO 1600
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' experiences explosive turbulance ***^E')
	CALL HURT( KIND, IHFAC, IFIX( IEF*4./(DIST+1.) ), DAMAGE )
C
C***	CHECK TO SEE IF THE HULL HAS CRACKED
C
1600	IF( IHFAC .GE. IDFAC ) GOTO 1700
	IF( IRAN( 100*IDFAC/IHFAC ) .LT. 97 ) GOTO 1700
	CALL CLRLIN
	CALL COLSTR(ICLRED,
     & '*** Water pressure has cracked the hull ***^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C***	MOVE THE SHIP USING HOME MADE TRIGONOMETRY
C
1700	CALL ADDVAL( 1, ISHIPX, ISHIPY, -IPLAYR*"1000000 )
	OSHIPX = SHIPX
	OSHIPY = SHIPY
	ODEPTH = DEPTH
1750	SHIPX = SHIPX + SMCOS(FLOAT(IAZ))*COSDEG(FLOAT(IPITCH))
     & *FLOAT(ISPEED)/30.0
	IF( SHIPX .LT. 0.5 .OR. SHIPX .GT. 120.5 ) SHIPX = OSHIPX
	ISHIPX = SHIPX + 0.5
	SHIPY = SHIPY + SMSIN(FLOAT(IAZ))*COSDEG(FLOAT(IPITCH))
     & *FLOAT(ISPEED)/30.0
	IF( SHIPY .LT. 0.5 .OR. SHIPY .GT. 120.5 ) SHIPY = OSHIPY
	ISHIPY = SHIPY + 0.5
	DEPTH = DEPTH + SINDEG(FLOAT(IPITCH))*FLOAT(ISPEED)/30.0
	DFACTR = (18.0-16.0*FLOAT(IBAL)/100.0-DEPTH)*0.014
	DEPTH = DEPTH + DFACTR
	IF( KIND .EQ. 2 .AND. DEPTH .GT. 18 ) DEPTH = 18
	IF( KIND .EQ. 5 .AND. DEPTH .GT. 35.5 ) DEPTH = 35.0
	IF( KIND .NE. 2 .AND. KIND .NE. 5 ) DEPTH = 18
	IDEPTH = DEPTH + 0.5
	IF( DAMAGE( 9, 1 ) .NE. 0 .OR. KIND .NE. 2 )
     & IBAL = -100.*(DEPTH-18.)/16.
	IF( IBAL .LT. 0 .AND. KIND .NE. 5 ) IBAL = 0
C
C***	CHECK TO SEE IF SHIP HIT SOMETHING
C
	CALL GETVAL( 1, ISHIPX, ISHIPY, IVAL )
	IF( KIND .NE. 5 .OR. IDEPTH .GT. 18 .OR.
     & IRIGHT(IVAL) .EQ. 18 ) GOTO 1760
	CALL CLRLIN
	CALL COLSTR(ICLRED,
     & '*** Helicopter has hit water and sunk ***^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
1760	IF( ILEFT( IVAL ) .NE. 0 .AND. IRIGHT( IVAL ) .LT. IDEPTH )
     &	    GOTO 2100
	IF( IRIGHT(IVAL) .LT. IDEPTH ) GOTO 2200
C
C***	HE EITHER HIT A ROCK OR HE IS DOCKING
C
	IDOCK = ISPEED .GT. 0 .AND. ISPEED .LT. 6 .AND. (
     & ( ISHIPX .EQ. IPRTX1 .AND. ISHIPY .EQ. IPRTY1 ) .OR.
     & ( ISHIPX .EQ. IPRTX2 .AND. ISHIPY .EQ. IPRTY2 ) )
	IF( .NOT. IDOCK ) GOTO 1762
	IAZ = IAZ + 180
	IF( IAZ .GT. 359 ) IAZ = IAZ - 360
	ITAZ = IAZ
	
1762	IF( .NOT. IDOCK )
     &CALL HURT( KIND, IHFAC, IABS(ISPEED)-IFIX(DFACTR*200.), DAMAGE )
	SHIPX = OSHIPX
	ISHIPX = SHIPX + .5
	SHIPY = OSHIPY
	ISHIPY = SHIPY + .5
	IF( KIND .EQ. 5 .AND. ODEPTH .LT. 18.9 ) ODEPTH = 19.
	DEPTH = ODEPTH
	IDEPTH = DEPTH + 0.5
	IBAL = -100.*(DEPTH-18.)/16.
	ISPEED = 0
	ITSPD = 0
	CALL CLRLIN
	IF( IDOCK ) GOTO 1800
	CALL COLSTR(ICLRED,'*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' hits a rock ***^E')
	GOTO 2200
C
C***	IF USER IS IN OPPONENTS PORT, DEFECT HIM
C
1800	IF( ( IPORT .EQ. 1 .AND. IABS( ISHIPX-IPRTX1 )
     & .LT. 2 .AND. IABS( ISHIPY-IPRTY1 ) .LT. 2 )
     & .OR. ( IPORT .EQ. 2 .AND. IABS( ISHIPX-IPRTX2 )
     & .LT. 2 .AND. IABS( ISHIPY-IPRTY2 ) .LT. 2 ) ) GOTO 1900
	IDFECT = IDFECT + 1
	IF( IDFECT .GT. 1 ) GOTO 9100
	CALL COLSTR(ICLRED,'*** You have defected ^E')
	CALL ADDVAL( 3, IPORT, 5, -1 )
	IPORT =3-IPORT
	CALL ADDVAL( 3, IPORT, 5, 1 )
	CALL PUTVAL( 2, IPLAYR, 9, IPORT )
C
C***	IF CRAFT IS IN PORT, REPAIR AND RESUPPLY SHIP
C
1900	IF( NKIND .EQ. 0 ) GOTO 1902
	KIND = NKIND
	CALL PRINT( KIND )
	ICHAR = 'N'
	CALL COLCUR( 1, 2 )
1902	CALL PUTVAL( 2, IPLAYR, 10, KIND )
	CALL COLSTR(ICLLBL,'*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' is in port ***^E')
	CALL GETVAL( 3, IPORT, 6, IVAL )
	IF( IVAL .GE. 2 ) GOTO 2200
	CALL STRING(' Supplies boarding ***^E')
	ITORP = 20
	IF( KIND .EQ. 4 ) ITORP = 4
	IMISSL = 5
	IF( KIND .EQ. 1 ) IMISSL = 12
	IF( KIND .EQ. 5 ) IMISSL = 15
	IDC = 20
	IMINE = 10
	DO 2000 I = 1, 10
	    DAMAGE( I, 1 ) = 0
2000	CONTINUE
	IHFAC = 100
	GOTO 2200
C
C***	****** KLUGE ****** SHIP CANNOT BE AT SAME X-Y AS ANOTHER
C***	SHIP.  ( UNFORTUNATE RESULT OF 2-DIMENSIONAL ARRAYS )
C
2100	IF( ILEFT( IVAL ) .GT. 26 ) GOTO 2150
	CALL GETVAL( 2, ILEFT( IVAL ), 4, ITDEP )
	IF( ITDEP .NE. IDEPTH ) GOTO 1750
C
	CALL HURT( KIND,IHFAC,IABS(ISPEED)-IFIX(DFACTR*200.),DAMAGE )
	SHIPX = OSHIPX
	ISHIPX = SHIPX + .5
	SHIPY = OSHIPY
	ISHIPY = SHIPY + .5
	DEPTH = ODEPTH
	IDEPTH = DEPTH + 0.5
	IBAL = -100.*(DEPTH-18.)/16.
	ISPEED = 0
	ITSPD = 0
	CALL CLRLIN
	CALL STRING('Collision with the ^E')
	CALL GETVAL( 2, ILEFT( IVAL ), 5, STNAME(1) )
	CALL GETVAL( 2, ILEFT( IVAL ), 6, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	GOTO 1750
C
2150	IF( IDEPTH .GT. 18 ) GOTO 1750
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' has hit a mine ***^E')
	CALL EXPLOD( ISHIPX, ISHIPY, 18, 5, IEXFLG )
	CALL PUTVAL( 1, ISHIPX, ISHIPY, IRIGHT( IVAL ) )
C
C***	PLACE SHIP IN HISEGMENT
C
2200	CALL ADDVAL( 1, ISHIPX, ISHIPY, IPLAYR*"1000000 )
	IF( KIND.LT.5 )
     & CALL PUTVAL( 2, IPLAYR, 7, IABS(ISPEED)*5000/KIND+100)
	IF(KIND.EQ.5)CALL PUTVAL(2,IPLAYR,7,IABS(ISPEED)/10+1)
	CALL PUTVAL( 2, IPLAYR, 2, ISHIPX )
	CALL PUTVAL( 2, IPLAYR, 3, ISHIPY )
	CALL PUTVAL( 2, IPLAYR, 4, IDEPTH )
C
C***	CHECK TO SEE IF SHIP WAS HIT BY A PORT-TO-SHIP MISSILE
C
	IF( IPORT .EQ. 1 )
     & IDIST = SQRT( (ISHIPX-IPRTX2+0.)^2 + (ISHIPY-IPRTY2+0.)^2 )
	IF( IPORT .EQ. 2 )
     & IDIST = SQRT( (ISHIPX-IPRTX1+0.)^2 + (ISHIPY-IPRTY1+0.)^2 )
	IF( IDIST .GE. 25 ) GOTO 2300
	IF( IDEPTH .LT. 18 ) IDIST = IDIST ^ ( 19-IDEPTH )
	CALL GETVAL( 3, 3-IPORT, 6, IVAL )
	IF( IVAL .GE. 5 .OR. IRAN(IDIST*3) .NE. 1 ) GOTO 2300
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** Ship hit by PTS missile ***^E')
	CALL HURT( KIND, IHFAC, 15, DAMAGE )
C
C***	INCREMENT TORPEDO & TIME COUNTERS
C
2300	IF( I1TORP .GT. 0 .AND. DAMAGE( 5, 1 ) .EQ. 0 )
     & I1TORP = I1TORP - 1
	IF( I2TORP .GT. 0 .AND. DAMAGE( 6, 1 ) .EQ. 0 )
     & I2TORP = I2TORP - 1
	ITURN = ITURN + 1
	IEXFLG = IEXFLG - 1
	IF( IEXFLG .EQ. 0 ) CALL PUTVAL( 5, 4, 0 )
2400	IF( ITURN .NE. 15 ) GOTO 2501
	ITURN = 0
	EOT = .NOT. ( EOT )
C
C***	IF THE SECOND HAND IS ON THE ZERO, DECREMENT DAMAGE
C***	(INCIDENTLY, THERE ARE 15 SECONDS TO A MINUTE AROUND HERE)
C
	DO 2500 I = 1, 10
	    IF( DAMAGE( I, 1 ) .GT. 0 )
     &		DAMAGE( I, 1 ) = DAMAGE( I, 1 ) - 1
2500	CONTINUE
2501	CONTINUE
C
C***	UPDATE SPEED, AZIMUTH & PITCH INCREMENTS
C
	IF( ISPEED .GT. ITSPD )  ISPEED = ISPEED - KIND
	IF( ISPEED .LT. ITSPD )  ISPEED = ISPEED + KIND
	IF( IABS(ISPEED-ITSPD) .LT. KIND ) ISPEED = ITSPD
	INC = 2^KIND
	IF( ISPEED .EQ. 0 .AND. KIND .NE. 5 ) INC = 0
	IF( .NOT. ((ITAZ-IAZ.GT.0.AND.ITAZ-IAZ.LT.180) .OR.
     & (ITAZ-IAZ.GT.-360.AND.ITAZ-IAZ.LT.-180)) )  INC = -INC
	IAZ = IAZ + INC
	IAZ = MOD( IAZ, 360 )
	IF( IAZ .LT. 0 )  IAZ = IAZ + 360
	IF(IABS(IAZ-ITAZ).LT.IABS(INC)+1.OR.
     &IABS(IAZ-360-ITAZ).LT.IABS(INC)+1) IAZ = ITAZ
	INC = 0
	IF( KIND .EQ. 2 .AND. ISPEED .NE. 0 ) INC = 10
	IF( KIND .EQ. 5 ) INC = 20
	IF( IPITCH .LT. ITPTCH ) IPITCH = IPITCH + INC
	IF( IPITCH .GT. ITPTCH ) IPITCH = IPITCH - INC
	IF( IABS(IPITCH-ITPTCH) .LT. INC ) IPITCH = ITPTCH
C
C***	GET ANY MESSAGES FOR THE SHIP
C
	CALL GETVAL( 6, 1, IVAL )
	IF( IVAL .NE. IPLAYR ) GOTO 2700
	CALL LOCK
	CALL PUTVAL( -6, 0 )
	CALL CLRLIN
	CALL GETVAL( 6, 3, IVAL )
	CALL CHROUT( IVAL+64 )
	CALL STRING(': - ^G^E')
	CALL GETVAL( 6, 2, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 2601
	DO 2600 I = 1, IVAL
	    CALL GETVAL( 6, I+3, ICCHAR )
	    CALL CHROUT( ICCHAR )
2600	CONTINUE
2601	CONTINUE
	CALL UNLOCK
C
C***	DECREMENT HULL-STRESS FACTOR IF DEEP (SUBMARINE)
C
2700	IF( IDEPTH .LT. 5 .AND. IHFAC .NE. 100 )
     & IHFAC = IHFAC - 5 + IDEPTH
	IF( IHFAC .LT. 0 )  IHFAC = 0
	IDFAC = (18.0-DEPTH) * 5.0
	IF( IDFAC .LT. 0 )  IDFAC = 0
C
C********************************************************
C***	UPDATE ALL SENSORS AND SCREEN INFORMATION    ****
C********************************************************
C
C***	UPDATE TIME OF DAY
C
	CALL DATIME( I, I, I, IHOUR, IMIN, ISEC, I )
	CALL COLCUR( 70, 24 )
	CALL NUMBER( IHOUR, -2 )
	CALL CHROUT(':')
	CALL NUMBER( IMIN, -2 )
	CALL CHROUT(':')
	CALL NUMBER( ISEC, -2 )
C
C***	UPDATE SECTOR (X)
C
	IF( ISHIPX .EQ. IOSHPX .AND. ICHAR .NE. 'N' ) GOTO 2800
	CALL COLCUR( 72, 23 )
	CALL NUMBER( ISHIPX, -3 )
	IOSHPX = ISHIPX
C
C***	UPDATE SECTOR (Y)
C
2800	IF( ISHIPY .EQ. IOSHPY .AND. ICHAR .NE. 'N' ) GOTO 2900
	CALL COLCUR( 76, 23 )
	CALL NUMBER( ISHIPY, -3 )
	IOSHPY = ISHIPY
C
C***	UPDATE DEPTH (SUBMARINE,HELICOPTER)
C
2900	IF((IDEPTH.EQ.IODEP .AND. ICHAR.NE.'N') .OR.
     & KIND.NE.2 .AND. KIND.NE.5)GOTO 3000
	IF( KIND .EQ. 2 ) CALL COLCUR( 70, 22 )
	IF( KIND .EQ. 5 ) CALL COLCUR( 74, 22 )
	IF( KIND .EQ. 2 ) CALL NUMBER( 18-IDEPTH, 4 )
	IF( KIND .EQ. 5 ) CALL NUMBER( IDEPTH-18, 4 )
	IODEP = IDEPTH
C
C***	UPDATE RADAR AND SONAR
C
3000	IF( IRADR .LT. 0 ) GOTO 3005
	IRADR = IRADR + IRADNC
	IF( IRADR .LT. 0 ) IRADR = IRADR + 360
	IF( IRADR .GT. 360 ) IRADR = IRADR - 360
	IF( IRADTO .LT. 0 .OR. IRADNC .EQ. 0 ) GOTO 3002
	IF( IABS( IRADR-IRADTO ) .LT. IABS(IRADNC) ) IRADR = IRADTO
	IF( IABS( IRADR-IRADTO ) .GT. 360-IABS(IRADNC) ) IRADR = IRADTO
	IF( IRADR .EQ. IRADTO ) IRADNC = 0
3002	CALL DISPLA(ISHIPX,ISHIPY,IDEPTH,IRADR,ICHAR,DAMAGE,KIND,IPORT)
	GOTO 3006
3005	CALL DISPLA(ISHIPX,ISHIPY,IDEPTH,IAZ,ICHAR,DAMAGE,KIND,IPORT)
C
C***	UPDATE SPEED
C
3006	IF( ISPEED .EQ. IOSPED .AND. ICHAR .NE. 'N' ) GOTO 3100
	CALL COLCUR( 71, 21 )
	CALL NUMBER( ISPEED, 3 )
	IOSPED = ISPEED
C
C***	UPDATE DESIRED SPEED
C
3100	IF( ITSPD .EQ. IOTSPD .AND. ICHAR .NE. 'N' ) GOTO 3200
	CALL COLCUR( 75, 21 )
	CALL NUMBER( ITSPD, 3 )
	IOTSPD = ITSPD
C
C***	UPDATE AZIMUTH
C
3200	IF( IAZ .EQ. IOAZ .AND. ICHAR .NE. 'N' ) GOTO 3300
	CALL COLCUR( 73, 20 )
	CALL NUMBER( IAZ, 3 )
	IOAZ = IAZ
C
C***	UPDATE DESIRED AZIMUTH
C
3300	IF( ITAZ .EQ. IOTAZ .AND. ICHAR .NE. 'N' ) GOTO 3400
	CALL COLCUR( 77, 20 )
	CALL NUMBER( ITAZ, 3 )
	IOTAZ = ITAZ
C
C***	UPDATE PITCH (SUBMARINE,HELICOPTER)
C
3400	IF((IPITCH.EQ.IOPTCH .AND. ICHAR.NE.'N') .OR.
     & (KIND.NE.2 .AND. KIND.NE.5))GOTO 3450
	CALL COLCUR( 71, 19 )
	CALL NUMBER( IPITCH, 3 )
	IOPTCH = IPITCH
C
C***	UPDATE DESIRED PITCH (SUBMARINE,HELICOPTER)
C
3450	IF((ITPTCH.EQ.IOTPCH .AND. ICHAR.NE.'N') .OR.
     & (KIND.NE.2 .AND. KIND.NE.5))GOTO 3500
	CALL COLCUR( 76, 19 )
	CALL NUMBER( ITPTCH, 3 )
	IOTPCH = ITPTCH
C
C***	UPDATE MINES (DESTROYER)
C
3500	IF((IMINE.EQ.IOMINE.AND.ICHAR.NE.'N').OR.KIND.NE.3)GOTO 3550
	CALL COLCUR( 71, 19 )
	CALL NUMBER( IMINE, 2 )
	IOMINE = IMINE
C
C***	UPDATE BALLAST (SUBMARINE)
C
3550	IF((IBAL.EQ.IOBAL.AND.ICHAR.NE.'N').OR.KIND.NE.2)GOTO 3600
	CALL COLCUR( 73, 18 )
	CALL NUMBER( IBAL, 3 )
	IOBAL = IBAL
C
C***	UPDATE DEPTH CHARGES (DESTROYER,BATTLESHIP)
C
3600	IF((IDC.EQ.IODC .AND. ICHAR.NE.'N') .OR.
     &	(KIND.NE.1 .AND. KIND.NE.3))GOTO 3650
	CALL COLCUR( 73, 18 )
	CALL NUMBER( IDC, 2 )
	IODC = IDC
C
C***	UPDATE MISSILE COUNT (ALL EXCEPT P.T. BOAT)
C
3650	IF((IMISSL.EQ.IOMSSL.AND.ICHAR.NE.'N').OR.KIND.EQ.4)GOTO 3700
	CALL COLCUR( 74, 16 )
	CALL NUMBER( IMISSL, 2 )
	IOMSSL = IMISSL
C
C***	UPDATE TORPEDO COUNT (SUBMARINE,P.T. BOAT)
C
3700	IF((ITORP.EQ.IOTORP .AND. ICHAR.NE.'N') .OR.
     &  ( KIND.NE.2 .AND. KIND.NE.4 ))GOTO 3750
	CALL COLCUR( 73, 15 )
	CALL NUMBER( ITORP, 3 )
	IOTORP = ITORP
C
C***	UPDATE AUTO FIRE SURFACE FLAG
C
3750	IF((ATOFIR.EQ.OFIRE.AND.ICHAR.NE.'N').OR.KIND.NE.1) GOTO 3800
	CALL COLCUR( 75, 15 )
	IF( ATOFIR ) CALL STRING('On ^E')
	IF( .NOT. ATOFIR ) CALL STRING('Off^E')
	OFIRE = ATOFIR
C
C***	UPDATE SOUND LEVEL
C
3800	ISLVL = 0
	HIGHST = 0
	DO 3900 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 3900
	    CALL GETVAL( 2, I, 2, ISX )
	    CALL GETVAL( 2, I, 3, ISY )
	    CALL GETVAL( 2, I, 4, ISD )
	    DIST =
     & SQRT((ISHIPX-ISX+0.)^2 + (ISHIPY-ISY+0.)^2 +
     & (IDEPTH-ISD+0.)^2)
	    CALL GETVAL( 2, I, 7, IVAL )
	    SOUND = FLOAT(IVAL)/((DIST+1.)^2)
	    ISLVL = ISLVL + SOUND
	    IF( DIST .EQ. 0 ) GOTO 3900
	    IF( DIST .LE. 5 .AND. ATOFIR .AND. ISD .GE. 18 )
     &		CALL PUTVAL( 2, I, 8, 11 )
	    IF( SOUND .LE. HIGHST ) GOTO 3900
	    IDEG = 90
	    IF( ISHIPX .EQ. ISX .AND. ISY .LT. ISHIPY ) IDEG = 270
	    IF( ISHIPX .NE. ISX ) IDEG =
     &		180.*ATAN(1.*(ISHIPY-ISY)/(1.*(ISHIPX-ISX)))/3.14159
	    IF( ISHIPX .GT. ISX ) IDEG = IDEG + 180
	    IDEG = MOD( IDEG, 360 )
	    IF( IDEG .LT. 0 ) IDEG = IDEG + 360
	    HIGHST = SOUND
3900	CONTINUE
	IF( IABS(ISPEED)*2 .GE. IFIX(HIGHST)) IDEG = 100000
C
	IF( ISLVL .EQ. IOSLVL .AND. ICHAR .NE. 'N' ) GOTO 3950
	CALL COLCUR( 69, 17 )
	CALL NUMBER( ISLVL, 5 )
	IOSLVL = ISLVL
C
3950	IF( IDEG .EQ. IODEG .AND. ICHAR .NE. 'N' ) GOTO 4000
	CALL COLCUR( 76, 17 )
	CALL NUMBER( IDEG, 3 )
	IODEG = IDEG
C
C***	UPDATE HULL-STRESS FACTOR (SUBMARINE)
C
4000	IF((IHFAC.EQ.IOHFAC.AND.ICHAR.NE.'N').OR.KIND.NE.2)GOTO 4100
	CALL COLCUR( 70, 14 )
	CALL NUMBER( IHFAC, 3 )
	IOHFAC = IHFAC
C
C***	UPDATE STRESS WATER IS EXERTING (SUBMARINE)
C
4100	IF((IDFAC.EQ.IODFAC.AND.ICHAR.NE.'N').OR.KIND.NE.2)GOTO 4200
	CALL COLCUR( 71, 13 )
	CALL NUMBER( IDFAC, 3 )
	IODFAC = IDFAC
C
C***	UPDATE NUMBER OF HITS ON PORT # 1
C
4200	CALL GETVAL( 3, 1, 6, IPK1 )
	IF( IPK1 .EQ. IOPK1 .AND. ICHAR .NE. 'N' ) GOTO 4300
	CALL COLCUR( 79, 11 )
	CALL NUMBER( IPK1, 1 )
	IF( IPORT .NE. 1 .OR. IPK1 .LE. IOPK1 ) GOTO 4250
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** EMERGENCY:  Port has been hit ***^E')
4250	IOPK1 = IPK1
C
C***	UPDATE SHIPS BELONGING TO PORT # 1
C
4300	CALL GETVAL( 3, 1, 5, IP1 )
	IF( IP1 .EQ. IOP1 .AND. ICHAR .NE. 'N' ) GOTO 4500
	CALL COLCUR( 64, 10 )
	DO 4400 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 4400
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .NE. 1 ) GOTO 4400
	    CALL CHROUT( I+64 )
4400	CONTINUE
	IF( IP1 .LT. IOP1 )  CALL STRING('  ^E')
	IOP1 = IP1
C
C***	UPDATE NUMBER OF HITS ON PORT # 2
C
4500	CALL GETVAL( 3, 2, 6, IPK2 )
	IF( IPK2 .EQ. IOPK2 .AND. ICHAR .NE. 'N' ) GOTO 4600
	CALL COLCUR( 79, 8 )
	CALL NUMBER( IPK2, 1 )
	IF( IPORT .NE. 2 .OR. IPK1 .LE. IOPK1 ) GOTO 4550
	CALL CLRLIN
	CALL COLSTR(ICLRED,'*** EMERGENCY:  Port has been hit ***^E')
4550	IOPK2 = IPK2
C
C***	UPDATE SHIPS BELONGING TO PORT # 2
C
4600	CALL GETVAL( 3, 2, 5, IP2 )
	IF( IP2 .EQ. IOP2 .AND. ICHAR .NE. 'N' ) GOTO 4800
	CALL COLCUR( 64, 7 )
	DO 4700 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 4700
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .NE. 2 ) GOTO 4700
	    CALL CHROUT( I+64 )
4700	CONTINUE
	IF( IP2 .LT. IOP2 )  CALL STRING('  ^E')
	IOP2 = IP2
C
C***	DECREMENT PORT REPAIR STATES IF THIS IS THE LAST JOB PLAYING
C
4800	DO 4900 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 4900
	    LASTJB = I
	    IF( .NOT. LOGDIN(IVAL) ) GOTO 4850
	    IF( JOB(-1) .EQ. 0 ) GOTO 4900
	    IF( JSTAT( IVAL ) .EQ. ISXBIT('^C') ) GOTO 4850
	    IF(	ITTY( IVAL ) .GE. 0 ) GOTO 4900
4850	    CALL ENDHIM( I )
4900	CONTINUE
	IF( ITURN .NE. 0 .OR. LASTJB .NE. IPLAYR .OR. EOT ) GOTO 5000
	CALL GETVAL( 3, 1, 6, IVAL )
	IF( IVAL .NE. 0 )  CALL ADDVAL( -3, -1 )
	CALL GETVAL( 3, 2, 6, IVAL )
	IF( IVAL .NE. 0 )  CALL ADDVAL( -3, -1 )
C
C***	UPDATE DAMAGE
C
5000	DO 5100 I = 1, 10
	    IF( KIND .EQ. 1 .AND. (I .EQ. 6 .OR. I .EQ. 9 )) GOTO 5100
	    IF( KIND .EQ. 3 .AND. (I .EQ. 5 .OR. I .EQ. 6 ) ) GOTO 5100
	    IF( KIND .EQ. 4 .AND. I .GT. 6 .AND. I .LT. 10 ) GOTO 5100
	    IF( KIND .EQ. 5 .AND. I .NE. 1 .AND. I .NE. 3 .AND.
     &		I .NE. 4 .AND. I .NE. 7 .AND. I .NE. 10 ) GOTO 5100
	    IF(DAMAGE(I,1).EQ.DAMAGE(I,2) .AND. ICHAR.NE.'N')GOTO 5100
	    CALL COLCUR( -2+I*8, 3 )
	    IF( DAMAGE( I, 1 ) .NE. 0 ) GOTO 5050
	    CALL PCOLOR( ICLGRE )
	    CALL CHROUT('O')
	    GOTO 5090
5050	    IF( DAMAGE( I, 1 ) .NE. -1 ) GOTO 5060
	    CALL PCOLOR( ICLPUR )
	    CALL CHROUT('P')
	    GOTO 5090
5060	    IF( DAMAGE( I, 1 ) .GT. 1 ) CALL PCOLOR( ICLRED )
	    IF( DAMAGE( I, 1 ) .EQ. 1 ) CALL PCOLOR( ICLYEL )
	    CALL NUMBER( DAMAGE( I, 1 ), 1 )
	    GOTO 5090
5090	    DAMAGE( I, 2 ) = DAMAGE( I, 1 )
5100	CONTINUE
C
C***	UPDATE NUMBER OF SECONDS UNTIL TORPEDOS ARE READY
C***	(SUBMARINE,P.T. BOAT)
C
	IF((I1TORP.EQ.IO1TRP .AND. ICHAR.NE.'N') .OR.
     & ( KIND.NE.2 .AND. KIND.NE.4 ))GOTO 5200
	CALL COLCUR( 73, 5 )
	IF( I1TORP .GT. 0 )  CALL NUMBER( I1TORP, 3 )
	IF( I1TORP .GT. 0 )  CALL STRING('  ^E')
	IF( I1TORP .EQ. 0 )  CALL STRING('Ready^E')
	IO1TRP = I1TORP
C
5200	IF((I2TORP.EQ.IO2TRP .AND. ICHAR.NE.'N') .OR.
     & ( KIND.NE.2 .AND. KIND.NE.4 ))GOTO 5300
	CALL COLCUR( 73, 4 )
	IF( I2TORP .GT. 0 )  CALL NUMBER( I2TORP, 3 )
	IF( I2TORP .GT. 0 )  CALL STRING('  ^E')
	IF( I2TORP .EQ. 0 )  CALL STRING('Ready^E')
	IO2TRP = I2TORP
C
C***	CHECK TO SEE IF THIS JOB IS STILL IN THE DATA BASE
C***	IF IT ISN'T, THEN SOMETHING IS VERY WRONG ... EXIT
C
5300	CALL GETVAL( 2, IPLAYR, 1, IJOB )
	IF( IJOB .EQ. JOB(0) ) GOTO 5400
	CALL CLRSCR
	CALL STRING
     & ('Your job has been removed from the database.^M^J^E')
	CALL CLOSE( 1 )
	CALL PSTOP
C
C*********************************
C***	GET USER'S COMMAND    ****
C*********************************
C
5400	CALL OUTBUF( 1 )
	CALL COMAND( ICHAR, COMARA, INDEX )
C
	IF( ICHAR .EQ. -1 ) GOTO 1100
C
	CALL CLRLIN
C
C***	GET ANY NUMBERS THERE MAY BE IN IT
C
	CALL GETNUM
     &( COMARA, INDEX, IFAC1, 10, IFAC2, 10, IFAC3, 10, IFAC4, 10 )
C
C***	EXIT (USEFULL)
C
	IF( ICHAR .NE. 'E' .OR. COMARA(2) .NE. 'X' ) GOTO 5500
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
C
C***	NEW SCREEN (NO-OP)
C
5500	IF( ICHAR .EQ. 'N' .AND. INDEX .LE. 1 ) GOTO 1100
C
C***	ALLOW USER TO CHANGE SHIP NAME
C
	IF( ICHAR .NE. 'N' ) GOTO 5550
	STNAME(1) = 0
	STNAME(2) = 0
	CALL CONVRT( COMARA(2), INDEX-1, 1, STNAME, 6 )
	CALL PUTVAL( 2, IPLAYR, 5, STNAME(1) )
	CALL PUTVAL( 2, IPLAYR, 6, STNAME(2) )
	ICHAR = 0
	GOTO 1100
C
C***	ALLOW USER TO SET KIND IF HE ENTERS A PORT.
C
5550	IF(ICHAR.NE.'K'.OR.NOTFRS.OR.IFAC1.LT.1.OR.IFAC1.GT.5)GOTO 5600
	IF( KIND .EQ. IFAC1 ) GOTO 1100
	IF( KIND .EQ. 5 .OR. IFAC1 .EQ. 5 ) GOTO 5551
	NKIND = IFAC1
	GOTO 1100
C
5551	CALL CLRLIN
	CALL STRING('*** ^E')
	CALL PKIND( KIND )
	CALL STRING(' may not become a ^E')
	CALL PKIND( IFAC1 )
	CALL STRING(' ***^E')
	GOTO 1100
C
C***	SONAR CONTROL
C
5600	IF( ICHAR .NE. 'S' .OR. COMARA(2) .NE. 'C' ) GOTO 5650
	IRADR = MOD( MOD( IFAC1, 360 )+360, 360 )
	IF( INDEX .EQ. 2 ) IRADR = -1
	IRADNC = 0
	GOTO 1100
C
5650	IF( ICHAR .NE. 'S' .OR. COMARA(2) .NE. 'W' ) GOTO 5700
	IRADTO = MOD( MOD( IFAC1, 360 )+360, 360 )
	IF( IRADR .LT. 0 ) IRADR = IAZ
	CALL ALLCAP( COMARA, 3 )
	IF( COMARA(3) .EQ. 'C' ) IRADNC = IFAC1
	IF( COMARA(3) .NE. 'C' ) IRADNC = IFAC2
	IF( IRADNC .EQ. 0 ) IRADNC = 3
	IF( IABS( IRADNC ) .GT. 359 ) IRADNC = MOD( IRADNC, 360 )
	IF( COMARA(3) .EQ. 'C' ) IRADTO = -1
	GOTO 1100
C
C***	HELM CONTROL
C
5700	IF( ICHAR .NE. 'A' ) GOTO 5900
	IF( DAMAGE( 2, 1 ) .NE. 0 ) GOTO 5800
	ITAZ = MOD( IFAC1, 360 )
	IF( ITAZ .LT. 0 )  ITAZ = ITAZ + 360
	GOTO 1100
C
5800	CALL COLSTR(ICLYEL,'*** Helm does not respond ***^E')
	GOTO 1100
C
C***	PITCH CONTROL (SUBMARINE, HELICOPTER)
C
5900	IF( ICHAR .NE. 'P' .OR. (KIND.NE.2.AND.KIND.NE.5)) GOTO 6100
	IF( DAMAGE( 8, 1 ) .NE. 0 ) GOTO 6000
	ITPTCH = IFAC1
	IF( IABS(ITPTCH) .GT. 90 ) ITPTCH = SIGN(1.,ITPTCH*1.)*90.
	IF( IABS(ITPTCH) .GT. 45 .AND. KIND .NE. 5 )
     & ITPTCH = SIGN(1.,ITPTCH*1.)*45.
	GOTO 1100
C
6000	CALL COLSTR(ICLYEL,'*** Pitch control does not respond ***^E')
	GOTO 1100
C
C***	BALLAST CONTROL (SUBMARINE)
C
6100	IF( ICHAR .NE. 'B' .OR. KIND .NE. 2 ) GOTO 6300
	IF( DAMAGE( 9, 1 ) .NE. 0 ) GOTO 6200
	IBAL = IFAC1
	IF( INDEX .EQ. 1 )  IBAL = -100.*(DEPTH-18.)/16.
	IF( IBAL .LT. 0 )  IBAL = 0
	IF( IBAL .GT. 100 )  IBAL = 100
	GOTO 1100
C
6200	CALL COLSTR(ICLYEL,
     & '*** Ballast control does not respond ***^E')
	GOTO 1100
C
C***	SPEED CONTROL
C
6300	IF( ICHAR .NE. 'S' ) GOTO 6500
	IF( DAMAGE( 1, 1 ) .NE. 0 ) GOTO 6400
	ITSPD = IFAC1
	IF( ITSPD .GT. 10*KIND ) ITSPD = 10*KIND
	IF( ITSPD .LT. -5*KIND )  ITSPD = -5*KIND
	GOTO 1100
C
6400	CALL COLSTR(ICLYEL,'*** Engines do not respond ***^E')
	GOTO 1100
C
C***	GET INFORMATION ABOUT OTHER USERS
C
6500	IF( ICHAR .NE. 'W' ) GOTO 6700
	IF( INDEX .EQ. 1 ) GOTO 6550
	ICCHAR = ICON( COMARA(2) ) - 64
	IF( ICCHAR .LT. 1 .OR. ICCHAR .GT. 26 ) GOTO 6600
	CALL GETVAL( 2, ICCHAR, 1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 6600
	CALL WHO( ICCHAR )
	GOTO 1100
C
6550	DO 6560 ITEMP = 1, 26
	    I = ITEMP
	    CALL GETVAL( 2, I, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 6560
	    CALL GETVAL( 2, I, 9, IVAL )
	    IF( IVAL .NE. IPORT ) GOTO 6560
	    CALL CHROUT( I+64 )
	    CALL CHROUT('/')
	    CALL GETVAL( 2, I, 10, IVAL )
	    IF( IVAL .EQ. 1 ) CALL CHROUT('B')
	    IF( IVAL .EQ. 2 ) CALL CHROUT('S')
	    IF( IVAL .EQ. 3 ) CALL CHROUT('D')
	    IF( IVAL .EQ. 4 ) CALL CHROUT('P')
	    IF( IVAL .EQ. 5 ) CALL CHROUT('H')
	    CALL CHROUT(':')
	    CALL GETVAL( 2, I, 2, IX )
	    CALL NUMBER( IX, -3 )
	    CALL CHROUT('-')
	    CALL GETVAL( 2, I, 3, IY )
	    CALL NUMBER( IY, -3 )
	    CALL CHROUT(';')
	    CALL GETVAL( 2, I, 4, ID )
	    CALL NUMBER( ID-18 )
	    CALL CHROUT(' ')
6560	CONTINUE
	GOTO 1100
C
6600	CALL COLSTR(ICLYEL,'Ship does not exist.^E')
	GOTO 1100
C
C***	GAG USER
C
6700	IF( ICHAR .NE. 'G' ) GOTO 6800
	CALL USRSET( "2013, 0 )
	GOTO 1100
C
C***	TORPEDO CONTROL
C
6800	IF( ICHAR.NE.'T' .OR. ( KIND.NE.2 .AND. KIND.NE.4 )) GOTO 7500
	IF( ITORP .EQ. 0 ) GOTO 7300
	INC = 1
	IF( DAMAGE( 5, 1 ) .NE. 0 .OR. I1TORP .NE. 0 ) INC = -1
	IF( DAMAGE( 6, 1 ) .NE. 0 .AND. INC .EQ. -1 ) GOTO 7200
	IF( INC .LT. 0 .AND. I2TORP .NE. 0 ) GOTO 7100
	IF( INC .LT. 0 )  I2TORP = 10
	IF( INC .GT. 0 )  I1TORP = 10
	ITORP = ITORP - 1
	TORPX = SHIPX
	TORPY = SHIPY
	TORPD = DEPTH
	ITP = IPITCH
	ITER = 0
6900	ITER = ITER + 1
	IF( ITER .GT. 25 ) GOTO 7450
	TORPX = TORPX + SMCOS(FLOAT(IAZ))*COSDEG(FLOAT(ITP))
	ITORPX = TORPX + 0.5
	TORPY = TORPY + SMSIN(FLOAT(IAZ))*COSDEG(FLOAT(ITP))
	ITORPY = TORPY + 0.5
	TORPD = TORPD + SINDEG(FLOAT(ITP))
	IF( TORPD .GT. 18 )  ITP = 0
	IF( TORPD .GT. 18 )  TORPD = 18
	ITORPD = TORPD + 0.5
	IF( KIND .EQ. 2 ) ITP = ITP - INC
	IF( ITORPX .EQ. ISHIPX .AND. ITORPY .EQ. ISHIPY ) GOTO 6900
	CALL GETVAL( 1, ITORPX, ITORPY, IVAL )
	IF( IRIGHT( IVAL ) .GE. ITORPD ) GOTO 7400
	IF( ILEFT( IVAL ) .EQ. 0 .OR. ILEFT( IVAL ) .GT. 26 ) GOTO 6900
	CALL GETVAL( 2, ILEFT( IVAL ), 4, IVAL1 )
	IF( ITORPD .NE. IVAL1 ) GOTO 6900
	CALL STRING('Torpedo at ^E')
	CALL NUMBER( ITORPX, -3 )
	CALL CHROUT('-')
	CALL NUMBER( ITORPY, -3 )
	CALL STRING(' at depth ^E')
	CALL NUMBER( 18-ITORPD )
	CALL STRING(' strikes the ^E')
	CALL GETVAL( 2, ILEFT( IVAL ), 5, STNAME(1) )
	CALL GETVAL( 2, ILEFT( IVAL ), 6, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL EXPLOD( ITORPX, ITORPY, ITORPD, 3, IEXFLG )
	CALL PUTVAL( 2, ILEFT( IVAL ), 8, 10 )
	GOTO 1100
C
7100	CALL COLSTR(ICLYEL,'*** Torpedo is not ready for firing ***^E')
	GOTO 1100
C
7200	CALL COLSTR(ICLYEL,'*** Torpedo tube does not respond ***^E')
	GOTO 1100
C
7300	CALL COLSTR(ICLYEL,'*** All torpedos are expended. ***^E')
	GOTO 1100
C
7400	CALL COLSTR(ICLLBL,'Torpedo at ^E')
	CALL NUMBER( ITORPX, -3 )
	CALL CHROUT('-')
	CALL NUMBER( ITORPY, -3 )
	CALL STRING(' at depth ^E')
	CALL NUMBER( 18-ITORPD )
	CALL STRING(' strikes rock^E')
7450	CALL EXPLOD( ITORPX, ITORPY, ITORPD, 3, IEXFLG )
	GOTO 1100
C
C***	COMMUNICATIONS CONTROL
C
7500	IF( ICHAR .NE. 'R' ) GOTO 7850
	IREC = ICON( COMARA(2) ) - 64
	IF( IREC .LT. 1 .OR. IREC .GT. 26 ) GOTO 7800
	CALL GETVAL( 2, IREC, 1, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 7800
	ITERAT = 0
7600	CALL GETVAL( 6, 1, IVAL )
	IF( IVAL .NE. 0 ) CALL NAP( 1000, 4 )
	CALL UNLOCK
	CALL LOCK
	CALL PUTVAL( -6, IREC )
	CALL PUTVAL( 6, 2, INDEX-2 )
	IF( INDEX .GT. 60 )  CALL PUTVAL( 6, 2, 60 )
	CALL PUTVAL( 6, 3, IPLAYR )
	IF( INDEX .LT. 3 ) GOTO 7701
	DO 7700 I = 1, INDEX-2
	    IF( I .LE. 60 )  CALL PUTVAL( 6, 3+I, COMARA(I+2) )
7700	CONTINUE
7701	CONTINUE
	CALL UNLOCK
	GOTO 1100
C
7800	CALL COLSTR(ICLYEL,
     & '*** Frequency is not known for that ship ***^E')
	GOTO 1100
C
C***	COMPUTER CONTROL (BATTLESHIPS)
C
7850	IF( ICHAR .NE. 'C' .OR. KIND .NE. 1 ) GOTO 7900
	IF( DAMAGE( 5, 1 ) .NE. 0 ) GOTO 7890
	CALL STRING('Computer:  ^E')
	IF( COMARA(2) .NE. 'G' ) GOTO 7860
	IF( DAMAGE( 10, 1 ) .NE. 0 ) GOTO 7855
	ATOFIR = (.NOT. ATOFIR)
	IF( ATOFIR ) CALL STRING('Automatic fire initiated^E')
	IF( .NOT. ATOFIR ) CALL STRING('Automatic fire halted^E')
	GOTO 1100
C
7855	CALL COLSTR(ICLYEL,'*** Surface guns do not respond ***^E')
	GOTO 1100
C
7860	CALL NUMBER( IFAC1, -3 )
	CALL CHROUT('-')
	CALL NUMBER( IFAC2, -3 )
	CALL STRING(' Alt: ^E')
	CALL NUMBER( IFAC3 )
	IFAC3 = IFAC3 + 18
	DEGREE = 90.
	IF( ISHIPX .EQ. IFAC1 .AND. ISHIPY .GT. IFAC2 ) DEGREE = 270.
	IF( ISHIPX .NE. IFAC1 )
     & DEGREE=180.*ATAN(1.*(ISHIPY-IFAC2)/(1.*(ISHIPX-IFAC1)))/3.14159
	IF( ISHIPX .GT. IFAC1 ) DEGREE = DEGREE + 180.
	IF( NEWANG ) DEGREE = 90 - DEGREE
7862	IF( DEGREE.LT.360 .AND. DEGREE.GE. 0 ) GOTO 7865
	IF( DEGREE .GE. 360 ) DEGREE = DEGREE - 360.
	IF( DEGREE .LT.   0 ) DEGREE = DEGREE + 360.
	GOTO 7862
7865	CALL STRING('  Azim: ^E')
	CALL NUMBER( DEGREE, 3, 10, 0 )
	CALL STRING('  Elev: ^E')
	IF( ISHIPX .EQ. IFAC1 .AND. ISHIPY .EQ. IFAC2 ) GOTO 7870
	DIST = SQRT((ISHIPX-IFAC1+0.)^2 + (ISHIPY-IFAC2+0.)^2)
	A = -0.05
	V = 1.
	RADICL =
     & 1-4.*(.5*A*DIST/(V^2))*(.5*A*DIST/(V^2)-(IDEPTH-IFAC3)/DIST)
	IF( RADICL .LT. 0 ) GOTO 7880
	ATARG1 = ( -1. + SQRT(RADICL))/(A*DIST/(V^2))
	ATARG2 = ( -1. - SQRT(RADICL))/(A*DIST/(V^2))
	ELEV1 = 180.*ATAN( ATARG1 )/3.14159 + .5
	ELEV2 = 180.*ATAN( ATARG2 )/3.14159 + .5
	CALL NUMBER( ELEV1, 4, 10, 1 )
	IF( IFIX(ELEV1) .EQ. IFIX(ELEV2) ) GOTO 7885
	CALL STRING(' or ^E')
	CALL NUMBER( ELEV2, 4, 10, 1 )
	GOTO 7885
C
7870	CALL STRING('90.00^E')
	GOTO 7885
C
7880	CALL STRING('Unknown^E')
C
7885	CALL STRING('  Dist: ^E')
	DIST =
     & SQRT((ISHIPX-IFAC1+0.)^2+(ISHIPY-IFAC2+0.)^2
     & +(IDEPTH-IFAC3+0.)^2)
	CALL NUMBER( DIST, 6, 10, 1 )
	GOTO 1100
C
7890	CALL COLSTR(ICLRED,'%Battle computer being reloaded^E')
	GOTO 1100
C
C***	MISSILE CONTROL (ALL EXCEPT P.T. BOAT)
C
7900	IF( ICHAR .NE. 'M' .OR. KIND .EQ. 4 ) GOTO 8910
	IF( IMISSL .EQ. 0 ) GOTO 8600
	IF( DAMAGE( 7, 1 ) .LT. 0 ) GOTO 8900
	IF( DAMAGE( 7, 1 ) .GT. 0 ) GOTO 8700
	IF(KIND.NE.5.AND.(IFAC2.LT.1.OR.IFAC2.GT.89))GOTO 8800
	IF( IFAC2 .GT. 89 .OR. IFAC2 .LT. -89 ) GOTO 8800
	IF( INDEX .EQ. 1 ) IFAC1 = IAZ
	IF( INDEX .EQ. 1 ) IFAC2 = -89
	IMISSL = IMISSL - 1
	DAMAGE( 7, 1 ) = 1
	XMISSL = SHIPX
	YMISSL = SHIPY
	DMISSL = DEPTH
	XVEL = SMCOS(FLOAT(IFAC1))*COS(0.017453293 * IFAC2)
	YVEL = SMSIN(FLOAT(IFAC1))*COS(0.017453293 * IFAC2)
	ZVEL = SINDEG(FLOAT(IFAC2))
C
8000	XMISSL = XMISSL + XVEL
	MISSLX = XMISSL + 0.5
	YMISSL = YMISSL + YVEL
	MISSLY = YMISSL + 0.5
	DMISSL = DMISSL + ZVEL
	MISSLD = DMISSL + 0.5
	ZVEL = ZVEL - 0.05
C
	IF(MISSLX.LT.1.OR.MISSLX.GT.120.OR.MISSLY.LT.1.OR.
     & MISSLY.GT.120) GOTO 8500
	CALL GETVAL( 1, MISSLX, MISSLY, IVAL )
	IF( IRIGHT( IVAL ) .GE. MISSLD ) GOTO 8100
	IF( ILEFT( IVAL ) .EQ. 0 .OR. ILEFT( IVAL ) .EQ. IPLAYR .OR.
     & ILEFT( IVAL ) .GT. 26 ) GOTO 8000
	CALL GETVAL( 2, ILEFT( IVAL ), 4, IVAL1 )
	IF( MISSLD .NE. IVAL1 ) GOTO 8000
	CALL STRING('Missile at ^E')
	CALL NUMBER( MISSLX, -3 )
	CALL CHROUT('-')
	CALL NUMBER( MISSLY, -3 )
	CALL STRING(' at altitude ^E')
	CALL NUMBER( MISSLD-18 )
	CALL COLSTR(ICLLBL,' strikes the ^E')
	CALL GETVAL( 2, ILEFT( IVAL ), 5, STNAME(1) )
	CALL GETVAL( 2, ILEFT( IVAL ), 6, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	IF(KIND.NE.5)CALL PUTVAL( 2, ILEFT( IVAL ), 8, 20 )
	IF(KIND.EQ.5)CALL PUTVAL( 2, ILEFT( IVAL ), 8, 5 )
	IF(KIND.NE.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 6, IEXFLG )
	IF(KIND.EQ.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 2, IEXFLG )
	GOTO 1100
C
8100	CALL STRING('Missile at ^E')
	CALL NUMBER( MISSLX, -3 )
	CALL CHROUT('-')
	CALL NUMBER( MISSLY, -3 )
	CALL STRING(' at altitude ^E')
	CALL NUMBER( MISSLD-18 )
	IF( MISSLX .EQ. IPRTX1 .AND. MISSLY .EQ. IPRTY1 ) GOTO 8200
	IF( MISSLX .EQ. IPRTX2 .AND. MISSLY .EQ. IPRTY2 ) GOTO 8300
	CALL COLSTR(ICLYEL,' pulverizes a rock^E')
	IF(KIND.NE.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 6, IEXFLG )
	IF(KIND.EQ.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 2, IEXFLG )
	GOTO 1100
C
8200	IF(KIND.NE.5)CALL ADDVAL( 3, 1, 6, 1 )
	CALL COLSTR(ICLLBL,' strikes the port of ^E')
	CALL GETVAL( 3, 1, 1, STNAME(1) )
	CALL GETVAL( 3, 1, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	IF(KIND.NE.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 6, IEXFLG )
	IF(KIND.EQ.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 2, IEXFLG )
	IF( IPORT .EQ. 1 ) GOTO 8400
	GOTO 1100
C
8300	IF(KIND.NE.5)CALL ADDVAL( 3, 2, 6, 1 )
	CALL COLSTR(ICLRED,' strikes the port of ^E')
	CALL GETVAL( 3, 2, 1, STNAME(1) )
	CALL GETVAL( 3, 2, 2, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	IF(KIND.NE.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 6, IEXFLG )
	IF(KIND.EQ.5)CALL EXPLOD( MISSLX, MISSLY, MISSLD, 2, IEXFLG )
	IF( IPORT .NE. 2 ) GOTO 1100
C
8400	IDFECT = IDFECT + 1
	IF( IDFECT .GT. 1 ) GOTO 9100
	CALL CLRLIN
	CALL COLSTR(ICLLBL,'**** You have defected ****^E')
	CALL ADDVAL( 3, IPORT, 5, -1 )
	IPORT =3-IPORT
	CALL ADDVAL( 3, IPORT, 5, 1 )
	CALL PUTVAL( 2, IPLAYR, 9, IPORT )
	GOTO 1100
C
8500	CALL STRING('Missile at ^E')
	CALL NUMBER( MISSLX, -3 )
	CALL CHROUT('-')
	CALL NUMBER( MISSLY, -3 )
	CALL STRING(' at altitude ^E')
	CALL NUMBER( MISSLD-18 )
	CALL STRING(' leaves radar range^E')
	GOTO 1100
C
8600	CALL COLSTR(ICLYEL,'*** All missiles are expended ***^E')
	GOTO 1100
C
8700	CALL COLSTR(ICLYEL,'*** Missile station not armed ***^E')
	GOTO 1100
C
8800	CALL COLSTR(ICLYEL,
     & '*** Cannot launch missile on extreme elevation ***^E')
	GOTO 1100
C
8900	CALL COLSTR(ICLYEL,
     & '*** Missile launcher does not respond ***^E')
	GOTO 1100
C
C***	MINE CONTROL (DESTROYER)
C
8910	IF( ICHAR .NE. 'L' .OR. KIND .NE. 3 ) GOTO 9000
	IF( IMINE .EQ. 0 ) GOTO 8980
	IF( DAMAGE( 9, 1 ) .NE. 0 ) GOTO 8970
	IMINE = IMINE - 1
	IX = SHIPX - SMCOS( FLOAT(IAZ) ) + 0.5
	IY = SHIPY - SMSIN( FLOAT(IAZ) ) + 0.5
	IF
     &( IX .LT. 1 .OR. IX .GT. 120 .OR. IY .LT. 1 .OR. IY .GT. 120 )
     & GOTO 8960
	CALL GETVAL( 1, IX, IY, IVAL )
	IF( IVAL .GT. 17 ) GOTO 8960
	CALL PUTVAL( 1, IX, IY, ICOMB( 26+IPORT, IVAL ) )
	GOTO 1100
C
8960	CALL EXPLOD( IX, IY, 18, 3, IEXFLG )
	GOTO 1100
C
8970	CALL COLSTR(ICLYEL,'*** Mine control does not respond ***^E')
	GOTO 1100
C
8980	CALL COLSTR(ICLYEL,'*** All mines are expended. ***^E')
	GOTO 1100
C
C***	DEPTH CHARGE CONTROL (DESTROYER,BATTLESHIP)
C
9000	IF( ICHAR .NE. 'D' .OR.
     & ( KIND.NE.1 .AND. KIND .NE. 3 )) GOTO 9050
	IF( IDC .EQ. 0 ) GOTO 9040
	IF( DAMAGE( 8, 1 ) .NE. 0 ) GOTO 9030
	INC = 3
	IF( COMARA( 2 ) .EQ. 'S' ) INC = -3
	IDC = IDC - 1
	IFAC1 = 18 - IFAC1
	IF( IFAC1 .GE. 18 .OR. IFAC1 .LT. 1 ) IFAC1 = 1
	IX = SHIPX + SMCOS( FLOAT(IAZ) )*INC + 0.5
	IY = SHIPY + SMSIN( FLOAT(IAZ) )*INC + 0.5
	CALL GETVAL( 1, IX, IY, IVAL )
	IF( IRIGHT( IVAL ) .GE. IFAC1 ) IFAC1 = IRIGHT( IVAL )
	CALL EXPLOD( IX, IY, IFAC1, 4, IEXFLG )
	GOTO 1100
C
9030	CALL COLSTR(ICLYEL,
     & '*** Depth charge control does not respond ***^E')
	GOTO 1100
C
9040	CALL COLSTR(ICLYEL,
     & '*** All depth charges are expended. ***^E')
	GOTO 1100
C
C***	GUN CONTROL (BATTLESHIP,DESTROYER,P.T. BOAT,HELICOPTER)
C
9050	IF(ICHAR.NE.'F' .OR. KIND .EQ. 2 ) GOTO 9090
	IF( DAMAGE( 10, 1 ) .NE. 0 ) GOTO 9080
C
	GX = SMCOS( FLOAT(IFAC1) )
	GY = SMSIN( FLOAT(IFAC1) )
C
	ITEMP = 5
	IF( KIND .EQ. 1 ) ITEMP = 7
	IF( KIND .EQ. 5 ) ITEMP = 3
9060	DO 9070 I = 1, ITEMP
	    IX = FLOAT(ISHIPX) + GX*I + 0.5
	    IY = FLOAT(ISHIPY) + GY*I + 0.5
	    IF( IX.LT.1 .OR. IX.GT.120 .OR. IY.LT.1 .OR. IY.GT.120 ) 
     &		GOTO 9070
	    CALL GETVAL( 1, IX, IY, IVAL )
	    IVAL = ILEFT( IVAL )
	    IF( IVAL .NE. 0 .AND. IVAL .NE. IPLAYR .AND. IVAL .LE. 26 )
     &	    GOTO 9075
9070	CONTINUE
	CALL STRING('*** Shells fall harmlessly ***^E')
	GOTO 1100
C
9075	CALL GETVAL( 2, IVAL, 4, IFAC2 )
	IF( IFAC2 .LT. 18 ) GOTO 9070
	IF( KIND .EQ. 5 .AND. IABS( IFAC2-IDEPTH ) .GT. 1 ) GOTO 9070
	CALL STRING('Shells strike the ^E')
	CALL GETVAL( 2, IVAL, 5, STNAME(1) )
	CALL GETVAL( 2, IVAL, 6, STNAME(2) )
	CALL STRING( STNAME, 6, 12 )
	CALL PUTVAL( 2, IVAL, 8, ITEMP*2+1 )
	GOTO 1100
C
9080	CALL COLSTR(ICLYEL,'*** Surface guns do not respond ***^E')
	GOTO 1100
C
C***	DEBUGGING FEATURES (EXPLODE, EDIT)
C
9090	IF( ICHAR .NE. 'E' .OR. .NOT. DEBUG ) GOTO 9095
	IF( COMARA(2) .EQ. 'D' ) CALL EDIT( COMARA(3), INDEX-2 )
	IF( COMARA(2) .EQ. 'D' ) GOTO 1100
	IFAC3 = IFAC3 + 18
	CALL ALLCAP( COMARA, 3 )
	IVIC = ICON( COMARA(3) ) - 64
	IF( IVIC .LT. 1 .OR. IVIC .GT. 26 ) GOTO 9094
	CALL GETVAL( 2, IVIC, 2, INC )
	IFAC1 = IFAC1 + INC
	CALL GETVAL( 2, IVIC, 3, INC )
	IFAC2 = IFAC2 + INC
	CALL GETVAL( 2, IVIC, 4, INC )
	IFAC3 = IFAC3 + INC - 18
9094	CALL EXPLOD( IFAC1, IFAC2, IFAC3, IFAC4, IEXFLG )
	GOTO 1100
C
C***	IF NONE OF THE ABOVE, COMMAND IS ILLEGAL
C
9095	CALL COLCUR( 1, 2 )
	CALL COLSTR(ICLYEL,'*** Illegal command "^E')
	CALL CHROUT( ICHAR )
	CALL STRING('" ***^E')
	GOTO 1100
C
C***	USER HAS DEFECTED TWICE.  KILL HIM
C
9100	CALL CLRLIN
	CALL COLSTR(ICLRED,
     & '*** You have been exterminated by your past allies
     & for defecting ***^E')
	CALL CEASE( ISHIPX, ISHIPY, IPLAYR )
	END

	SUBROUTINE COLCUR( IX, IY )
	CALL DEFCOL
	CALL CURSOR( IX, IY )
	RETURN
	END

    	SUBROUTINE COLSTR( ICOL, MSGARA )
	INTEGER MSGARA( 16 )
	CALL PCOLOR( ICOL )
	CALL STRING( MSGARA )
	RETURN
	END
