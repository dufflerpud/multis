C	@HDR@	$Id$
C	@HDR@		Copyright 1982-2025 by
C	@HDR@		Christopher Caldwell/Brightsands
C	@HDR@		P.O. Box 401, Bailey Island, ME 04003
C	@HDR@		All Rights Reserved
C	@HDR@
C	@HDR@	This software comprises unpublished confidential information
C	@HDR@	of Brightsands and may not be used, copied or made available
C	@HDR@	to anyone, except in accordance with the license under which
C	@HDR@	it is furnished.
	SUBROUTINE DEFCOL

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	CALL PCOLOR( ICLWHI )
	CALL PBACK( ICLBLA )
	RETURN
	END

	REAL FUNCTION COSDEG( DEG )
	COSDEG = COS( DEG * 3.141592654/180.0 )
	RETURN
	END

	REAL FUNCTION SINDEG( DEG )
	SINDEG = SIN( DEG * 3.141592654/180.0 )
	RETURN
	END


	REAL FUNCTION SMCOS( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMCOS = COSDEG( D )
	RETURN
	END

	REAL FUNCTION SMSIN( DEG )
	LOGICAL NEWANG
	COMMON/NHCOM/NEWANG
	D = DEG
	IF( NEWANG ) D = 90.0 - D
	SMSIN = SINDEG( D )
	RETURN
	END

	SUBROUTINE INITDB
C
	CALL ENABLE
	CALL INIT( 1, 1, 100, 100, 30 )
	CALL INIT( 2, 7, 400, 5 )
	CALL INIT( 3, 36, 5 )
	CALL INIT( 4, 7, 26, 2 )
C
	DO 100 IXT = 1, 100
	    IX = IXT
	    DO 100 IYT = 1, 100
		IY = IYT
		CALL PUTVAL( 1, IX, IY, 5, 1 )
		IF( MOD( IX-5,10 ).NE.0.OR.MOD( IY,10 ).NE.0 ) GOTO 100
		CALL MAKOBJ( IX, IY, 6, 4 )
100	CONTINUE
C
	DO 400 IYT = 1, 76
	    IY = IYT
	    DO 300 IZT = 1, 4
		IZ = IZT
		IF( IZ .NE. 2 .OR. MOD(IY-1,5) .NE. 0 ) GOTO 200
		CALL MAKOBJ( 48, IY, IZ, 3 )
		CALL MAKOBJ( 52, IY, IZ, 3 )
		GOTO 300
200		CALL PUTVAL( 1, 48, IY, IZ, 1 )
		CALL PUTVAL( 1, 52, IY, IZ, 1 )
300	    CONTINUE
	    DO 400 IXT = 49, 51
		IX = IXT
		CALL PUTVAL( 1, IX, IY, 5, 0 )
		CALL PUTVAL( 1, IX, IY, 1, 1 )
400	CONTINUE
C
	DO 500 IXT = 48, 52
	    IX = IXT
	    DO 500 IZT = 1, 4
		IZ = IZT
		CALL PUTVAL( 1, IX, 76, IZ, 1 )
500	CONTINUE
C
	CALL MAKOBJ( 50, 76, 3, 2 )
	CALL MAKOBJ( 50, 76, 6, 4 )
C
	CALL PUTVAL( 3, 4, 60*30 )
	CALL PUTVAL( 3, 5, -1 )
	CALL UNLOCK
	RETURN
	END
	SUBROUTINE PRINT
C
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA
C
	CALL USRSET( "2002, 1 )
	CALL CLRSCR
	CALL COLCUR( 1, 24 )
	CALL STRING('+(   ,   ,   ) Azi:    Elv:    Rol:   +^E')
	CALL PBACK( ICLWHI )
	DO 100 IY = 1, 19
	    CALL CURSOR( 1, 24-IY )
	    CALL CHROUT('|')
	    CALL CURSOR( 39, 24-IY )
	    CALL CHROUT('|')
100	CONTINUE
	CALL PBACK( ICLBLA )
	CALL COLCUR( 1, 4 )
	CALL STRING('+Vel:    D-Deg:    D-Spd:    Rol/s:   +^E')
	CALL CURSOR( 45, 24 )
	CALL STRING('Time:^E')
	CALL CURSOR( 45, 23 )
	CALL STRING('Rebel ships:^E')
	CALL CURSOR( 45, 22 )
	CALL STRING('Empire ships:^E')
	CALL CURSOR( 1, 1 )
	CALL STRING('Command:^E')
	RETURN
	END

	FUNCTION ICHCOD( ICH, IFG, IBG )
	IF( ICH .LT. 0 .OR. ICH .GT. 256 ) ICH = ICON( ICH )
	ICHCOD = 256*256*IFG + 256*IBG + ICH
	RETURN
	END
	SUBROUTINE UPDSCR( X, Y, Z, D, E, PIT, ICHAR, IPLAYR )
C
	IMPLICIT INTEGER ( A - Z )
	INTEGER SCREEN( 19, 19 ), OSCR( 19, 19 ), PRILST( 7 )
	REAL XP, YP, XR, YR, ZR, D, E, PIT
	LOGICAL NEXT, GOOD

	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA

	IF( PRILST(1) .NE. 0 ) GOTO 3
	PRILST(1) = ICHCOD( ' ', ICLWHI, ICLBLA )	! Space or wall
	PRILST(2) = ICHCOD( '.', ICLLBL, ICLBLA )	! Edge/corner/end
	PRILST(3) = ICHCOD( '@', ICLRED, ICLYEL )	! The port
	PRILST(4) = ICHCOD( '*', ICLPUR, ICLBLA )	! Trench Gun
	PRILST(5) = ICHCOD( '^', ICLPUR, ICLRED )	! Surface gun
	PRILST(6) = ICHCOD( '+', ICLWHI, ICLBLA )
	PRILST(7) = ICHCOD( '%', ICLRED, ICLYEL )	! Explosion particle
C
3	CALL GETVAL( 3, 5, ITIM )
	IF( ITIM .LT. 0 ) GOTO 5
	CALL COLCUR( 45, 20 )
	CALL COLSTR(ICLRED,'Death star explodes in ^E')
	CALL NUMBER( ITIM )
	CALL STRING(' seconds. ^G^E')

5	CALL GETVAL( 3, 4, ITIM )
	CALL COLCUR( 51, 24 )
	CALL NUMBER( ITIM/60, 2 )
	CALL CHROUT(':')
	CALL NUMBER( ITIM-60*(ITIM/60), -2 )
	IF( X.EQ.OX.AND.Y.EQ.OY.AND.Z.EQ.OZ.AND.ICHAR.NE.'N' ) GOTO 100
	CALL COLCUR( 3, 24 )
	CALL NUMBER( X-50, 3 )
	OX = X
	CALL CHROUT(',')
	CALL NUMBER( Y-76, 3 )
	OY = Y
	CALL CHROUT(',')
	CALL NUMBER( Z-5, 3 )
	OZ = Z
100	IF( IFIX(D).EQ. OD .AND. ICHAR .NE. 'N' ) GOTO 200
	CALL COLCUR( 20, 24 )
	CALL NUMBER( IFIX(D), 3 )
	OD = D
200	IF(IFIX(E).EQ. OE .AND. ICHAR .NE. 'N' ) GOTO 300
	CALL COLCUR( 28, 24 )
	CALL NUMBER( IFIX(E), 3 )
	OE = E
300	IF( IFIX(PIT) .EQ. OPIT .AND. ICHAR .NE. 'N' ) GOTO 400
	CALL COLCUR( 36, 24 )
	CALL NUMBER( IFIX(PIT), 3 )
	OPIT = PIT
400	CALL SETVEW(FLOAT(X),FLOAT(Y),FLOAT(Z),D,E,45.,18.9999,PIT)
C
	IF( Z .LT. 5 ) GOTO 501
	DO 500 IT = 1, 100
	    I = IT
	    CALL PRSPEC( FLOAT(I), 1., 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 1., FLOAT(I), 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( FLOAT(I), 100., 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 100., FLOAT(I), 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
500	CONTINUE
501	CONTINUE
C
	DO 600 YT1 = 1, 75
	    Y1 = YT1
	    CALL PRSPEC( 48., FLOAT(Y1), 1., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 52., FLOAT(Y1), 1., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 48., FLOAT(Y1), 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 52., FLOAT(Y1), 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
600	CONTINUE
C
	DO 700 XT1 = 48, 52
	    X1 = XT1
	    CALL PRSPEC( FLOAT(X1), 76., 1., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( FLOAT(X1), 76., 5., XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
700	CONTINUE
C
	DO 800 ZT1 = 2, 4
	    Z1 = ZT1
	    CALL PRSPEC( 48., 76., FLOAT(Z1), XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
	    CALL PRSPEC( 52., 76., FLOAT(Z1), XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = 1
800	CONTINUE
C
	CALL GETVAL( 3, 1, OBJNUM )
	DO 900 I = 1, OBJNUM
	    IOBJ = I
	    CALL GETVAL( 2, IOBJ, 1, X1 )
	    XR = X1
	    CALL GETVAL( 2, IOBJ, 2, Y1 )
	    YR = Y1
	    CALL GETVAL( 2, IOBJ, 3, Z1 )
	    ZR = Z1
	    DIST =SQRT((XR-X+0.0)^2+(YR-Y+0.0)^2+(ZR-Z+0.0)^2)
	    IF( DIST .EQ. 0 .OR. DIST .GT. 20 ) GOTO 900
	    CALL GETVAL( 2, IOBJ, 4, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 900
	    CALL PRSPEC( XR, YR, ZR, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    IF( DIST .GT. 5 ) GOTO 900
	    CALL PRSPEC( XR-.5, YR-.5, ZR-.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR+.5, YR-.5, ZR-.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR-.5, YR+.5, ZR-.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR+.5, YR+.5, ZR-.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR-.5, YR-.5, ZR+.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR+.5, YR-.5, ZR+.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR-.5, YR+.5, ZR+.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
	    CALL PRSPEC( XR+.5, YR+.5, ZR+.5, XP, YP, GOOD )
	    IF( GOOD )  SCREEN( IFIX(XP+1.), IFIX(YP+1.) ) = IVAL
900	CONTINUE
C
	DO 1100 Y1 = 1, 19
	    NEXT = .FALSE.
	    DO 1100 X1 = 1, 19
		IF( ICHAR .EQ. 'N' )  OSCR(X1,Y1) = 0
		ISCR = SCREEN(X1,Y1)
		IF( ISCR .EQ. OSCR(X1,Y1) ) GOTO 1000
		IF( NEXT )  CALL CHROUT(' ')
		IF( .NOT. NEXT )  CALL CURSOR( X1*2, Y1+4 )
		IF( ISCR .GE. 7 ) GOTO 950
		ICH = PRILST(ISCR+1)
		IFG = ICH / 256 / 256
		IBG = MOD( ICH / 256, 256 )
		ICH = MOD( ICH, 256 )
		GOTO 970
950		ICH = ISCR - 6
		IF( (ICH.LE.13) .EQ. (IPLAYR.LE.13) ) GOTO 960
		IBG = ICLRED
		IFG = ICLPUR
		ICH = ICH + 64
		GOTO 970
960		IBG = ICLDBL
		IFG = ICLLBL
		ICH = ICH + 64
970		CALL PBACK( IBG )
		CALL PCOLOR( IFG )
		CALL CHROUT( ICH )
		OSCR( X1, Y1 ) = ISCR
		SCREEN(X1,Y1) = 0
		NEXT = .TRUE.
		GOTO 1100
1000		SCREEN(X1,Y1) = 0
		NEXT = .FALSE.
1100	CONTINUE
	RETURN
	END
	SUBROUTINE COMAND( ICHAR, COMARA, ARRIND )
C
C  --   ROUTINE GET COMMAND FROM USER IF ONE PRESENT.
C
	INTEGER COMARA(61), INDEX, ARRIND, ICHAR
	DATA INDEX/0/
C
C  --   IF THERE IS A CHARACTER OUT GET IT, ELSE, SLEEP FOR
C  --   0.5 SECONDS OR UNTIL ONE IS.
C
100	CALL NAP( 500, "14 )
	CALL CHRBUF( ICHAR )
	IF( ICHAR .EQ. -1 )  RETURN
	IF( ICHAR .EQ. "10 .OR. ICHAR .EQ. "177 ) GOTO 200
	IF( ICHAR .EQ. "25 ) GOTO 300
	IF( ICHAR .LT. "40 ) GOTO 500
	IF( INDEX .GE. 60 ) GOTO 600
C
C  --   NOT SPECIAL CHARACTER, PUT IN ARRAY
C
	INDEX = INDEX + 1
	CALL COLCUR( 9 + INDEX, 1 )
	IF( ICHAR .GE. 97 )  ICHAR = ICHAR - 32
	CALL CHROUT( ICHAR )
	CALL OUTBUF( 1 )
	COMARA(INDEX) = ICON( ICHAR )
	IF( INDEX .NE. 1 ) GOTO 100
	IF( ICHAR .LT. 65 .OR. ICHAR .GT. 90 ) GOTO 500
	ICHAR = ICON( ICHAR )
	IF( ICHAR.EQ.'A' .OR. ICHAR.EQ.'D' .OR. ICHAR.EQ.'T' ) GOTO 500
	GOTO 100
C
C  --   DELETE CHARACTER
C
200	CALL COLCUR( 9 + INDEX, 1 )
	CALL CHROUT( ' ' )
	CALL OUTBUF( 1 )
	INDEX = INDEX - 1
	IF( INDEX .LT. 0 )  INDEX = 0
	GOTO 100
C
C  --   DELETE LINE
C
300	CALL COLCUR( 10, 1 )
	DO 400 I = 1, INDEX
	    CALL CHROUT(' ')
400	CONTINUE
	CALL OUTBUF( 1 )
	INDEX = 0
	GOTO 100
C
C  --   CARRIAGE RETURN TYPED
C
500	IF( INDEX .EQ. 0 ) GOTO 100
600	COMARA(INDEX + 1) = 0
	CALL COLCUR( 10, 1 )
	DO 700 I = 1, INDEX
	CALL CHROUT(' ')
700	CONTINUE
	CALL OUTBUF( 1 )
	CALL NAP( 500, 4 )
	ICHAR = COMARA(1)
	ARRIND = INDEX
	INDEX = 0
	RETURN
	END
	SUBROUTINE MESSAG( ICOL, MSGARA )
C
C	The following gets replaced with character msgara(80) before being
C	handed to GNU g77.
	INTEGER MSGARA( 16 )
C
	CALL COLCUR( 1, 2 )
	CALL REPEAT(' ',79)
	CALL CURSOR( 1, 2 )
	CALL COLSTR( ICOL, MSGARA )
	RETURN
	END
	SUBROUTINE CEASE( ISHIP, ICOL, MSGARA )
C
C	The following gets replaced with character msgara(80) before being
C	handed to GNU g77.
	INTEGER MSGARA( 16 )

	CALL MESSAG( ICOL, MSGARA )
	CALL CLOSE( 1 )
	CALL UNLOCK
	CALL GETVAL( 2, ISHIP, 4, IVAL )
	CALL PUTVAL( 4, IVAL-6, 1, 0 )
	CALL PUTVAL( 4, IVAL-6, 2, 0 )
	CALL ADDVAL( 3, 3, -1 )
	CALL DELOBJ( ISHIP )
	CALL USRSET( "2007, 0 )
	CALL USRSET( "2002, 0 )
	CALL USRSET( "2021, 1 )
C
	CALL EXPROG
C
	END
	SUBROUTINE MAKOBJ( X, Y, Z, VAL )
C
	IMPLICIT INTEGER ( A - Z )
C
	CALL GETVAL( 3, 1, LASTOB )
	CALL GETVAL( 3, 2, LASTPT )
	LASTPT = LASTPT + 1
	IF( LASTPT .GE. LASTOB ) GOTO 101
	DO 100 IOBJ = LASTPT, LASTOB
	    CALL GETVAL( 2, IOBJ+0, 4, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 200
100	CONTINUE
101	CONTINUE
	IOBJ = LASTOB + 1
	CALL PUTVAL( 3, 1, IOBJ )
C
200	CALL PUTVAL( 3, 2, IOBJ )
	CALL PUTVAL( 2, IOBJ, 1, X )
	CALL PUTVAL( 2, IOBJ, 2, Y )
	CALL PUTVAL( 2, IOBJ, 3, Z )
	CALL PUTVAL( 2, IOBJ, 4, VAL )
	CALL PUTVAL( 1, X, Y, Z, 1 )
	RETURN
	END
	SUBROUTINE DELOBJ( IOBJ )
C
	CALL GETVAL( 2, IOBJ, 1, IX )
	CALL GETVAL( 2, IOBJ, 2, IY )
	CALL GETVAL( 2, IOBJ, 3, IZ )
	CALL PUTVAL( 1, IX, IY, IZ, 0 )
	CALL PUTVAL( 2, IOBJ, 4, 0 )
	CALL GETVAL( 3, 2, IVAL )
	IF( IVAL .GT. IOBJ )  CALL PUTVAL( -3, IOBJ )
	RETURN
	END
	INTEGER FUNCTION NUMOBJ( X, Y, Z )
C
	IMPLICIT INTEGER ( A - Z )
C
	CALL GETVAL( 3, 1, NUMOBJ )
C
	DO 100 IOBJ = 1, NUMOBJ
	    NUMOBJ = IOBJ
	    CALL GETVAL( 2, NUMOBJ, 1, IVAL )
	    IF( IVAL .NE. X ) GOTO 100
	    CALL GETVAL( 2, NUMOBJ, 2, IVAL )
	    IF( IVAL .NE. Y ) GOTO 100
	    CALL GETVAL( 2, NUMOBJ, 3, IVAL )
	    IF( IVAL .NE. Z ) GOTO 100
	    CALL GETVAL( 2, NUMOBJ, 4, IVAL )
	    IF( IVAL .NE. 0 )  RETURN
100	CONTINUE
	NUMOBJ = 0
	RETURN
	END
	SUBROUTINE INRANG( DEG )
C
100	IF( DEG .GE. 0 ) GOTO 200
	DEG = DEG + 360
	GOTO 100
200	IF( DEG .LT. 360 )  RETURN
	DEG = DEG - 360
	GOTO 200
	END
	SUBROUTINE EXPLOD( X, Y, Z, F )
C
	IMPLICIT INTEGER ( A - Z )
C
	DO 200 I = 1, F*8
	    XDIR = IRAN(3)-2
	    YDIR = IRAN(3)-2
	    ZDIR = IRAN(3)-2
	    DO 100 J = 1, F
		NX = X + XDIR*J
		NY = Y + YDIR*J
		NZ = Z + ZDIR*J
		IF( NX .LT. 1 .OR. NX .GT. 100 .OR. NY .LT. 1 .OR.          NY .
     &GT. 100 .OR. NZ .LT. 1 .OR. NZ .GT. 30 ) GOTO 200
		CALL GETVAL( 1, NX, NY, NZ, IVAL )
		IF( IVAL .NE. 0 ) GOTO 200
		CALL MAKOBJ( NX, NY, NZ, 6 )
		CALL PUTVAL( 2, NUMOBJ( NX, NY, NZ ), 5, 10 )
100	    CONTINUE
200	CONTINUE
	RETURN
	END
	SUBROUTINE DUMP
C
	IMPLICIT INTEGER ( A - Z )
C
	INTEGER FILESP( 13 )
C
	FILESP( 3 ) = ISXBIT('DSK')
	FILESP( 4 ) = ISXBIT('WAR')
	FILESP( 5 ) = ISXBIT('DMA')
	FILESP( 5 ) = FILESP( 5 ) + NMTHRU*"1000000
	CALL OFILE( 2, FILESP, 0 )
	CALL WFILE( 2, FILESP )
	NMTHRU = NMTHRU + 1
	CALL SELECT( 2 )
	CALL GETVAL( 3, 1, NOBJ )
	CALL GETVAL( 3, 2, VAL )
	CALL STRING('Maximum object: ^E')
	CALL NUMBER( NOBJ )
	CALL STRING('.   Known to be filled in list: ^E')
	CALL NUMBER( VAL )
	CALL STRING('.^M^J^E')
	DO 100 I = 1, NOBJ
	    IOBJ = I
	    CALL GETVAL( 2, IOBJ, 1, X )
	    CALL GETVAL( 2, IOBJ, 2, Y )
	    CALL GETVAL( 2, IOBJ, 3, Z )
	    CALL GETVAL( 2, IOBJ, 4, VAL )
	    CALL NUMBER( IOBJ )
	    CALL COORD( X, Y, Z )
	    CALL NUMBER( VAL )
	    CALL CHROUT(':')
	    CALL GETVAL( 2, IOBJ, 5, VAL1 )
	    CALL NUMBER( VAL1 )
	    CALL GETVAL( 1, X, Y, Z, VAL1 )
	    CALL NUMBER( VAL1, 2 )
	    IF( (VAL.EQ.0).NE.(VAL1.EQ.0) ) CALL STRING('   *^E')
	    CALL CRLF
100	    CONTINUE
	CALL CLOSE( 2 )
	CALL SELECT( 1 )
	CALL MESSAG(ICLBLU,'[Data base #^E')
	CALL NUMBER( NMTHRU )
	CALL STRING(' dumped on war.^E')
	CALL STRING( IEXT, 6, 3 )
	CALL CHROUT(']')
	RETURN
	END
	SUBROUTINE PROBJ( IOBJ )
C
	IF( IOBJ .EQ. 0 )  CALL STRING('The death star^E')
	IF( IOBJ .EQ. 0 )  RETURN
	CALL GETVAL( 2, IOBJ, 4, IVAL )
	IF( IVAL .EQ. 1 )  CALL STRING('The death star^E')
	IF( IVAL .EQ. 2 )  CALL STRING('An exhaust port^E')
	IF( IVAL .EQ. 3 )  CALL STRING('A light laser tower^E')
	IF( IVAL .EQ. 4 )  CALL STRING('A heavy laser tower^E')
	IF( IVAL .EQ. 5 )  CALL STRING('A torpedo^E')
	IF( IVAL .EQ. 6 )  CALL STRING('An explosion particle^E')
	IF( IVAL .LE. 6 )  RETURN
	IF( IVAL .LE. 19 )  CALL STRING('The rebel-^E')
	IF( IVAL .GT. 19 )  CALL STRING('The empire-^E')
	CALL CHROUT( 58+IVAL )
	RETURN
	END
	SUBROUTINE COORD( IX, IY, IZ )
	CALL STRING('( ^E')
	CALL OUTNUM( IX-50, IY-76, IZ-5 )
	CALL STRING(' )^E')
	RETURN
	END
	SUBROUTINE SETVEW( XO, YO, ZO, DEG, ELV, VSPAN, WIDTH, ROTAT )
C
C
C	THIS SUBROUTINE SETS UP ALL THE NECESSARY VARIABLES
C	TO DETERMINE THE POSITION (IN PERSPECTIVE) ON A PLANE
C	OF A POINT IN 3 DIMENSIONS.  TO FIND THAT POINT, CALL
C	PRSPEC.
C
C	XO, YO, ZO	-	THE VIEW POINT IN SPACE
C	DEG, ELV	-	THE AZIMUTH AND ELEVATION OF THE
C				VIEW PROJECTION
C	VSPAN		-	THE MAXIMUM VIEW ANGLE
C	WIDTH		-	WIDTH OF VIEWING PLANE
C	ROTAT		-	HOW EYE IS ORIENTED TO THE SYSTEM
C
C
C
C			VIEWING PLANE (PERSPECTIVE)
C
C		     +(X1,Y1,Z1)
C		     !
C		     !
C		     !
C	-------------------------------------------------
C	:	     .		^			:
C	:	     .		+(XOFYP,YOFYP,ZOFYP)	:
C	:	     .		!			:
C	:	     +(X,Y,Z)	!			:
C	:	     !		!			:
C	:	     !		!   (XOFXP,YOFXP,ZOFXP) :
C	:	     !		+------<-PDIST->------+>:
C	:	     !	    (XC,YC,ZC)			:
C	:	     !	      /				:
C	:	     !	   DIST				:
C	:	     !	    /				:
C	:	     !	   / ->				:
C	:	     !	  /  N = (A,B,C)		:
C	-------------!---/------------------------------:
C		     !	/
C		     ! /
C		     !/
C		     +(X0,Y0,Z0)
C
	REAL SMSIN, SMCOS, COSDEG, SINDEG
	LOGICAL NEWANG

	COMMON/NHCOM/NEWANG
	COMMON /PRSCOM/ X0,Y0,Z0,XOFXP,YOFXP,ZOFXP,XOFYP,YOFYP,ZOFYP,
     &	A, B, C, PDIST, XC, YC, ZC, PCOS, PSIN

C
C
C	COPY VIEW POINT FOR COMMON
	X0 = XO
	Y0 = YO
	Z0 = ZO
C	CALCULATE HALF PLANE, 3RD SIDE AND NORMAL DISTANCES
	PDIST = WIDTH/2.0
	CDIST = PDIST / SINDEG(VSPAN)
	DIST = SQRT( CDIST^2 - PDIST^2 )
C
C	THE VIEW PROJECTION IS THE NORMAL TO THE PLANE SO
C	VECTOR N = (A,B,C) AND THE PLANE'S EQUATION IS
C	A*X + B*Y + C*Z = D.  GO FIND A, B AND C
	A = SMCOS(DEG)*COSDEG(ELV)*DIST
	B = SMSIN(DEG)*COSDEG(ELV)*DIST
	C = SINDEG(ELV)*DIST
C
C	DETERMINE THE ORIGIN OF THE PLANE
	XC = X0 + A
	YC = Y0 + B
	ZC = Z0 + C
C
C	NOW DETERMINE THE UNIT VECTORS FOR THE PLANE.
C	FOR VECTOR YP:
	XOFYP = (X0 + SMCOS(DEG)*COSDEG(ELV+VSPAN)*CDIST - XC )/PDIST
	YOFYP = (Y0 + SMSIN(DEG)*COSDEG(ELV+VSPAN)*CDIST - YC )/PDIST
	ZOFYP = (Z0 + SINDEG(ELV+VSPAN)*CDIST - ZC )/PDIST
C
C	FOR VECTOR XP:
	XOFXP = B*ZOFYP - C*YOFYP
	YOFXP = C*XOFYP - A*ZOFYP
C	ZOFXP = A*YOFYP - B*XOFYP
	ZOFXP = 0
C
C	NOW CONVERT XP TO A UNIT VECTOR
	DFACT = SQRT( XOFXP^2 + YOFXP^2 )
	XOFXP = XOFXP / DFACT
	YOFXP = YOFXP / DFACT
C
C	NOW FIND THE FACTORS TO DETERMINE ROLL
	IF( NEWANG ) GOTO 1000
	PCOS = COSDEG( ROTAT )
	PSIN = SINDEG( ROTAT )
	GOTO 2000
1000	PCOS = COSDEG( -ROTAT )
	PSIN = SINDEG( -ROTAT )
2000	RETURN
	END
	SUBROUTINE PRSPEC( X1, Y1, Z1, FXP, FYP, DONE )
C
C	X1, Y1, Z1  -	POINT TO TRANSFORM
C	FXP, FYP    -	RESULTING POINT
C	DONE	    -	LOGICAL TRUE IF NO ERROR
C
	COMMON /PRSCOM/ X0,Y0,Z0,XOFXP,YOFXP,ZOFXP,XOFYP,YOFYP,ZOFYP,
     &	A, B, C, PDIST, XC, YC, ZC, PCOS, PSIN
C
	LOGICAL DONE
C
	DONE = .FALSE.
	XP = 0
	YP = 0
C
C	(X,Y,Z) WILL BE THE POINT WHERE THE PROJECTION MEETS THE PLANE.
C	DETERMINE THE DIRECTION VECTOR (XD,YD,ZD).
	XD = X1 - X0
	YD = Y1 - Y0
	ZD = Z1 - Z0
C
C		NOW WE KNOW THAT
C	D = A*( X0 + A )  +  B*( Y0 + B )  +  C*( Z0 + C )
C		AND
C	D = A*( X0 + R*XD )  +  B*( Y + R*YD )  +  C*( Z0 + R*ZD )
C		SO
	R = ( A^2 + B^2 + C^2 ) / ( A*XD + B*YD + C*ZD )
C
C	IF R < 0 THEN OBJECT BEHIND VIEW POINT
	IF( R .LT. 0 ) RETURN
C
C	NOW, CALCULATE THE POINT WHERE THE LINES MEETS THE PLANE
	X = X0 + R*XD
	Y = Y0 + R*YD
	Z = Z0 + R*ZD
C
C	SINCE (X,Y,Z) = XP*(XOFXP,YOFXP,ZOFXP) + YP*(XOFYP,YOFYP,ZOFYP)
C	THEN
C	X-XC = XP*XOFXP + YP*XOFYP
C	Y-YC = XP*YOFXP + YP*YOFYP
C	Z-ZC = XP*ZOFXP + YP*ZOFYP
C
C	3 EQUATIONS, 2 UNKNOWNS (XP AND YP).  BY SUBSTITUTION:
	DENOM = XOFXP*YOFYP - YOFXP*XOFYP
	IF( ABS( DENOM ) .LT. 0.001 ) GOTO 10
	YP = ((Y-YC)*XOFXP - (X-XC)*YOFXP) / DENOM
	GOTO 100
10	DENOM = XOFXP*ZOFYP - ZOFXP*XOFYP
	IF( ABS( DENOM ) .LT. 0.001 ) GOTO 20
	YP = ((Z-ZC)*XOFXP - (X-XC)*ZOFXP) / DENOM
	GOTO 100
20	DENOM = YOFXP*ZOFYP - ZOFXP*YOFYP
	IF( ABS( DENOM ) .LT. 0.001 ) RETURN
	YP = ((Z-ZC)*YOFXP - (Y-YC)*ZOFXP) / DENOM
100	IF( ABS( XOFXP ) .LT. 0.001 ) GOTO 110
	XP = ((X-XC) - YP*XOFYP)/XOFXP
	GOTO 200
110	IF( ABS( YOFXP ) .LT. 0.001 ) GOTO 120
	XP = ((Y-YC) - YP*YOFYP)/YOFXP
	GOTO 200
120	IF( ABS( ZOFXP ) .LT. 0.001 ) RETURN
	XP = ((Z-ZC) - YP*ZOFYP)/ZOFXP
200	CONTINUE
	FXP = PCOS*XP + PSIN*YP 
	FYP = PCOS*YP - PSIN*XP

C	NAN TESTS (NOT REQUIRED UNDER TOPS10)
	IF( .NOT. ((FXP .LT. 0.0) .OR. (FXP .GE. 0.0) ) ) RETURN
	IF( .NOT. ((FYP .LT. 0.0) .OR. (FYP .GE. 0.0) ) ) RETURN

	IF( ABS(FXP).GT.PDIST .OR. ABS(FYP).GT.PDIST ) RETURN
	FXP = FXP + PDIST
	FYP = FYP + PDIST
	DONE = .TRUE.
	RETURN
	END

	SUBROUTINE SYSWHO( IJOB )
	INTEGER UNAME(2)
	IF( JOB(IJOB) .EQ. 0 ) RETURN
	CALL STRING('Job ^E')
	CALL NUMBER( IJOB )
	CALL CHROUT(' ')
	UNAME(1) = IGTAB( IJOB, "31 )
	UNAME(2) = IGTAB( IJOB, "32 )
	CALL STRING( UNAME, 6, 12 )
	CALL STRING(' [^E')
	CALL NUMBER( ILEFT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL CHROUT(',')
	CALL NUMBER( IRIGHT( IGTAB( IJOB, 2 ) ), 0, 8 )
	CALL STRING('] ^E')
	CALL STRING(' TTY^E')
	CALL NUMBER( ITTY( IJOB ), 0, 8 )
	CALL STRING(' at ^E')
	CALL NODLIN( ITTY(IJOB), IN, IL )
	CALL STRING( NODE( IN ), 6, 6 )
	CALL CHROUT('(')
	CALL NUMBER( IN, 0, 8 )
	CALL STRING(')^E')
	CALL STRING(' line ^E')
	CALL NUMBER( IL, 0, 8 )
	CALL CHROUT(' ')
	CALL STRING( JSTAT( IJOB ), 6, 2 )
	RETURN
	END

	SUBROUTINE WHO( ILETR )
C
C***    SUBROUTINE PRINTS OUT STATISTICS ON USER
C
	IJOB = 0
	IF(ILETR.GT.0.AND.ILETR.LE.27)CALL GETVAL(4,ILETR,1,IJOB)
	IF( IJOB .EQ. 0 )  CALL MESSAG(ICLYEL,'No one^E')
	IF( IJOB .EQ. 0 )  RETURN
	IF( ILETR .LE. 13 ) CALL MESSAG(ICLLBL,'Rebel-^E')
	IF( ILETR .GT. 13 ) CALL MESSAG(ICLLBL,'Empire-^E')
	CALL CHROUT( ILETR+64 )
	CALL STRING(': ^E')
	CALL SYSWHO( IJOB )
	CALL CRLF
	RETURN
	END
	SUBROUTINE FMAIN
C
	IMPLICIT INTEGER ( B - Z )
C
	INTEGER SCREEN( 19, 19 ), OSCR( 19, 19 ), COMARA( 61 ), PAR(20)
	INTEGER FILSPC( 13 )
	REAL AX, AY, AZ, E, D, ROLLAM, DVEC, SMCOS, SMSIN
	REAL COSDEG, SINDEG
	LOGICAL MISS, INIFLG, LPRIVD, NEWANG

	COMMON/NHCOM/NEWANG
C
	COMMON /COL/ICLWHI,ICLDBL,ICLRED,ICLLBL,
     &			ICLPUR,ICLGRE,ICLYEL,ICLBLA
	DATA ICHAR/'N'/, NTORP/4/
C
	ICLWHI = 1
	ICLDBL = 2
	ICLRED = 3
	ICLLBL = 4
	ICLPUR = 5
	ICLGRE = 6
	ICLYEL = 7
	ICLBLA = 8

	CALL PPN( I, IPN )

	CALL SETTTY( COMARA, PAR, ILEN, LPRIVD, FILSPC )

	NEWANG = .TRUE.
	DO 10 I=1, ILEN
	    IF( PAR(I) .EQ. ISXBIT('OLDANG') ) NEWANG = .FALSE.
10	CONTINUE

100	CALL CHECK( INIFLG )
	IF( INIFLG )  CALL INITDB
	CALL CTRAP
	CALL EXPROG
C
200	CALL DEFCOL
	CALL STRING('^MInput character to represent ship:       ^M^E')
	CALL STRING('Input character to represent ship: ^B')
	CALL CHRWAT( IPLAYR )
	IF( IPLAYR .GT. 96 ) IPLAYR = IPLAYR - 32
	IPLAYR = IPLAYR - 64
	IF( IPLAYR .LT. 1 .OR. IPLAYR .GT. 26 ) GOTO 200
	CALL GETVAL( 4, IPLAYR, 1, IVAL )
	IF( IVAL .NE. 0 ) GOTO 200
	CALL PUTVAL( -4, JOB(0) )
	CALL PUTVAL( 4, IPLAYR, 2, 0 )
	AX = 1.
	IF( IPLAYR .GT. 13 )  AX = 100.
	X = AX
	AZ = 20.
	Z = AZ
300	AY = IRAN(100)
	Y = AY
	D = 0
	IF( IPLAYR .GT. 13 )  D = 180
	IF( .NOT. NEWANG ) GOTO 305
	D = 90 - D
	IF( D .LT. 0 ) D = D + 360
305	CALL GETVAL( 1, X, Y, Z, IVAL )
	IF( IVAL .NE. 0 ) GOTO 300
	CALL MAKOBJ( IFIX(AX+.5), IFIX(AY+.5), IFIX(AZ+.5), IPLAYR+6 )
	SHIPNM = NUMOBJ( X, Y, Z )
	CALL ADDVAL( 3, 3, 1 )
	CALL CTRAP
	CALL CEASE( SHIPNM, ICLLBL, 'Stopping on user request.^E')
C
	CALL OFILE( 1, ISXBIT('TTY'), "10 )
	CALL SELECT( 1 )
	CALL USRSET("2006,"1)
	CALL USRSET("2025,"0)
	CALL USRSET("2007,"1)
	CALL USRSET("2010,"1)
	CALL USRSET("2021,"0)
	CALL USRSET("1030,TTYSPD)
	GOTO 500
C
C***********************
C***    GAME LOOP    ***
C***********************
C
400	CALL USRSET("2030,TTYSPD)
	CALL USRSET("2031,TTYSPD)
	CALL GETVAL( 3, 4, IVAL )
	IF( IVAL .GT. 0 ) GOTO 405
	CALL CEASE( SHIPNM, ICLRED,
     & 'The rebel base has been destroyed.^E')

405	CALL GETVAL( 3, 5, IVAL )
	IF( IVAL .NE. 0 ) GOTO 410
	CALL CEASE( SHIPNM, ICLRED,
     & 'The death star has been destroyed.^E')

410	CALL COMAND( ICHAR, COMARA, INDEX )
	CALL OUTBUF( 1 )
	IF( ICHAR .EQ. -1 ) GOTO 3100
C
	IF( ICHAR .NE. 'N' ) GOTO 600
500	CALL PRINT
	GOTO 3100
C
600	IF( ICHAR .NE. 'E' ) GOTO 700
	CALL CEASE( SHIPNM, ICLLBL, 'Stopping on user request.^E')
C
700	IF( ICHAR .NE. 'A' ) GOTO 800
	IF( IPLAYR .GT. 13 .AND. SPEED .GE. 10 ) GOTO 3100
	IF( SPEED .GE. 15 ) GOTO 800
	SPEED = SPEED + 1
	GOTO 3100
C
800	IF( ICHAR .NE. 'D' ) GOTO 900
	SPEED = SPEED - 1
	IF( SPEED .LE. -5 ) GOTO 3100
	GOTO 3100
C
900	IF( ICHAR .NE. 'P' ) GOTO 1000
	IF( .NOT. LPRIVD ) GOTO 1000
C	CHANGED TO INTEGER GETNUM SINCE NO WAY FOR MODERN GETNUM TO KNOW IF
C	ARGS ARE REAL OR INTEGERS
	CALL GETNUM(COMARA,INDEX,IAX,10,IAY,10,IAZ,10,
     & IDEGRE,10,IELEV,10,IROLL,10)
	YAW = 0
	PITCH = 0
	ROLL = 0
	SPEED = 0
	AX = IAX + 50.
	AY = IAY + 75.
	AZ = IAZ + 5.
	D = IDEGRE
	E = IELEV
	ROLLAM = IROLL
	GOTO 3100
C
1000	IF( ICHAR .NE. '1' ) GOTO 1100
	YAW = YAW + 1
	PITCH = PITCH - 1
	GOTO 3100
C
1100	IF( ICHAR .NE. '2' ) GOTO 1200
	PITCH = PITCH - 1
	GOTO 3100
C
1200	IF( ICHAR .NE. '3' ) GOTO 1300
	YAW = YAW - 1
	PITCH = PITCH - 1
	GOTO 3100
C
1300	IF( ICHAR .NE. '4' ) GOTO 1400
	YAW = YAW + 1
	GOTO 3100
C
1400	IF( ICHAR .NE. '5' ) GOTO 1500
	YAW = 0
	PITCH = 0
	ROLL = 0
	GOTO 3100
C
1500	IF( ICHAR .NE. '6' ) GOTO 1600
	YAW = YAW - 1
	GOTO 3100
C
1600	IF( ICHAR .NE. '7' ) GOTO 1700
	YAW = YAW + 1
	PITCH = PITCH + 1
	GOTO 3100
C
1700	IF( ICHAR .NE. '8' ) GOTO 1800
	PITCH = PITCH + 1
	GOTO 3100
C
1800	IF( ICHAR .NE. '9' ) GOTO 1900
	YAW = YAW - 1
	PITCH = PITCH + 1
	GOTO 3100
C
1900	IF( ICHAR .NE. '<' .AND. ICHAR .NE. ',' ) GOTO 2000
	ROLL = ROLL + 1
	GOTO 3100
C
2000	IF( ICHAR .NE. '>' .AND. ICHAR .NE. '.' ) GOTO 2100
	ROLL = ROLL - 1
	GOTO 3100
C
2100	IF( ICHAR .NE. 'B' ) GOTO 2200
	CALL GETNUM( COMARA, INDEX, IX, 10, IY, 10, IZ, 10, B, 10 )
	CALL EXPLOD( IX, IY, IZ, B )
	GOTO 3100
C
2200	IF( ICHAR .NE. '0' .AND. ICHAR .NE. 'T' ) GOTO 2800
	IF( IPLAYR .GT. 13 .AND. ICHAR .EQ. 'T' ) GOTO 2800
	IF( ICHAR .NE. 'T' ) GOTO 2205
	IF( NTORP .GT. 0 ) GOTO 2204
	CALL MESSAG(ICLYEL,'All torpedos are expended.^E')
	GOTO 3100
2204	NTORP = NTORP - 1
2205	MISS = .TRUE.
	DO 2300 DIST = 1, 20
	    PHASRX = AX + SMCOS(D)*COSDEG(E)*DIST + .5
	    IF( PHASRX .LT. 1 .OR. PHASRX .GT. 100 ) GOTO 2400
	    PHASRY = AY + SMSIN(D)*COSDEG(E)*DIST + .5
	    IF( PHASRY .LT. 1 .OR. PHASRY .GT. 100 ) GOTO 2400
	    PHASRZ = AZ + SINDEG(E)*DIST + .5
	    IF( PHASRZ .LT. 1 .OR. PHASRZ .GT. 30 ) GOTO 2400
	    CALL GETVAL( 1, PHASRX, PHASRY, PHASRZ, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 2300
	    IF( PHASRX .EQ. X .AND. PHASRY .EQ. Y .AND. PHASRZ .EQ. Z )
     & GOTO 2300
	    IVAL = NUMOBJ( PHASRX, PHASRY, PHASRZ )
	    IVAL1 = 0
	    IF( IVAL .GT. 0 ) CALL GETVAL( 2, IVAL, 4, IVAL1 )
	    IF( IVAL1 .EQ. 6 ) GOTO 2300
	    MISS = .FALSE.
	    IF(IVAL1.LT.6)  CALL EXPLOD(PHASRX,PHASRY,PHASRZ,IVAL1+1)
	    IF(IVAL1.GT.6)  CALL PUTVAL(4,IVAL1-6,2,1)
	    GOTO 2400
2300	CONTINUE
2400	IF( ICHAR .EQ. '0' ) GOTO 2450
	IF( MISS ) GOTO 3100
	CALL COLCUR( 19, 14 )
	CALL CHROUT('<')
	CALL COLCUR( 21, 14 )
	CALL CHROUT('>')
	GOTO 2701
2450	DO 2700 I = 1, 12
	    IF( I .GT. 9 ) GOTO 2600
	    CALL COLCUR( 39-2*I, I+4 )
	    CALL CHROUT('\')
	    CALL COLCUR( I*2+1, I+4 )
	    CALL CHROUT('/')
	    IF( IPLAYR .GT. 13 ) GOTO 2500
	    CALL COLCUR( I*2+1, 24-I )
	    CALL CHROUT('\')
	    CALL COLCUR( 39-2*I, 24-I )
	    CALL CHROUT('/')
2500	    IF( I .NE. 9 .OR. MISS ) GOTO 2600
	    CALL COLCUR( 19, 14 )
	    CALL CHROUT('(')
	    CALL COLCUR( 21, 14 )
	    CALL CHROUT(')')
2600	    IF( I .LE. 3 ) GOTO 2700
	    CALL COLCUR( 45-2*I, I+1 )
	    CALL CHROUT(' ')
	    CALL COLCUR( 2*I-5, I+1 )
	    CALL CHROUT(' ')
	    IF( IPLAYR .GT. 13 ) GOTO 2700
	    CALL COLCUR( 2*I-5, 27-I )
	    CALL CHROUT(' ')
	    CALL COLCUR( 45-2*I, 27-I )
	    CALL CHROUT(' ')
2700	CONTINUE
2701	CONTINUE
	IF( MISS ) GOTO 3100
	CALL COLCUR( 19, 14 )
	CALL CHROUT(' ')
	CALL COLCUR( 21, 14 )
	CALL CHROUT(' ')
	IF( ICHAR .EQ. '0' ) CALL MESSAG(ICLLBL,'Laser strikes ^E')
	IF( ICHAR .EQ. 'T' )
     & CALL MESSAG(ICLLBL,'Proton torpedo strikes ^E')
	CALL PROBJ( IVAL )
	CALL STRING(' at ^E')
	CALL COORD( PHASRX, PHASRY, PHASRZ )
	CALL CHROUT('.')
	IF(IVAL1.GT.2.AND.IVAL1.LT.7)CALL DELOBJ( IVAL )
	IF( IVAL1.NE.2 .OR. ICHAR.NE.'T' ) GOTO 3100
	IF( IRAN( IABS(Z-2) ) .GT. 1 ) GOTO 3100
	CALL PUTVAL( 3, 5, 30 )
	GOTO 3100
C
2800	IF( ICHAR .NE. 'W' ) GOTO 2900
	CALL WHO( ICON( COMARA(2) ) - 64 )
	GOTO 3100
C
2900	IF( ICHAR .NE. 'M' ) GOTO 3000
	CALL DUMP
	GOTO 3100
C
3000	CALL MESSAG(ICLYEL,'Illegal command.^E')
C
3100	AX = AX + SMCOS(D)*COSDEG(E)*SPEED/10.
	AY = AY + SMSIN(D)*COSDEG(E)*SPEED/10.
	AZ = AZ + SINDEG(E)*SPEED/10.
	IF(IFIX(AX+.5).EQ.X.AND.IFIX(AY+.5).EQ.Y.AND.IFIX(AZ+.5).EQ.Z)
     &  GOTO 3300
	CALL PUTVAL( 1, X, Y, Z, 0 )
	X = AX + 0.5
	Y = AY + 0.5
	Z = AZ + 0.5
	IF(X.LT.1 .OR. X.GT.100 .OR. Y.LT.1 .OR. Y.GT.100 .OR. Z.GT.30)
     &  GOTO 4600
	CALL GETVAL( 1, X, Y, Z, IVAL )
	IF( IVAL .EQ. 0 ) GOTO 3200
	IVAL = NUMOBJ( X, Y, Z )
	IF( IVAL .NE. 0 )  CALL GETVAL( 2, IVAL, 4, IVAL )
	IF( IVAL .LT. 6 )  CALL EXPLOD( X, Y, Z, (IVAL+1)*2 )
	IF( IVAL .GT. 6 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with a ship ***^G^E')
	IF( IVAL .LE. 1 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with the death star ***^G^E')
	IF( IVAL .EQ. 2 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with an exhaust port ***^G^E')
	IF( IVAL .EQ. 3 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with a light laser tower ***^G^E')
	IF( IVAL .EQ. 4 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with a heavy laser tower ***^G^E')
	IF( IVAL .EQ. 5 )  CALL CEASE( SHIPNM, ICLRED,
     & '*** Collision with a torpedo ***^G^E')
	CALL MESSAG(ICLYEL,'*** Ship buffetted in explosion ***^E')
	IFF = IABS( 17-SPEED ) / 3
	YAW = YAW + IRAN( IFF*2+1 ) - IFF-1
	PITCH = PITCH + IRAN( IFF*2+1 ) - IFF-1
	ROLL = ROLL + IRAN( IFF*2+1 ) - IFF-1
3200	CALL PUTVAL( 2, SHIPNM, 1, X )
	CALL PUTVAL( 2, SHIPNM, 2, Y )
	CALL PUTVAL( 2, SHIPNM, 3, Z )
	CALL PUTVAL( 1, X, Y, Z, 1 )
3300	DVEC = 90
	IF( PITCH .LT. 0 )  DVEC = 270
C
C	NEWANG WORK NOT COMPLETED
C
	IF(YAW.NE.0)DVEC=ATAN(-FLOAT(PITCH)/FLOAT(YAW))*180./3.14159
	IF( YAW .GT. 0 )  DVEC = DVEC + 180
	DSPEED = SQRT( (YAW+0.0)^2 + (PITCH+0.)^2 )
C	IF( NEWANG ) DVEC = 360.0 - DVEC
	CALL INRANG( DVEC )
	IF( DSPEED .EQ. 0 )  DVEC = 10000
	E = E + SINDEG( DVEC+ROLLAM ) * DSPEED
	IF( NEWANG ) D = D + COSDEG( DVEC+ROLLAM ) * DSPEED
	IF( .NOT. NEWANG ) D = D - COSDEG( DVEC+ROLLAM ) * DSPEED
	IF( ABS(E) .GT. 90 )  ROLLAM = ROLLAM + 180
	IF( ABS(E) .GT. 90 )  D = D + 180
	IF( E .GT. 90 )  E = 180-E
	IF( E .LT. -90 )  E = -180-E
C	END NEWANG WORK
	ROLLAM = ROLLAM + ROLL
	CALL INRANG( D )
	CALL INRANG( ROLLAM )
	CALL UPDSCR( X, Y, Z, D, E, ROLLAM, ICHAR, IPLAYR )
	IF( OSPEED .EQ. SPEED .AND. ICHAR .NE. 'N' ) GOTO 3400
	CALL COLCUR( 6, 4 )
	CALL NUMBER( SPEED, 3 )
	OSPEED = SPEED
3400	IF( ODVEC .EQ. IFIX(DVEC) .AND. ICHAR .NE. 'N' ) GOTO 3500
	CALL COLCUR( 16, 4 )
	CALL NUMBER( IFIX(DVEC), 3 )
	ODVEC = DVEC
3500	IF( ODSPEE .EQ. DSPEED .AND. ICHAR .NE. 'N' ) GOTO 3600
	CALL COLCUR( 26, 4 )
	CALL NUMBER( DSPEED, 3 )
	ODSPEE = DSPEED
3600	IF( OROLL .EQ. ROLL .AND. ICHAR .NE. 'N' ) GOTO 3700
	CALL COLCUR( 36, 4 )
	CALL NUMBER( ROLL, 3 )
	OROLL = ROLL
3700	CALL GETVAL( 3, 3, IUSER )
	IF( IUSER .EQ. OUSER .AND. ICHAR .NE. 'N' ) GOTO 4000
	CALL COLCUR( 58, 23 )
	DO 3800 I = 1, 13
	    CALL GETVAL( 4, I+0, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 3800
	    LASTON = I
	    CALL CHROUT( LASTON+64 )
3800	CONTINUE
	CALL STRING('   ^E')
	CALL COLCUR( 59, 22 )
	DO 3900 I = 14, 26
	    CALL GETVAL( 4, I+0, 1, IVAL )
	    IF( IVAL .EQ. 0 ) GOTO 3900
	    LASTON = I
	    CALL CHROUT( LASTON+64 )
3900	CONTINUE
	CALL STRING('   ^E')
	OUSER = IUSER
4000	CALL GETVAL( 4, IPLAYR, 2, IVAL )
	IF( IVAL .NE. 0 )  CALL EXPLOD( X, Y, Z, 5 )
	IF( IVAL .NE. 0 )  CALL CEASE( SHIPNM,ICLRED,
     &'******** Ship has been hit *** Ship destroyed ********^G^E')
	IF(IPLAYR.GT.13.OR.Z.GT.10.OR.IRAN(10).LE.1)GOTO 4400
	IF( Z .LT. 5 ) GOTO 4350
	X0 = IFIX((X-5)/10.)*10 + 5
	X1 = IFIX((X+5)/10.)*10 + 5
	IF( MOD( X, 10 ) .EQ. 5 ) X1 = 101
	Y0 = IFIX((X-5)/10.)*10 + 5
	Y1 = IFIX((X+5)/10.)*10 + 5
	IF( MOD( Y, 10 ) .EQ. 5 ) Y1 = 101
	IVAL1 = 0
	IF( X0 .LT. 1 ) GOTO 4200
	IF( Y0 .LT. 1 ) GOTO 4100
	CALL GETVAL( 1, X0, Y0, 6, IVAL )
	IVAL1 = IVAL1 + IVAL
4100	IF( Y1 .GT. 100 ) GOTO 4200
	CALL GETVAL( 1, X0, Y1, 6, IVAL )
	IVAL1 = IVAL1 + IVAL
4200	IF( X1 .GT. 100 ) GOTO 4325
	IF( Y0 .LT. 1 ) GOTO 4300
	CALL GETVAL( 1, X1, Y0, 6, IVAL )
	IVAL1 = IVAL1 + IVAL
4300	IF( Y1 .GT. 100 ) GOTO 4325
	CALL GETVAL( 1, X1, Y1, 6, IVAL )
	IVAL1 = IVAL1 + IVAL
4325	IF( IVAL1 .EQ. 0 ) GOTO 4350
	DO 4330 I = 1, IVAL1
	    IF( IRAN( Z-5 + IABS(SPEED) ) .LE. 1 ) GOTO 4330
	    CALL EXPLOD( X, Y, Z, 5 )
	    CALL CEASE
     &( SHIPNM, ICLRED, '*** Ship hit by heavy laser beam ***^G^E')
4330	CALL EXPLOD( X+IRAN(5)-3, Y+IRAN(5)-3, Z+IRAN(3)-1, 1 )
	GOTO 4400

4350	IF(X.LT.49.OR.X.GT.51.OR.Y.GT.75.OR.Z.GT.5.OR.IRAN(5).LE.1)
     &GOTO 4400
	Y0 = (Y-1)/5*5+1
	IVAL1 = 0
	CALL GETVAL( 1, 48, Y0, 2, IVAL )
	IVAL1 = IVAL1 + IVAL
	CALL GETVAL( 1, 52, Y0, 2, IVAL )
	IVAL1 = IVAL1 + IVAL
	IF( IVAL1 .EQ. 0 ) GOTO 4400
	DO 4355 I = 1, IVAL1
	    IF( IRAN(IABS(SPEED)*10) .GT. 1 ) GOTO 4355
	    CALL EXPLOD( X, Y, Z, 5 )
	    CALL CEASE
     &( SHIPNM,ICLRED,'*** Ship hit by light laser beam ***^G^E')
4355	CALL EXPLOD( 48+IRAN(3), Y+IRAN(3)-2, Z+IRAN(3)-2, 1 )
4400	IF( LASTON .NE. IPLAYR ) GOTO 400
	CALL ADDVAL( 3, 4, -1 )
	CALL GETVAL( 3, 5, IVAL )
	IF( IVAL .GT. 0 ) CALL ADDVAL( 3, 5, -1 )
	CALL GETVAL( 3, 1, OBJNUM )
	DO 4500 I = 1, OBJNUM
	    IOBJ = I
	    CALL GETVAL( 2, IOBJ, 4, IVAL )
	    IF( IVAL .NE. 6 ) GOTO 4500
	    CALL ADDVAL( 2, IOBJ, 5, -1 )
	    CALL GETVAL( -2, IVAL )
	    IF( IVAL .LE. 0 )  CALL DELOBJ( IOBJ )
4500	CONTINUE
	GOTO 400
C
4600	CALL CEASE( SHIPNM, ICLLBL, 'You have flown out of range.^E')
	END

	SUBROUTINE COLCUR( IX, IY )
	CALL DEFCOL
	CALL CURSOR( IX, IY )
	RETURN
	END

    	SUBROUTINE COLSTR( ICOL, MSGARA )
	INTEGER MSGARA( 16 )
	CALL PCOLOR( ICOL )
	CALL STRING( MSGARA )
	RETURN
	END
