.LC
.LM 5
.RM 70
.FLAG CAPITALIZE
.CENTER; <USRPAK.HLP
.P; <USRPAK IS A SUBROUTINE PACKAGE DESIGNED TO GIVE <FORTRAN
USERS THE ADVANTAGES OF DEGENERATING TO ASSEMBLY OPERATIONS ONLY
WHEN NECESSARY.  ^IT ALLOWS THE USER TO RETRIEVE INFORMATION
ABOUT OTHER JOBS, PERFORM <I/O FUNCTIONS, CONTROL HIS OWN JOB
PARAMETERS, AND MANIPULATE HIS CORE IMAGE.
.P; <USRPAK HAS ONE STANDARD LOGICAL FUNCTION <ERROR WHICH
WILL RETURN .TRUE. IF THE PREVIOUS SUBROUTINE CALL FAILED.
.PAGE
.CENTER; ******************** MODULE <WHO ********************
.SKIP 2
.CENTER; <LOGICAL <FUNCTION <LOGDIN( <JOB )
.P; ^RETURNS .TRUE. IF THE SPECIFIED INTEGER <JOB NUMBER IS LOGGED
IN.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <JOB( 0 )
.P; ^RETURNS THE INTEGER NUMBER OF THE USER'S JOB.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ITTY( <JOB )
.P; ^RETURNS THE INTEGER TTY NUMBER (OCTAL) OF THE SPECIFIED
INTEGER <JOB IF IT IS ATTACHED, OR ELSE -1 IF IT IS DETACHED.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ICJOB( <JOB )
.P; ^RETURN THE CONTROLLING JOB (BATCH/OPSER) FOR <JOB OR -1
IF IT CONTROLS ITSELF.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <JSTAT( <JOB )
.P; ^RETURNS THE TWO LETTER SIXBIT RUN QUEUE NAME FOR <JOB.
^SOME OF THESE STATES ARE "<RN", "<SL", "<EW" ETC.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <NODE( <NODNUM OR <NODNAM )
.P; ^RETURN THE SIXBIT NODE NAME FROM THE OCTAL INTEGER <NODNUM
OR THE OCTAL INTEGER NODE NUMBER FOR THE SIXBIT <NODNAM.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IDLINE( <DEVNAM )
.P; ^RETURN THE TERMINAL NUMBER FROM THE
.SKIP 2
.CENTER; <SUBROUTINE <PPN( <P, <PN )
.P; ^THIS ROUTINE WILL RETURN THE OCTAL INTEGER <P AND <PN OF
THIS USER'S PPN.
.SKIP 2
.CENTER; <SUBROUTINE <NODLIN( <ITTY, <NODNUM, <TTYLIN )
.P; ^GIVEN THE INTEGER OCTAL TTY NUMBER <ITTY, <NODLIN WILL
RETURN THE INTEGER OCTAL NODE NUMBER <NODNUM ASSOCIATED
WITH THAT TTY AND THE TTY'S INTEGER OCTAL LINE NUMBER IN
<TTYLIN.
.SKIP 2
.CENTER; <SUBROUTINE <CORSIZ( <JOB, <LOWCOR, <HIGHCO, <SWAPPD )
.P; ^GIVEN THE INTEGER <JOB NUMBER, THIS ROUTINE WILL RETURN
THE AMOUNT OF CORE IT HAS IN THE LOW SEGMENT IN INTEGER <LOWCOR,
THE AMOUNT OF CORE IT HAS IN THE HI SEGMENT IN INTEGER <HICHCO,
AND THE LOGICAL <SWAPPD AS .TRUE. IF THE JOB IS SWAPPED OUT.
.SKIP 2
.CENTER; ******************** MODULE <DATIME ********************
.SKIP 2
.CENTER; <SUBROUTINE <DATIME( <DAY, <MONTH, <YEAR,
.CENTER;  <HOUR, <MINUTE, <SECOND, <MILSEC )
.P; ^RETURN THE NUMERIC TIME IN INTEGERS.
.SKIP 2
.CENTER; ******************** MODULE <OUTDAT *********************
.SKIP 2
.CENTER; <SUBROUTINE <OUTDAT( <IDATWD, <ISTRNG, <ILEN, <MAXLN,
.CENTER; <TYPE[, <SEPCHR ])
^THIS ROUTINE TAKES THE DATE ISTORED IN <TYPE FORMAT
AND PLACES THE STRING EQUIVALENT IN <ISTRNG WITH A LENGTH OF
<ILEN (USER SPECIFIES MAXIMUM IN <MAXLN).  <SEPCHR SPECIFIES
THE CHARACTER TO SEPARATE THE DATE AND TIME.  <TYPE MAY BE
ONE OF THE FOLLOWING:
.LM 11
.NOFILL
0 ^FANCY UNIVERSAL FORMAT (DATE,,TIME)
1 ^SYSTEM DATE,,TIME IN SECONDS
2 ^SYSTEM DATE
3 ^SYSTEM TIME
4 ^UNIVERSAL DATE,,TIME
5 ^UNIVERSAL DATE
6 ^UNIVERSAL TIME
7 ^TIME IN JIFFIES TO SECONDS
8 ^TIME IN TICKS TO SECONDS
9 ^TIME IN MILLISECONDS TO SECONDS
.LM 10
10 ^TIME IN MILLISECONDS
11 ^TIME IN MINUTES TO SECONDS
.FILL
.LM 5
.SKIP 2
.CENTER; ******************** MODULE <INDAT *********************
.SKIP 2
.CENTER; <SUBROUTINE <INDAT( <STRING, <ILEN, <IDATE )
.SKIP 2
.P; ^THIS ROUTINE INTERPRETS THE DATE STORED IN <A1 FORMAT IN THE
ARRAY <STRING (<ILEN LONG), AND RETURNS IT IN SYSTEM FORMAT.
.SKIP 2
.CENTER; <SUBROUTINE <SETHOL( <NAMEAR, <VALAR, <LEN )
.P; <THIS ROUTINE ALLOWS THE USER TO SET HOLLIDAYS THAT <INDAT
WILL RECOGNIZE.  <LEN IS THE NUMBER OF HOLLIDAYS THE USER WISHES
TO DEFINE.  <NAMEAR IS A SIXBIT ARRAY OF HOLLIDAY NAMES (<LEN
LONG).  <VALAR IS AN ARRAY OF HOLLIDAYS SPECIFIERS OF THE FOLLOWING
FORM:
.LM 8
.NOFILL
0,,(<MON-1)*31+DAY-1		MONTH, DAY OF MONTH
1,,(<WEEK-1)*7+DAY		WEEK OF YEAR, DAY OF WEEK
2,,((<MON-1)*6+WEEK-1)*7+DAY-1	MONTH,WEEK DAY FALLS ON
3,,((<MON-1)*6+WEEK-1)*7+DAY-1	SAME EXCEPT SKIP TO NEXT
				WEEK IF IT FALLS ON THE FIRST
.FILL
.SKIP 2
.CENTER; <INTEGER <FUNCTION <DATNOW
.P; ^THIS FUNCTION RETURNS THE CURRENT DATE AND TIME IN
SYSTEM FORMAT.
.SKIP 2
.CENTER; <SUBROUTINE <FIXDAT( <IDATE )
.P; ^IF <IDATE (<SYSTEM FORMAT) CONTAINS ONLY A TIME, THE CURRENT
THE DATE WILL BE ADDED TO IT AND IF THE TIME IS PREVIOUS TO NOW,
THEN INCREMENT THE DATE.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <UNVSYS( <IUNIV )
.P; ^THIS FUNCTION RETURNS THE TIME STORED IN <UNIVERSAL DATE/TIME
FORMAT IN <SYSTEM FORMAT.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <SYSUNV( <ISYSTM )
.P; ^THIS FUNCTION RETURNS THE TIME STORED IN <SYSTEM FORMAT
IN <UNIVERSAL DATE/TIME FORMAT.
.SKIP 2
.CENTER; ******************** MODULE <USRSET ********************
.SKIP 2
.CENTER; <SUBROUTINE <USRSET( <CODE, <VALUE )
.P; <USRSET RETURNS OR SETS THE USER'S TERMINAL CHARACTERISTICS
BASED ON <CODE.  (REFER TO <MONITOR <CALLS MANUAL)  ^WHEN
RETURNING THE VALUE, THE INTEGER <CODE WILL BE LESS THAN 2000 AND
THE VALUE WILL BE RETURNED IN <VALUE.  ^WHEN SETTING, <CODE
WILL BE GREATER THAN 2000 AND THE VALUE WILL BE SET TO <VALUE.
VALUE WILL BE SET TO <VALUE.  
.CENTER; ******************** MODULE <OUTPUT ********************
.SKIP 2
.CENTER; <SUBROUTINE <TTYTYP( <ITYPE )
.P; <TTYTYP WILL SET THE TERMINAL TYPE FOR THE ROUTINES <CURSOR
AND <CLRSCR.  THE TYPES ARE:
.LM 20
.BREAK; 0 - <ADDS580
.BREAK; 1 - <ADM3
.BREAK; 2 - <VT52
.BREAK; 3 - <ISC
.BREAK; 4 - <ISC (LARGE MODE, <A7 ON)
.BREAK; 5 - <PE550
.BREAK; 6 - <ADDS980
.BREAK; 7 - <ACTV
.BREAK; 8 - <VT100
.BREAK; 9 - <NORTHSTAR <ADVANTAGE
.LM 5
.SKIP 2
.CENTER; <SUBROUTINE <SELECT( <CHAN )
.P; ^THIS ROUTINE ALLOWS THE USER TO DIRECT OUTPUT IN THIS MODULE
TO ANY DEVICE OPENNED ON INTEGER CHANNEL <CHAN.  ^IF <CHAN IS ZERO
(OR HASN'T BEEN CALLED), OUTPUT DEFAULTS TO THIS TERMINAL VIA
THE <TRMOP. <MONITOR <CALL.
.SKIP 2
.CENTER; ***** <STATIC <SCREEN <ROUTINES *****
.SKIP 2
.CENTER; <SUBROUTINE <DEFSCR( <SCRNUM, <ARRAY )
.P; ^THIS ROUTINE DEFINES A SCREEN ARRAY REFERRENCED BY <SCRNUM
IN ARRAY <ARRAY (A 384 WORD INTEGER ARRAY).
.SKIP 2
.CENTER; <SUBROUTINE <SETDIS( <SCRNUM )
.P; ^ALL OUTPUT FROM THIS MODULE UNTIL THIS ROUTINE IS CALLED
AGAIN, WILL BE DIVERTED TO THE SCREEN <SCRNUM.  ^IN MOST CASES,
THE USER WOULD SPORATICALLY OUTPUT TO THE SCREEN, AND THEN
DISPLAY THE SCREEN CONTENTS ALL AT ONCE WITH THE <UPDATE OR
<NEWSCR ROUTINES.  ^THE ADVANTAGE OF THIS METHOD IS THAT
THE COMPUTER CAN DO THE MINIMUM AMOUNT OF <I/O TO UPDATE THE
SCREEN IN A REFRESH ENVIRONMENT.
.SKIP 2
.CENTER; <SUBROUTINE <CURPOS( <CURSRX, <CURSRY )
.P; ^THIS ROUTINE RETURNS THE CURRENT POSITION OF THE CURSOR
IN INTEGER <CURSRX - <CURSRY.  (*NOTE* THE BOTTOM LEFT CORNER
OF THE SCREEN IS 1-1 AND THE TOP RIGHT OF MOST SCREENS IS 80-24)
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ICHRAT( <CURSRX, <CURSRY )
.P; ^THIS FUNCTION RETURNS THE CHARACTER AT <CURSRX, <CURSRY
ON THE SCREEN DEFINED BY <SETDIS.
.SKIP 2
.CENTER; <SUBROUTINE <NEWSCR( <SCRNUM )
.P; ^THIS ROUTINE CLEARS THE SCREEN OF THE TERMINAL AND
THEN PRINTS THE ENTIRE CONTENTS OF THE SCREEN DEFINED AS <SCRNUM.
.SKIP 2
.CENTER; <SUBROUTINE <UPDATE( <SCRNUM )
.P; ^THIS ROUTINE UPDATES ONLY THE THINGS THAT HAVE CHANGED FOR
THE SCREEN <SCRNUM SINCE LAST TIME <UPDATE WAS CALLED.
.SKIP 2
.CENTER; <SUBROUTINE <GRAFON
.P; ^THIS ROUTINE SETS CERTAIN TERMINAL CHARACTERISTICS TO ALLOW
EASY GRAPHICS INTERACTION.  ^IT TURNS OFF ECHO, CONTROL-^S/^Q,
TURNS ON TAPE MODE (NO LINE FEED AFTER CARRIAGE RETURN DURING
INPUT) ETC.   *** ^THE TERMINAL IS VIRTUALLY UNUSABLE IN THIS
STATE WITHOUT SPECIAL <I/O ROUTINES TO HANDLE CHARACTER INPUT. ***
^TO EXIT THIS MODE, USE THE ROUTINE <GRAFOF.
.SKIP 2
.CENTER; <SUBROUTINE <GRAFOF
.P; ^THIS ROUTINE RESETS SOME OF THE TERMINAL CHARACTERISTICS
SET BY <GRAFON.  ^IT IS USEFUL IN RECOVERING FROM GRAPHICS MODE.
.SKIP 2
.CENTER; ***** END OF <STATIC <SCREEN <ROUTINES *****
.SKIP 2
.CENTER; <SUBROUTINE <CURSOR( <CURSRX, <CURSRY )
.P; ^PLACE THE CURSOR AT <CURSRX, <CURSRY (1-1 IS LOWER LEFT HAND
CORNER) OF SCREEN.
.SKIP 2
.CENTER; <SUBROUTINE <CLRSCR
.P; ^CLEAR THE SCREEN.
.SKIP 2
.CENTER; <SUBROUTINE <CHROUT( <ICHAR )
.P; ^OUTPUT EITHER AN <A1 OR <R1 FORMATTED CHARACTER INTEGER <ICHAR.
.SKIP 2
.CENTER; <SUBROUTINE <REPEAT( <ICHAR, <NUMTMS )
.P; ^THIS ROUTINE WILL CALL <CHROUT WITH <ICHAR <NUMTMS TIMES.
.SKIP 2
.CENTER; <SUBROUTINE <NUMBER( <NUM )
.CENTER; OR
.CENTER; <SUBROUTINE <NUMBER( <NUM, <LENGTH )
.CENTER; OR
.CENTER; <SUBROUTINE <NUMBER( <NUM, <LENGTH, <BASE )
.CENTER; OR
.CENTER; <SUBROUTINE <NUMBER( <NUM, <LENGTH, <BASE, <RITDEC )
.P; ^THIS ROUTINE OUTPUTS A NUMBER <NUM WHICH MAY BE EITHER
AN INTEGER OR REAL.  ^ALL OTHER PARAMETERS ARE OPTIONAL.
.BREAK; <LENGTH - DEFAULT: 0
.LM 10
^IF <LENGTH IS GREATER THAN ZERO, A <LENGTH NUMBER OF DIGITS
WILL BE PRINTED (PUTTING SPACES TO THE LEFT AS NEEDED).  ^IF
<LENGTH IS ZERO, THE NUMBER IS PRINTED USING AS MANY DIGITS
AS NECESSARY.  ^IF <LENGTH IS LESS THAN ZERO, A -<LENGTH NUMBER
WILL BE PRINTED USING ZEROES TO THE LEFT AS NEEDED).
.LM 5
.BREAK; <BASE - DEFAULT: 10
.LM 10
^LEGAL BASES ARE -36 THROUGH -2 AND 2 THROUGH 36.
.LM 5
.BREAK; <FIELD - DEFAULT: 2 (FOR REALS ONLY)
.LM 10
^THIS PARAMETER IS ONLY VALID FOR REAL <NUM'\S.  IT IS THE
NUMBER OF DIGITS TO PRINT TO THE RIGHT OF THE DECIMAL POINT
IF IT IS NOT NEGATIVE.  ELSE, DO NOT PRINT A DECIMAL POINT.
.LM 5
.SKIP 2
.CENTER; <SUBROUTINE <LNUMBR( <NUM )
.CENTER; OR
.CENTER; <SUBROUTINE <LNUMBR( <NUM, <LENGTH )
.CENTER; OR
.CENTER; <SUBROUTINE <LNUMBR( <NUM, <LENGTH, <BASE )
.CENTER; OR
.CENTER; <SUBROUTINE <LNUMBR( <NUM, <LENGTH, <BASE, <RITDEC )
.P; ^THIS ROUTINE IS IDENTICAL TO <NUMBER EXCEPT THAT IT ADDS
TRAILING SPACES INSTEAD OF LEADING SPACES.
.SKIP 2
.CENTER; <SUBROUTINE <OUTNUM( <NUM1, <NUM2,...<NUM\N )
.P; ^THIS ROUTINE WILL OUTPUT <NUM1...<NUM\N IN THEIR DEFAULT
FORMATS SEPARATED BY COMMAS.
.SKIP 2
.CENTER; <SUBROUTINE <STRING( <ARRAY )
.CENTER; OR
.CENTER; <SUBROUTINE <STRING( <ARRAY, <FRMNUM, <NUMCHR )
.P; ^THIS ROUTINE WILL OUTPUT THE ARRAY <ARRAY.  ^IF <FRMNUM
IS NOT SPECIFIED, THE ARRAY IS ASSUMED TO BE <A5 FORMATTED AND
IT WILL CONTINUE UNTIL IT ENCOUNTERS A CONTROL-^E (END OF STRING)
OR A CONTROL-^B (END OF BUFFER).
^OTHERWISE, <FRMNUM REPRESENTS THE FORMAT NUMBER 1=<A1, 2=<A2 ETC.
(0=<R1, 6=SIXBIT)
AND <NUMCHR IS THE NUMBER OF CHARACTERS TO OUTPUT.
^WHEN <FRMNUM AND <NUMCHR ARE NOT SPECIFIED, CHARACTERS PRECEDED
WITH A CIRCUMFLEX (_^) ARE CONSIDERED CONTROL CHARACTERS.
^THUS THE FOLLOWING IS A COMMON OUTPUT STATEMENT.
.LM 10
.BREAK; <CALL <STRING('_^^G^THIS IS A TEST._^^M_^^J_^^B')
.LM 5
.BREAK; ^THIS CALL WILL OUTPUT A CONTROL-^G, "^THIS IS A TEST."
A CARRIAGE RETURN, A LINE FEED AND THEN IT WILL DUMP THE BUFFER.
.SKIP 2
.CENTER; <SUBROUTINE <CURBUF
.P; ^THIS ROUTINE WILL DUMP THE BUFFER (IF CHAN NOT ZERO).
.SKIP 2
.CENTER; <SUBROUTINE <CRLF
.P; ^THIS ROUTINE OUTPUTS A CARRIAGE RETURN.
.SKIP 2
.CENTER; ******************** MODULE <INPUT ********************
.SKIP 2
.CENTER; <LOGICAL <FUNCTION <LSKIP( 0 )
.P; ^RETURN .TRUE. IF THERE IS A LINE IN THE TERMINAL INPUT BUFFER.
.SKIP 2
.CENTER; <LOGICAL <FUNCTION <CSKIP( 0 )
.P; ^RETURN .TRUE. IF THERE IS A CHARACTER IN THE TERMINAL INPUT
BUFFER.
.SKIP 2
.CENTER; <SUBROUTINE <CHRBUF( <INCHAR )
.P; ^RETURN THE NEXT CHARACTER IN THE INPUT BUFFER IN <INCHAR IF ONE
EXISTS.  ^ELSE, RETURN -1.
.SKIP 2
.CENTER; <SUBROUTINE <CHRWAT( <INCHAR )
.P; ^RETURN THE NEXT CHARACTER IN THE INPUT BUFFER IN <INCHAR IF ONE
EXISTS.  ^ELSE, WAIT UNTIL ONE DOES.
.SKIP 2
.CENTER; <SUBROUTINE <GETNUM( <ARRAY, <LENGTH,
.CENTER; <NUM1, <BASE1, <NUM2, <BASE2,...NUM\N, <BASE\N )
.P; ^RETURN EITHER REAL OR INTEGER NUMBERS <NUM1...NUM\N FROM
THE ARRAY <ARRAY (INTEGER <LENGTH LONG) IN RADIX <BASE1...BASE\N.
<ARRAY MUST BE AN <A1 FORMMATED ARRAY  (SUCH AS AN ARRAY RETURNED
FORM <GETSTR).
.SKIP 2
.CENTER; <SUBROUTINE <GETSTR( <ARRAY, <MAXLEN, <LENGTH )
.CENTER; OR
.CENTER; <SUBROUTINE <GETSTR( <ARRAY, <MAXLEN, <LENGTH, <CHAN, <EOF )
.P; ^RETURN THE <A1 FORMATTED STRING <ARRAY FROM THE TERMINAL
IF 3 ARGUMENTS, OR FROM CHAN IF 5 ARGUMENTS.  
<MAXLEN IS THE LENGTH OF THE ARRAY YOU PASSED TO <GETSTR.
<LENGTH IS THE NUMBER OF CHARACTERS IN THE LINE RETURNED.
<EOF WILL RETURN .TRUE. IF FOUND END OF FILE WHILE READING FROM <CHAN.
.SKIP 2
.CENTER; ******************** MODULE <STROPR ********************
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ISERCH( <ARRAY, <WORD, <LENGTH )
.P; ^SEARCH THE ARRAY <ARRAY (<LENGTH LONG) FOR THE FIRST OCCURENCE OF
<WORD.  ^IF FOUND, RETURN ITS INDEX, ELSE RETURN ZERO.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ISRSIX( <ARRAY, <WORD, <LENGTH )
.P; ^SEARCH THE SIXBIT ARRAY <ARRAY (<LENGTH LONG) FOR AN ELEMENT WHICH
SIXBIT <WORD IS AN ABBREVIATION FOR.  ^IF ONE IS FOUND, RETURN
ITS INDEX, ^IF MORE THAN ONE IS FOUND, RETURN THE NEGATIVE INDEX
OF THE FIRST ONE, ELSE RETURN ZERO.  ^THIS FUNCTION IS PARTICULARLY
USEFUL IN SCANNING A LIST OF COMMANDS (STORED IN SIXBIT).
.SKIP 2
.CENTER; <LOGICAL <FUNCTION <COMPAR( <ARRAY1, <ARRAY2, <LENGTH )
.P; ^THIS FUNCTION RETURNS .TRUE. IF <ARRAY1 (<LENGTH LONG) AND
<ARRAY2 (<LENGTH LONG) ARE IDENTICAL.
.SKIP 2
.CENTER; <SUBROUTINE <ALLCAP( <ARRAY, <LENGTH )
.P; ^REPLACE ALL LOWER CASE LETTERS WITH THEIR UPPERCASE EQUIVALENTS
IN THIS <A1 OR <R1 FORMATTED ARRAY <ARRAY (<LENGTH LONG).
.SKIP 2
.CENTER; <SUBROUTINE <PARSE( <ARRAY, <LENGTH,
.CENTER; <SIXARA, <NUMWRD, <MAXWRD )
.P; ^THIS ROUTINE EXTRACTS "WORDS" FROM THE <A1 FORMATTED ARRAY <ARRAY
(<LENGTH LONG) AND RETURNS THEM IN SIXBIT IN THE ARRAY <SIXARA
(HAVING A MAXIMUM OF <MAXWRD ELEMENTS AND RETURNING <NUMWRD, THE NUMBER
OF WORD FOUND).  ^A WORD IS ANY COLLECTION OF ALPHANUMERICS OR
A PRINTABLE CHARACTER.  IF A STRING CONTAINED "THIS IS A TEST, ADD
2.4 + 8.5 AND GET 10.9", PARSE WOULD RETURN "THIS##", "IS####",
"A#####", "TEST##", ",######", "ADD###", "2#####", ".#####", "4#####",
"+#####", "3#####", ".#####", "5#####", "AND###", "GET###", "10####",
".#####", "9#####".
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IRAD50( <WORD )
.P; ^RETURN THE RADIX 50 EQUIVALENT OF THE SIXBIT INTEGER <WORD.
.SKIP 2
.CENTER; ******************** MODULE <CONVRT ********************
.SKIP 2
.CENTER; <SUBROUTINE <CONVRT( <ARRAY1, <LENGTH, <INRM,
.CENTER; <ARRAY2, <OUTFRM )
.P; ^THIS ROUTINE CONVERTS THE ARRAY <ARRAY1 (<LENGTH CHARACTERS)
FORMATTED ACCORDING TO <INFRM (0=<R1, 1=<A1, 2=<A2,...5=A5, 6=SIXBIT)
TO <ARRAY2 FORMATTED ACCORDING TO <OUTFRM.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ICON( <ICHAR )
.P; ^RETURN THE EQUIVALENT <R1 FORMAT FROM <A1 FORMATTED <ICHAR OR
RETURN THE EQUIVALENT <A1 FORMAT FROM <R1 FORMATTED <ICHAR.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ISXBIT( <WORD )
.P; ^RETURN THE SIXBIT EQUIVALENT OF THE <A5 FORMATTED <WORD.
.SKIP 2
.CENTER; ******************** MODULE <JOBCON ********************
.SKIP 2
.CENTER; <SUBROUTINE <RPROG( <FILESP, <INC )
.P; ^RUN THE PROGRAM SPECIFIED IN <FILESP (SEE <SCAN IN MODULE <IO)
WITH A RUNOFFSET OF <INC.
.SKIP 2
.CENTER; <SUBROUTINE <TSTOP
.P; ^EXIT TO THE MONITOR BUT ALLOW A <CONTINUE.
.SKIP 2
.CENTER; <SUBROUTINE <PSTOP
.P; ^EXIT TO THE MONITOR AND DESTROY CORE IMAGE.
.SKIP 2
.CENTER; <SUBROUTINE <DETACH
.P; ^DETACH THIS JOB.
.SKIP 2
.CENTER; <SUBROUTINE <QGONE
.P; ^LOG THIS JOB OUT.
.SKIP 2
.CENTER; <SUBROUTINE <NAP( <TIME )
.CENTER; OR
.CENTER; <SUBROUTINE <NAP( <TIME, <WAKFLG )
.P; ^THIS ROUTINE WILL SLEEP FOR <TIME MILLISECONDS OR UNTIL
THE CONDITIONS OF <WAKFLG ARE MET (REFER TO <MONITOR <CALLS MANUAL
UNDER <HIBER <MONITOR <CALL).
.SKIP 2
.CENTER; <SUBROUTINE <ASSIGN( <DEVNAM, <LOGNAM )
.P; ^ASSIGN THE PHYSICAL DEVICE SPECIFIED IN THE SIXBIT INTEGER <DEVNAM
THE LOGICAL SIXBIT INTEGER NAME <LOGNAM.
.SKIP 2
.CENTER; ******************** MODULE <IPCF ********************
.SKIP 2
.CENTER; <SUBROUTINE <SEND( <TOJOB, <LENGTH, <ARRAY )
.P; ^SEND AN <IPCF MESSAGE TO <TOJOB JOB CONSISTING OF THE ARRAY <ARRAY
(<LENGTH LONG, MAX. IS 511 WORDS).
.SKIP 2
.CENTER; <SUBROUTINE <RCEIVE( <FRMJOB, <LENGTH, <ARRAY )
.P; ^RECEIVE THE NEXT <IPCF MESSAGE DESTINED FOR THIS JOB.  ^RETURN
<FRMJOB AS ZERO IF NONE PRESENT, ELSE THE NUMBER OF THE JOB WHO
SENT IT.  ^RETURN THE ARRAY <ARRAY (AND ITS LENGTH <LENGTH).
.SKIP 2
.CENTER; ******************** MODULE <TEMP ********************
.SKIP 2
.CENTER; <SUBROUTINE <TEMP( <TMPNAM, <LENGTH, <ARRAY )
.P; ^STORE THE ARRAY <ARRAY (<LENGTH LONG) IN TMPCORE UNDER THE
INTEGER SIXBIT NAME <TMPNAM.
.SKIP 2
.CENTER; <SUBROUTINE <GETEMP( <TMPNAM, <LENGTH, <ARRAY )
.P; ^READ THE ARRAY <ARRAY (<LENGTH LONG) FROM THE <TMPCOR FILE
INTEGER SIXBIT NAME <TMPNAM.
.SKIP 2
.CENTER; ******************** MODULE <MATH ********************
.SKIP 2
.CENTER; <INTEGER <FUNCTION <INTOF( <REALNM )
.P; ^RETURN THE VALUE WITHOUT CONVERTING IT (THUS FOOLING FORTRAN
AND ALL ITS INTEGER/REAL CONVERSIONS).
.SKIP 2
.CENTER; <REAL <FUNCTION <REALOF( <INTNUM )
.P; ^RETURN THE VALUE WITHOUT CONVERTING IT.
.SKIP 2
.CENTER; <REAL <FUNCTION <DEGRAD( DEG )
.CENTER; OR
.CENTER; <REAL <FUNCTION <RADDEG( RAD )
.P; ^CONVERT DEGREES TO RADIANS OR RADIANS TO DEGREES.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ISGN( <NUM )
.P; ^RETURN -1 IF <NUM_<0, 0 IF <NUM=0 OR 1 IF <NUM>0.
.SKIP 2
.CENTER; <REAL <FUNCTION <ASGN( <RNUM )
.P; ^RETURN -1.0 IF <RNUM_<0, 0.0 IF <RNUM=0 OR 1.0 IF <RNUM>0.
.SKIP 2
.CENTER; <REAL <FUNCTION <TAN( <RAD )
.P; ^RETURN THE TANGENT OF <RAD (IN RADIANS).
.SKIP 2
.CENTER; <REAL <FUNCTION <TAND( <DEGREE )
.P; ^RETURN THE TANGENT OF <DEGREE IN DEGREE MEASUREMENT (VS. RADIAN).
.SKIP 2
.CENTER; <REAL <FUNCTION <ATAND( RNUM )
.P; ^RETURN THE ARCTANGENT IN DEGREES OF <RNUM.
.SKIP 2
.CENTER; <REAL <FUNCTION <ASIND( <DEGREE )
.CENTER; OR
.CENTER; <REAL <FUNCTION <ACOSD( <DEGREE )
.P; ^RETURN THE ARCSINE OR THE ARCCOSINE OF <DEGREE IN DEGREES.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IFACTR( <NUM )
.P; ^RETURN <NUM FACTORIAL.
.SKIP 2
.CENTER; <SUBROUTINE <CMPCOD( <ARRAY1, <LEN1,
.CENTER; <ARRAY2, <MAXLEN, <LEN2,
.CENTER; <SNAME1, <VAR1, <SNAME2, <VAR2...SNAME\N, <VAR\N )
.P; ^THIS ROUTINE GENERATES *EXECUTABLE CODE* FROM THE <A1 FORMATTED
CHARACTER ARRAY <ARRAY1 (<LEN1 LONG) WHICH CONTAINS AN ALGEBRAIC
EXPRESSION (<I.E. <A*B+3).  ^THE CODE IS LEFT IN THE ARRAY <ARRAY2
(MAXIMUM SENT IN <MAXLEN, ACTUAL RETURNED IN <LEN2) WHICH CAN BE
HANDED TO THE ROUTINE <TVAR.  ^IF <TVAR IS CALLED WITH THIS ARRAY,
THE RESULT OF THE ALGEBRAIC EXPRESSION WILL BE PLACED IN <OUTVAR.
<NAME1...NAME\N ARE THE SIXBIT NAMES USED TO REFER TO THE VARIABLES
(<I.E. ^A, ^B, ^XCOOD) AND <VAR1...VAR\N ARE THE CORRESPONDING
VARIABLES IN YOUR PROGRAM.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <TVAR( <ARRAY2 )
.P; ^THIS ROUTINE IS USED PRIMARILY TO EXECUTE CODE GENERATED
BY <CMPCOD.  ^THE FUNCTION
WILL HAVE THE VALUE OF THE EXPRESSION EVALUATED WITH THE CURRENT
<VAR1...VAR\N.  ^THE COMBINATION OF THESE ROUTINES ALLOW THE
PROGRAMMER TO ALLOW THE USER TO INPUT A FORMULA AND THEN RE-EVALUATE
IT EXTREMELY EFFICIENTLY (<I.E. FOR PLOTTING).
.SKIP 2
.CENTER; <SUBROUTINE <DEFUNC( <SIXNAM, <NUMARG )
.P; ^THIS ROUTINE ALLOWS THE USER TO DEFINE FUNCTIONS TO BE ALLOWED
IN <CMPCOD (SIN, LOG, ABS ETC. HAVE ALREADY BEEN DEFINED).  <SIXNAM
IS THE SIXBIT NAME WHICH <CMPCOD WILL RECOGNIZE THE FUNCTION AS,
AND <FNC IS THE FUNCTION ITSELF.  ^CALLING SEQUENCE:
.LM 10
.BREAK; <CALL <DEFUNC( <ISXBIT( '<MYFUNC' ), 1 )
.LM 15
.BREAK; <CALL <FNC
.LM 5
.BREAK; *** <MYFUNC WILL NOT BE CALLED BY <DEFUNC, ONLY BY THE
CALLING OF <TVAR.
.SKIP 2
.CENTER; ******************** MODULE <CNTRLC ********************
.SKIP 2
.CENTER; <SUBROUTINE <ENABLE
.P; ^DISALLOW CONTROL-^C'S.
.SKIP 2
.CENTER; <SUBROUTINE <DISABL
.P; ^ALLOW CONTROL-^C'S AGAIN.
.SKIP 2
.CENTER; <SUBROUTINE <CTRAP
.P; ^CALL THE ROUTINE <MYSUB WHEN A CONTROL-^C IS TYPED.  <MYSUB
WILL NOT BE EXECUTED DIRECTLY AFTER <CTRAP IS (ALTHOUGH BY STANDARD
<FORTRAN, IT LOOKS LIKE IT WOULD).  ^CALLING SEQUENCE:
.LM 10
.BREAK; <CALL <CTRAP
.LM 15
.BREAK; <CALL <MYSUB( <ARG1...ARG\N )
.LM 5
.BREAK; ^THIS CAN BE TURNED OFF BY CALLING <DISABL.
.SKIP 2
.CENTER; ******************** MODULE <IO ********************
.SKIP 2
.CENTER; <SUBROUTINE <OFILE( <CHAN, <SIXDEV, <MODE )
.CENTER; OR
.CENTER; <SUBROUTINE <OFILE( <CHAN, <FILESP, <MODE )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <OFILE( <CHAN, <SIXDEV, <MODE )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <OFILE( <CHAN, <FILESP, <MODE )
.P; ^THIS ROUTINE WHEN CALLED AS A FUNCTION RETURNS THE
ERROR CODE (CHECK TO SEE IF THERE WAS AN ERROR WITH FUNCTION
<ERROR).  ^OTHERWISE, THE ERROR CODE IS DISCARDED.  ^THIS
ROUTINE OPENS A DEVICE SPECIFIED IN SIXBIT IN <SIXDEV OR
IN THE <FILESP ARRAY (SEE <SCAN) ON CHANNEL <CHAN (INTEGER SUCH
THAT 0 _< CHAN _< 16) IN MODE <MODE (0 IS ASCII).
.SKIP 2
.CENTER; <SUBROUTINE <CLOSE( <CHAN )
.P; ^FINISH ANY <IO OPERATIONS ON CHANNEL <CHAN AND CLOSE OFF
ANY FILES ASSOCIATED WITH IT.  ^RELEASE THE CHANNEL.
.SKIP 2
.CENTER; <SUBROUTINE <RFILE( <CHAN, <FILESP )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <RFILE( <CHAN, <FILESP )
.P; ^LOOKUP FILE SPECIFIED IN <FILESP AND ASSOCIATE FILE WITH
<CHAN (<I.E. PREPARE FILE FOR READING).  ^IF FUNCTION, RETURN
ERROR CODE.
.SKIP 2
.CENTER; <SUBROUTINE <READF( <CHAN, 'FILESTRING' )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <READF( <CHAN, <FILESP )
.P; ^OPEN AND ^LOOKUP FILE SPECIFIED IN FILESTRING LITERAL.  ^IF
FUNCTION, RETURN ERROR CODE.  ^IF 'FILESPEC' IS REPLACED BY 0,
READ THE FILE SPEC FROM THE TERMINAL.
.SKIP 2
.CENTER; <SUBROUTINE <WFILE( <CHAN, <FILESP )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <WFILE( <CHAN, <FILESP )
.P; ^ENTER FILE SPECIFIED IN <FILESP AND ASSOCIATE FILE WITH
<CHAN (<I.E. PREPARE FILE FOR WRITING).
.SKIP 2
.CENTER; <SUBROUTINE <WRITEF( <CHAN, 'FILESTRING' )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <WRITEF( <CHAN, 'FILESTRING' )
.P; ^OPEN AND ^ENTER FILE SPECIFIED IN FILESTRING LITERAL.  ^IF
FUNCTION, RETURN ERROR CODE.  ^IF 'FILESPEC IS REPLACED BY 0,
READ THE FILE SPEC FROM THE TERMINAL.
.SKIP 2
.CENTER; <SUBROUTINE <AFILE( <CHAN, <FILESP )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <AFILE( <CHAN, <FILESP )
.P; ^PREPARE FILE FOR APPENDING ON DEVICE OPEN ON <CHAN.
.SKIP 2
.CENTER; <SUBROUTINE <APPENF( <CHAN, 'FILESTRING' )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <APPENF( <CHAN, 'FILESTRING' )
.P; ^OPEN ^LOOKUP, AND ^ENTER FILE SPECIFIED IN FILESTRING LITERAL.
^SKIP TO END OF FILE.  ^IF FUNCTION, RETURN ERROR CODE.
^IF 'FILESTRING' IS REPLACED BY 0, READ FILE SPEC FROM TERMINAL.
.SKIP 2
.CENTER; <SUBROUTINE <RNFILE( <CHAN, <FILESP )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <RNFILE( <CHAN, <FILESP )
.P; ^RENAME FILE ON <CHAN TO FILE SPECIFIED IN <FILESP (MUST HAVE
CALLED <RFILE ON ORIGINAL FILE ON <CHAN).
.SKIP 2
.CENTER; <SUBROUTINE <FILGET( <CHAN, <VALUE, <EOF )
.P; ^READ ONE VALUE (MAY BE WORD OR BYTE DEPENDING ON MODE) FROM
DEVICE OPENNED ON <CHAN.  ^RETURN <EOF AS .TRUE. IF REACHED
END OF FILE.
.SKIP 2
.CENTER; <SUBROUTINE <FILPUT( <CHAN, <VALUE )
.P; ^WRITE VALUE (WORD OR BYTE) TO DEVICE OPENNED ON <CHAN.
.SKIP 2
.CENTER; <SUBROUTINE <XFER( <CHAN1, <CHAN2 )
.P; ^READ THE REMAINDER OF FILE FROM <CHAN1 AND WRITE IT TO <CHAN2.
.SKIP 2
.CENTER; <SUBROUTINE <OUTBUF( <CHAN )
.P; ^DUMP ANY BUFFERS SET UP BY THE MONITOR OUT TO THE DEVICE.
^IF WRITING TO A TERMINAL, <OUTBUF SHOULD BE CALLED (OR <CURBUF)
BEFORE INPUT IS DONE SO THE USER HAS ALL THE INFORMATION AVAILABLE.
.SKIP 2
.CENTER; <SUBROUTINE <NBUFFR( <NUMBUF, <BUFLEN )
.P; ^THIS ROUTINE ALLOWS THE USER TO SET THE DEFAULT NUMBER OF
BUFFERS PER RING AND THE BUFFER LENGTH.  ^IF NO DEFAULT IS APPLIED
200 OCTAL WORDS ARE USED FOR BUFFER LENGTH, AND 2 BUFFERS PER RING.
.SKIP 2
.CENTER; <SUBROUTINE <ISEEK( <ICHAN, <RECNUM )
.CENTER; <SUBROUTINE <OSEEK( <ICHAN, <RECNUM )
.P; ^POSITION INPUT OR OUTPUT POINTER FOR CHANNEL <ICHAN TO
THE <RECNUM\T\H RECORD.  ^A RECORD IS DEFINED AS A SEVEN BIT
BYTE IF THE FILE IS OPENNED IN <ASCII MODE (DEFAULT), OR A 36
BIT BYTE IF THE FILE IS OPENNED IN ^BINARY.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IINPOS( <ICHAN )
.CENTER; <INTEGER <FUNCTION <IOTPOS( <ICHAN )
.P; ^RETURN THE CURRENT INPUT OR OUTPUT POSITION POINTER OF THE
FILE OPENNED ON <ICHAN.
.SKIP 2
.CENTER; <SUBROUTINE <SCAN( <IND1, <IND2, <ARRAY, <FILESP )
.P; ^THIS ROUTINE "SCAN'S" THE ARRAY <ARRAY FROM <IND1 TO <IND2
AND RETURNS ANOTHER 13 WORD ARRAY <FILESP CONSISTING OF THE FOLLOWING
.LM 16
ITEMS:
.LITERAL
INDEX			CONTAINS
1			NUMBER OF ITEMS IN ARRAY (13)
2			NODE NAME IN SIXBIT
3			DEVICE NAME IN SIXBIT
4			FILE NAME IN SIXBIT
5			EXTENSION IN SIXBIT
6			PROTECTION (OCTAL, 0<=PROTECTION<=777)
7			P (OCTAL, FROM PPN)
8			PN (OCTAL, FROM PPN)
9			SFD #1 IN SIXBIT
10			SFD #2 IN SIXBIT
11			SFD #3 IN SIXBIT
12			SFD #4 IN SIXBIT
13			SFD #5 IN SIXBIT
.END LITERAL
.LM 5
.SKIP 2
.CENTER; ******************** MODULE <EXADEP ********************
.SKIP 2
.CENTER; <SUBROUTINE <E( <ADDRES, <WORD )
.P; ^RETURN THE CONTENTS OF <ADDRES IN THE USERS MEMORY SPACE
IN <WORD.
.SKIP 2
.CENTER; <SUBROUTINE <D( <ADDRES, <WORD )
.P; ^SET THE CONTENTS OF <ADDRES TO <WORD.
.SKIP 2
.CENTER; <SUBROUTINE <CCORE( <LOWADR, <HGHADR )
.P; ^SET THE USERS CORE DIMENSIONS TO <LOWADR LOCATIONS IN THE
LOWSEGMENT AND <HGHADR LOCATIONS IN THE HISEGMENT.
.SKIP 2
.CENTER; <SUBROUTINE <HIPROT( <SWITCH )
.P; ^TURN THE HISEGMENT WRITE PROTECT BIT ON IF <SWITCH IS 1, ELSE
TURN IT OFF.
.SKIP 2
.CENTER; <SUBROUTINE <TCON( <ADDRES )
.P; ^TRANSFER EXECUTION TO <ADDRESS.
.SKIP 2
.CENTER; <SUBROUTINE <SHIFTC( <WORD1, <WORD2, <INC )
.P; ^GLUE <WORD1 AND <WORD2 TOGETHER AND SHIFT THEM <INC BITS
TO THE LEFT.
.SKIP 2
.CENTER; <SUBROUTINE <SHIFT( <WORD1, <INC )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <SHIFT( <WORD1, <INC )
.P; ^SHIFT <WORD1 <INC BITS TO THE LEFT.
.SKIP 2
.CENTER; <SUBROUTINE <GETBYT( <BIT1, <BIT\N, <WORD, <BYTE )
.P; <RETURN THE BITS <BIT1...BIT\N FROM <WORD IN <BYTE (RIGHT
JUSTIFIED).
.SKIP 2
.CENTER; <SUBROUTINE <PUTBYT( <BIT1, <BIT\N, <WORD, <BYTE )
.P; <PLACE <BYTE IN <BIT1...BIT\N OF <WORD.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ILEFT( <WORD )
.CENTER; OR
.CENTER; <INTEGER <FUNCTION <IRIGHT( <WORD )
.P; ^RETURN THE LEFT OR RIGHT HALF OF <WORD RIGHT JUSTIFIED.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <ICOMB( <WORD1, <WORD2 )
.P; ^RETURN A WORD SUCH THAT ITS LEFT HALF IS THE RIGHT HALF
OF <WORD1 AND ITS RIGHT HALF IS THE RIGHT HALF OF <WORD2.
.SKIP 2
.CENTER; <SUBROUTINE <EXECUT( <WORD )
.P; ^EXECUTE <WORD AS MACHINE CODE.  ^SET ERROR FOR FUNCTION <ERROR
IF IT DID NOT SKIP.
.SKIP 2
.CENTER; <SUBROUTINE <PUSHVL( <WORD, <PDLERR )
.P; ^PUSH <WORD ONTO A STACK AND RETURN <PDLERR .TRUE. IF STACK
OVERFLOW.
.SKIP 2
.CENTER; <SUBROUTINE <POPVAL( <WORD, <PDLERR )
.P; ^POP <WORD OFF THE STACK AND RETURN <PDLERR .TRUE. IF STACK
UNDERFLOW.
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IGTAB( <INDEX, <TABLE )
.P; ^RETURN A ELEMENT FROM THE GETTAB TABLE <TABLE SPECIFIED
BY THE INDEX <INDEX.
.SKIP 2
.CENTER; <SUBROUTINE <ARCOPY( <ARRAY1, <ARRAY2, <SIZE )
.P; ^COPY <ARRAY1 (<SIZE ELEMENTS) INTO <ARRAY2.
.SKIP 2
.CENTER; <SUBROUTINE <ARFILL( <ARRAY, <SIZE, <ELEMNT )
.P; ^FILL <ARRAY (SIZE <ELEMNT) WITH <ELEMNT (<I.E. ZERO TO ZERO
OUT AN ARRAY).
.SKIP 2
.CENTER; <SUBROUTINE <MCALL1( <CALINM, <AC, <ERRFLG )
.P; ^EXECUTE THE MONITOR CALL NUMERICALLY SPECIFIED BY <CALINM
WITH <AC FOR ITS ACCUMULATOR AND SET <ERRFLG ON ERROR RETURN.
.SKIP 2
.CENTER; <SUBROUTINE <MCALL2( <CALINM, <AC, <ERRFLG, <LENGTH, <ARRAY )
.P; ^EXECUTE THE MONITOR CALL NUMERICALLY SPECIFIED BY <CALINM
WITH THE ACCUMULATOR INITIALLY LOADED WITH <LENGTH ON THE
LEFT SIDE AND THE ADDRESS OF <ARRAY ON THE RIGHT.  <AC IS SET TO
THE VALUE OF THE ACCUMULATOR ON RETURN AND <ERRFLG IS SET IF
THE ERROR RETURN WAS TAKEN.
.SKIP 2
.CENTER; ******************** MODULE <USRDDT ********************
.SKIP 2
.CENTER; <SUBROUTINE <SYMWRD( <WORD, <SIXNAM, <ACNUM,
.CENTER; <IND, <INDAC, <DEST )
.P; ^TAKES THE SIXBIT INSTRUCTION IN <SIXNAM WITH THE <AC SPECIFIED
IN <ACNUM, THE INDIRECT <AC IN <INDAC, THE RIGHT HALF OF THE WORD
IN <DEST, AND CREATES THE MACHINE CODE INSTRUCTION <WORD WITH THE
INDIRECT BIT SET IF <IND IS TRUE.  ^THE FOLLOWING SYMBOL TYPES ARE
AVAILABLE:
.LM 20
.BREAK; ^NORMAL INSTRUCTIONS
.BREAK; ^USER <I/O INSTRUCTIONS
.BREAK; ^EXTENDED USER FUNCTIONS
.BREAK; <MTAPE SYMBOLS
.BREAK; <UUO'\S (^MONITOR CALLS), <TOPS10 601 TO 701
.BREAK; ^SPECIAL <JFCL SYMBOLS
.BREAK; ^SPECIAL <JRST SYMBOLS
.BREAK; <TTCALL SYMBOLS (I.E. <CLRBFI'\S ETC)
.BREAK; ^SPECIAL USER <I/O SYMBOLS (<SWPIO, <APRID, ETC)
.LM 5
.BREAK; SIXBIT DEVICE NAMES ARE RETURNED IN <ACNUM WITH USER <I/O
INSTRUCTIONS.
.SKIP 2
.CENTER; <SUBROUTINE <WRDSYM( <WORD, <SIXNAM, <ACNUM,
.CENTER; <IND, <INDAC, <DEST [,<SIMPLE] )
.P; ^PARSE THE MACHINE CODE INSTRUCTION <WORD INTO ITS SIXBIT NAME
<SIXNAM, <AC <ACNUM, INDIRECT <AC <INDAC, RIGHT HALF OF WORD <DEST
AND SET <IND IF THE INDIRECT BIT IS ON.  ^IF <SIMPLE IS ZERO,
ALL SYMBOLS AVAILABLE ARE RETURNED (I.E. <HALT VS. <JRST 4,).  ^IF
<SIMPLE IS NEGATIVE ONE, USE THE SIMPLER VERSION.  ^IF <SIMPLE IS 
NEGATIVE TWO, USER <I/O INSTRUCTIONS WILL STILL RETURN SIXBIT DEVICE
NAMES IN THE ACCUMULATOR FIELD.
.SKIP 2
.CENTER; ******************** MODULE <RANDOM ********************
.SKIP 2
.CENTER; <INTEGER <FUNCTION <IRAN( <RANGE )
.P; ^RETURN A RANDOM INTEGER BETWEEN 1 AND <RANGE.
.SKIP 2
.CENTER; <REAL <FUNCTION <ARAN( <RANGE )
.P; ^RETURN A REAL RANDOM NUMBER BETWEEN 0 AND <RANGE.
.SKIP 2
.CENTER; ******************** MODULE <UPP ********************
.SKIP 2
.CENTER; <SUBROUTINE <PLOTON( <PLTYPE, <ICHAN )
.P; ^SET PLOT DESTINATION TO ONE OF THREE PLACES:  <PLTYPE=1:
<INTECOLOR, <PLTYPE=2: <TEKTRONIX, <PLTYPE=3: <CALCOMP PLOTTER.
^OUTPUT CHANNEL IS SPECIFIED IN <ICHAN.
.SKIP 2
.CENTER; <SUBROUTINE <PENTER
.P; ^ENTER PLOTTING MODE.
.SKIP 2
.CENTER; <SUBROUTINE <PORG( <X, <Y )
.P; ^SET THE ORIGIN TO <X-Y RELATIVE TO THE CURRENT ORIGIN.
.SKIP 2
.CENTER; <SUBROUTINE <PFACTR( <FACTOR )
.P; ^SET THE SCALING FACTOR TO <FACTOR TIMES THE CURRENT FACTOR
(IF <FACTOR=0, RESET TO SCALING FACTOR OF 1.0).  ^ORIGINALLY
ALL COORDINATES ARE BASED ON A PLANE WHERE <X AND <Y RANGE FROM
0.0 TO 1.0.
.SKIP 2
.CENTER; <SUBROUTINE <PMOVE( <X, <Y )
.P; ^MOVE THE "PEN" TO <X-Y.
.SKIP 2
.CENTER; <SUBROUTINE <PMOVER( <X, <Y )
.P; ^MOVE THE "PEN" TO <X-Y RELATIVE TO THE CURRENT <X-Y.
.SKIP 2
.CENTER; <SUBROUTINE <PDRAW( <X, <Y )
.P; ^DRAW A LINE FROM THE CURRENT POSITION TO <X-Y.
.SKIP 2
.CENTER; <SUBROUTINE <PDRAWR( <X, <Y )
.P; ^DRAW A LINE FROM THE CURRENT POSITION TO <X-Y RELATIVE
TO THE CURRENT <X-Y.
.SKIP 2
.CENTER; <SUBROUTINE <PEXIT
.P; ^EXIT PLOTTING MODE.
.SKIP 2
.CENTER; <SUBROUTINE <POFFST( <XOFF, <XFACT, <YOFF, <YFACT )
.P; ^SET FACTORS FOR POSITION CALCULATIONS:
.LM 10
.BREAK; <NX=(XOFF+X)*XFACT
.BREAK; <NY=(YOFF+Y)*YFACT
.LM 5
.SKIP 2
.CENTER; <SUBROUTINE <PWHERE( <X, <Y, <FACTOR )
.P; ^RETURN THE CURRENT <X-Y POSITION OF THE "PEN" AND THE
CURRENT FACTOR.
.SKIP 2
.CENTER; <SUBROUTINE <PCOLOR( <COLOR )
.P; ^SET THE "PEN" COLOR TO:
.LM 10
.BREAK; <COLOR
.BREAK; 1 - WHITE(<ISC), GREEN(<TEK), BLACK(<CALCOMP)
.BREAK; 2 - DARK BLUE, GREEN(<TEK)
.BREAK; 3 - RED, GREEN(<TEK)
.BREAK; 4 - LIGHT BLUE(<ISC), GREEN(<TEK), BLACK(<CALCOMP)
.BREAK; 5 - PURPLE(<ISC), GREEN(<TEK), BLUE(<CALCOMP)
.BREAK; 6 - GREEN, RED(<CALCOMP)
.BREAK; 7 - YELLOW(<ISC), GREEN(<TEK), BLACK(<CALCOMP)
.BREAK; 8 - BLACK(<ISC), GREEN(<TEK), BLUE(<CALCOMP)
.LM 5
.SKIP 2
.CENTER; <SUBROUTINE <PBACK( <COLOR )
.P; ^SET BACKGROUND COLOR ON <ISC TO <COLOR.
.SKIP 2
.CENTER; <SUBROUTINE <PBLON
.P; ^TURN BLINK ON FOR <ISC.
.SKIP 2
.CENTER; <SUBROUTINE <PBLOFF
.P; ^TURN BLINK OFF FOR <ISC.
.SKIP 2
.CENTER; <SUBROUTINE <PCURSR( <ICHAR, <X, <Y )
.P; ^FOR <TEKTRONIX: ^WAIT FOR THE USER TO TYPE A CHARACTER
(RETURNED IN <R1 FORMAT IN <ICHAR) AND RETURN THE <X-Y POSITION
OF THE CROSS HAIRS.
.SKIP 2
.CENTER; <SUBROUTINE <PLTSYM( <ICHAR, <X, <Y, <HEIGHT, <ANGLE )
.P; ^PLOT THE CHARACTER <ICHAR (<R1 FORMAT) AT <X-Y AT <ANGLE
DEGREES WITH THE CHARACTER ^HEIGHT UNITS TALL.
.SKIP 2
.CENTER; <SUBROUTINE <PSTR( <ARRAY, <X, <Y, <HEIGHT, <ANGLE, <LENGTH )
.P; ^PLOT THE <A5 FORMATTED STRING <ARRAY (<LENGTH CHARACTERS LONG)
STARTING AT <X-Y AT <ANGLE DEGREES WITH CHARACTERS <HEIGHT UNITS
TALL.
.SKIP 2
.CENTER; <SUBROUTINE <PNUM( <FLONUM, <X, <Y, <HEIGHT, <ANGLE, <NDEC )
.P; ^PLOT A FLOATING POINT NUMBER WITH <NDEC DIGITS TO THE RIGHT
OF THE DECIMAL POINT.
